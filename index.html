<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Crow&#039;s Sky</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Crow&#039;s Sky"><meta name="msapplication-TileImage" content="/img/avatarCircle.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Crow&#039;s Sky"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Crow&#039;s Sky"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Crow&#039;s Sky"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="White Crow"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Crow's Sky","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"white crow"},"publisher":{"@type":"Organization","name":"Crow's Sky","logo":{"@type":"ImageObject","url":"http://example.com/img/avatarCircle.png"}},"description":""}</script><link rel="icon" href="/img/avatarCircle.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/WhileCrow"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-10-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-08-08T00:20:27.000Z" title="8/8/2024, 8:20:27 AM">2024-08-08</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-08-09T03:47:24.209Z" title="8/9/2024, 11:47:24 AM">2024-08-09</time></span><span class="level-item"><a class="link-muted" href="/categories/Common/">Common</a><span> / </span><a class="link-muted" href="/categories/Common/JavaBasic/">JavaBasic</a></span><span class="level-item">3 minutes read (About 426 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/08/08/JIT&amp;AOT/">Thread</a></h1><div class="content"><p><img src="/2024/08/08/JIT&AOT/image-20210602170532688.png" alt="image-20210602170532688"></p>
<p>对于dalvik虚拟机而言其检测到执行频率较高的函数时就会进行jit编译将其编译为本地机器码，这样下次此函数执行的时候就会直接执行编译后的机器码，编译后的机器码只存在于内存中并不会以文件的形式保存，app重启后此函数依然会以解释模式执行。在JIT编译函数生成机器码的同时还会生成配置文件profile记录热点函数信息，供AOT守护进程使用编译生成oat文件，以提速执行。</p>
<p>以下为JIT工作流：</p>
<p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/14335/1720605390695-15111b6b-42a6-4dde-b5d8-49bd7d2417bc.png" alt="img"></p>
<p>但在我们测试中 AE 无论运行多少次启动阶段依然有JIT的运行，但TEMU在启动阶段JIT是无执行的，判断TEMU已做了AOT优化。</p>
<p>AOT事前编译，即在代码运行前进行编译。对于android 7.0之前的art虚拟机而言其会在apk安装的过程中利用dex2oat程序将apk中的dex文件编译为本地机器指令并保存为oat文件，这样在apk启动时直接加载此oat文件并运行，提高了程序了执行效率。但是因为他需要在apk安装的时候使用dex2oat程序进行编译，所以增加了apk在安装过程中的时间。</p>
<p>通过AOT优化的中端机有100ms收益</p>
<p>该优化需要对APP内所有工程做改造，升级AGP后，进行BaselineProfile优化</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-07-26T00:20:27.000Z" title="7/26/2024, 8:20:27 AM">2024-07-26</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-08-09T03:43:52.576Z" title="8/9/2024, 11:43:52 AM">2024-08-09</time></span><span class="level-item"><a class="link-muted" href="/categories/Common/">Common</a><span> / </span><a class="link-muted" href="/categories/Common/JavaBasic/">JavaBasic</a></span><span class="level-item">29 minutes read (About 4385 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/07/26/Tread/">Thread</a></h1><div class="content"><h1 id="线程-进程"><a href="#线程-进程" class="headerlink" title="线程/进程"></a>线程/进程</h1><p><strong>进程</strong>：进程是系统进行资源分配和调度的一个独立单位 (拥有独立内存空间)，一个app就是一个进程，进程包含线程。</p>
<p><strong>线程</strong>：是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一些在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
<p><strong>静态</strong>的是资源和<strong>动态</strong>的是计算</p>
<ol>
<li><p>进程是一个资源的容器，为进程里的所有线程提供共享资源，是对程序的一种静态描述</p>
</li>
<li><p>线程是计算机最小的<u>调度和运行</u>（计算）单位，是对程序的一种动态描述</p>
</li>
</ol>
<h2 id="Java里的线程有哪些状态？"><a href="#Java里的线程有哪些状态？" class="headerlink" title="Java里的线程有哪些状态？"></a>Java里的线程有哪些状态？</h2><p>JDK中，线程（Thread）定义了6种状态： NEW（新建）、RUNNABLE（可执行）、BLOCKED（阻塞）、WAITING（等待）、TIMED_WAITING（限时等待）、TERMINATED（结束）。</p>
<p>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * A thread state.  A thread can be in one of the following  states:</span><br><span class="line"> * &lt;ul&gt;</span><br><span class="line"> * &lt;li&gt;&#123;@link #NEW&#125;</span><br><span class="line"></span><br><span class="line"> *     A thread that has not yet started is in this state.</span><br><span class="line"> *     &lt;&#x2F;li&gt;</span><br><span class="line"> * &lt;li&gt;&#123;@link #RUNNABLE&#125;</span><br><span class="line"></span><br><span class="line"> *     A thread executing in the Java virtual machine is in  this state.</span><br><span class="line"> *     &lt;&#x2F;li&gt;</span><br><span class="line"> * &lt;li&gt;&#123;@link #BLOCKED&#125;</span><br><span class="line"></span><br><span class="line"> *     A thread that is blocked waiting for a monitor lock</span><br><span class="line"> *     is in this state.</span><br><span class="line"> *     &lt;&#x2F;li&gt;</span><br><span class="line"> * &lt;li&gt;&#123;@link #WAITING&#125;</span><br><span class="line"></span><br><span class="line"> *     A thread that is waiting indefinitely for another  thread to</span><br><span class="line"> *     perform a particular action is in this state.</span><br><span class="line"> *     &lt;&#x2F;li&gt;</span><br><span class="line"> * &lt;li&gt;&#123;@link #TIMED_WAITING&#125;</span><br><span class="line"></span><br><span class="line"> *     A thread that is waiting for another thread to perform  an action</span><br><span class="line"> *     for up to a specified waiting time is in this state.</span><br><span class="line"> *     &lt;&#x2F;li&gt;</span><br><span class="line"> * &lt;li&gt;&#123;@link #TERMINATED&#125;</span><br><span class="line"></span><br><span class="line"> *     A thread that has exited is in this state.</span><br><span class="line"> *     &lt;&#x2F;li&gt;</span><br><span class="line"> * &lt;&#x2F;ul&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * A thread can be in only one state at a given point in  time.</span><br><span class="line"> * These states are virtual machine states which do not  reflect</span><br><span class="line"> * any operating system thread states.</span><br><span class="line"> *</span><br><span class="line"> * @since   1.5</span><br><span class="line"> * @see #getState</span><br><span class="line"> *&#x2F;</span><br><span class="line">public enum State &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Thread state for a thread which has not yet started.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    NEW,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Thread state for a runnable thread.  A thread in the  runnable</span><br><span class="line">     * state is executing in the Java virtual machine but it  may</span><br><span class="line">     * be waiting for other resources from the operating  system</span><br><span class="line">     * such as processor.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Thread state for a thread blocked waiting for a  monitor lock.</span><br><span class="line">     * A thread in the blocked state is waiting for a monitor  lock</span><br><span class="line">     * to enter a synchronized block&#x2F;method or</span><br><span class="line">     * reenter a synchronized block&#x2F;method after calling</span><br><span class="line">     * &#123;@link Object#wait() Object.wait&#125;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    BLOCKED,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Thread state for a waiting thread.</span><br><span class="line">     * A thread is in the waiting state due to calling one of  the</span><br><span class="line">     * following methods:</span><br><span class="line">     * &lt;ul&gt;</span><br><span class="line">     *   &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no  timeout&lt;&#x2F;li&gt;</span><br><span class="line">     *   &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;&#x2F;li&gt;</span><br><span class="line">     *   &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;&#x2F;li&gt;</span><br><span class="line">     * &lt;&#x2F;ul&gt;</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;A thread in the waiting state is waiting for  another thread to</span><br><span class="line">     * perform a particular action.</span><br><span class="line">     *</span><br><span class="line">     * For example, a thread that has called  &lt;tt&gt;Object.wait()&lt;&#x2F;tt&gt;</span><br><span class="line">     * on an object is waiting for another thread to call</span><br><span class="line">     * &lt;tt&gt;Object.notify()&lt;&#x2F;tt&gt; or  &lt;tt&gt;Object.notifyAll()&lt;&#x2F;tt&gt; on</span><br><span class="line">     * that object. A thread that has called  &lt;tt&gt;Thread.join()&lt;&#x2F;tt&gt;</span><br><span class="line">     * is waiting for a specified thread to terminate.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    WAITING,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Thread state for a waiting thread with a specified  waiting time.</span><br><span class="line">     * A thread is in the timed waiting state due to calling  one of</span><br><span class="line">     * the following methods with a specified positive  waiting time:</span><br><span class="line">     * &lt;ul&gt;</span><br><span class="line">     *   &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;&#x2F;li&gt;</span><br><span class="line">     *   &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with  timeout&lt;&#x2F;li&gt;</span><br><span class="line">     *   &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with  timeout&lt;&#x2F;li&gt;</span><br><span class="line">     *   &lt;li&gt;&#123;@link LockSupport#parkNanos  LockSupport.parkNanos&#125;&lt;&#x2F;li&gt;</span><br><span class="line">     *   &lt;li&gt;&#123;@link LockSupport#parkUntil  LockSupport.parkUntil&#125;&lt;&#x2F;li&gt;</span><br><span class="line">     * &lt;&#x2F;ul&gt;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Thread state for a terminated thread.</span><br><span class="line">     * The thread has completed execution.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://assets.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h3 id="状态说明"><a href="#状态说明" class="headerlink" title="状态说明"></a>状态说明</h3><p>线程在一个给定的时间点只能处于下面其中一种状态：</p>
<p>这些状态是虚拟机状态，并不能反映任何操作系统的线程状态。</p>
<ul>
<li><p>NEW：尚未启动的线程处于这个状态。Thread thread = new Thread(new Runnable(){…});处于这个状态。</p>
</li>
<li><p>RUNNABLE：可运行的线程处于这个状态。对应操作系统中的两种状态：ready和running，也就是说RUNNABLE状态既可以是可运行的，也可以是实际运行中的，有可能正在执行，也有可能没有正在执行。关于这个问题的理解，可以对比想一下，thread.start()调用之后线程会立刻执行吗？</p>
</li>
<li><p>BLOCKED：阻塞，<strong>进入synchronized修饰的方法或者代码块，等待监视器锁的线程</strong>处于这个状态。</p>
</li>
<li><p>WAITING：无限期等待另一个线程执行特定操作的线程处于这种状态。</p>
</li>
<li><p>TIMED_WAITING：正在等待另一个线程执行某个操作的线程在指定的等待时间内处于这种状态。</p>
</li>
<li><p>TERMINATED：已经退出的线程处于这个状态。</p>
</li>
</ul>
<h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><p>NEW：线程尚未启动的线程状态。当在程序中创建一个线程的时候Thread t = new Thread(Runnable);，线程处于NEW状态。</p>
<p>RUNNABLE：可运行线程的线程状态。处于可运行状态的线程正在Java虚拟机中执行，但它可能正在等待操作系统中的其他资源，比如处理器。也就是说， 这个状态就是可运行也可不运行的状态。注意Runnable ≠ Running。</p>
<p>BLOCKED：进入synchronized修饰的方法或者代码块，等待监视器锁的阻塞线程的线程状态。比如，线程试图通过synchronized去获取监视器锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。等到获得了监视器锁之后会再次进入RUNNABLE状态。</p>
<p>WAITING：调用以下方法之一，线程会处于等待状态：</p>
<ul>
<li>Object.wait()注意：括号内不带参数；</li>
<li>Thread.join()注意：扩号内不带参数；</li>
<li>LockSupport.park()；</li>
</ul>
<p>其实wait()方法有多重形式，可以不带参数，可以带参数，参数表示等待时间（单位ms），如图所示：</p>
<p><img src alt="img"><img src="/2024/07/26/Tread/1538609-20220626174204766-251050442.png" alt="img"></p>
<p>“BLOCKED（阻塞状态）”和“WAITING（等待状态）”的区别：阻塞状态在等待获取一个排它锁，这个事件将会在另外一个线程放弃这个锁的时候发生，然后由阻塞状态变为可执行状态；而等待状态则是在等待一段时间，或者等待唤醒动作的发生。</p>
<p>TIMED_WAITING：一个线程调用了以下方法之一（方法需要带具体的等待时间），会处于定时等待状态：</p>
<ul>
<li>Thread.sleep(long timeout)</li>
<li>Object.wait(long timeout)</li>
<li>Thread.join(long timeout)</li>
<li>LockSupport.parkNanos()</li>
<li>LockSupport.parkUntil()</li>
</ul>
<p>TERMINATED：  该线程已经执行完毕。执行完毕指的是线程正常执行完了run方法之后退出，也可以是遇到了未捕获的异常而退出。</p>
<p><img src="/2024/07/26/Tread/1538609-20220626174204590-1253779990.png" alt="img"></p>
<h3 id="初始-NEW"><a href="#初始-NEW" class="headerlink" title="初始(NEW)"></a>初始(NEW)</h3><p>新创建了一个线程对象，但还没有调用start()方法。</p>
<h3 id="运行-RUNNABLE"><a href="#运行-RUNNABLE" class="headerlink" title="运行(RUNNABLE)"></a>运行(RUNNABLE)</h3><h4 id="Ready"><a href="#Ready" class="headerlink" title="Ready"></a>Ready</h4><h4 id="Running"><a href="#Running" class="headerlink" title="Running"></a>Running</h4><p>Java线程中将就绪（ready）和运行中（running）两种状态笼统 的称为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方 法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此 时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态 （running）。</p>
<h3 id="阻塞-BLOCKED"><a href="#阻塞-BLOCKED" class="headerlink" title="阻塞(BLOCKED)"></a>阻塞(BLOCKED)</h3><p>表示线程阻塞于锁。或称“挂起”</p>
<blockquote>
<p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间</p>
</blockquote>
<h3 id="等待-WAITING"><a href="#等待-WAITING" class="headerlink" title="等待(WAITING)"></a>等待(WAITING)</h3><p>等待状态，处于等待状态的线程是由于执行了<strong>Thread.join</strong>或<strong>Object.wait</strong>方法</p>
<p> 处于waiting状态的线程会等待另外一个线程处理特殊的行为。 再举个例子，如果一个线程调用了一个对象的wait方法，那么这个线程就会处于waiting状态直到另外一个线程调用这个对象的notify或者notifyAll方法后才会解除这个状态</p>
<h3 id="超时等待-TIMED-WAITING"><a href="#超时等待-TIMED-WAITING" class="headerlink" title="超时等待(TIMED_WAITING)"></a>超时等待(TIMED_WAITING)</h3><p>有等待时间的等待状态，比如调用了**Thread.sleep(long timeout)、Thread.join(long timeout)、Object.wait(long timeout)**，并且指定了等待时间，线程就会处于这个状态。 </p>
<h3 id="终止-TERMINATED"><a href="#终止-TERMINATED" class="headerlink" title="终止(TERMINATED)"></a>终止(TERMINATED)</h3><p>表示该线程已经执行完毕。</p>
<blockquote>
<p>对比分析Java中的各个线程相关的wait()、notify()、sleep()、interrupt()方法</p>
</blockquote>
<h1 id="线程相关方法"><a href="#线程相关方法" class="headerlink" title="线程相关方法"></a>线程相关方法</h1><h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><h4 id="sleep：暂停当前正在执行的线程；（类方法）"><a href="#sleep：暂停当前正在执行的线程；（类方法）" class="headerlink" title="sleep：暂停当前正在执行的线程；（类方法）"></a>sleep：暂停当前正在执行的线程；（<strong>类方法</strong>）</h4><p>​    是Thread的静态方法，很显然它是让当前线程按照指定的时间休眠，其休眠时间的精度取决于处理器的计时器和调度器。需要注意的是如果当前线程获得了锁，sleep方法并不会失去锁。sleep方法经常拿来与Object.wait()方法进行比价，这也是面试经常被问的地方。</p>
<blockquote>
<p><strong>sleep() VS wait()</strong></p>
</blockquote>
<p>  两者主要的区别：</p>
<pre><code>1. sleep()方法是Thread的静态方法，而wait是Object实例方法
2. wait()方法必须要在同步方法或者同步块中调用，也就是必须已经获得对象锁。而sleep()方法没有这个限制可以在任何地方种使用。另外，wait()方法会释放占有的对象锁，使得该线程进入等待池中，等待下一次获取资源。而sleep()方法只是会让出CPU并不会释放掉对象锁；
3. sleep()方法在休眠时间达到后如果再次获得CPU时间片就会继续执行，而wait()方法必须等待Object.notift/Object.notifyAll通知后，才会离开等待池，并且再次获得CPU时间片才会继续执行。
</code></pre>
<h4 id="yield：暂停当前正在执行的线程，并执行其他线程；（类方法）"><a href="#yield：暂停当前正在执行的线程，并执行其他线程；（类方法）" class="headerlink" title="yield：暂停当前正在执行的线程，并执行其他线程；（类方法）"></a>yield：暂停当前正在执行的线程，并执行其他线程；（<strong>类方法</strong>）</h4><p>​    是Thread的静态方法，一旦执行，它会是当前线程让出CPU，但是，需要注意的是，让出的CPU并不是代表当前线程不再运行了，如果在下一次竞争中，又获得了CPU时间片当前线程依然会继续运行。另外，让出的时间片只会分配<strong>给当前线程相同优先级</strong>的线程。</p>
<p>​    yield()方法使当前线程出让CPU执行时间，但并不会释放当前线程所持有的锁。执行完yield()方法后，线程从Running状态转变为Runnable状态，既然是Runnable状态，那么也很可能马上会被CPU调度再次进入Running状态。</p>
<blockquote>
<p>什么是线程优先级了？下面就来具体聊一聊。</p>
<p>现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当前时间片用完后就会发生线程调度，并等待这下次分配。线程分配到的时间多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要或多或少分配一些处理器资源的线程属性。</p>
<p>在Java程序中，通过一个<strong>整型成员变量Priority</strong>来控制优先级，优先级的范围从1~10.在构建线程的时候可以通过**setPriority(int)**方法进行设置，默认优先级为5，优先级高的线程相较于优先级低的线程优先获得处理器时间片。需要注意的是在不同JVM以及操作系统上，线程规划存在差异，有些操作系统甚至会忽略线程优先级的设定。</p>
<p>另外需要注意的是，sleep()和yield()方法，同样都是当前线程会交出处理器资源，而它们不同的是，sleep()交出来的时间片其他线程都可以去竞争，也就是说都有机会获得当前线程让出的时间片。而yield()方法只允许与当前线程具有相同优先级的线程能够获得释放出来的CPU时间片。</p>
</blockquote>
<h4 id="join：等待该线程终止；"><a href="#join：等待该线程终止；" class="headerlink" title="join：等待该线程终止；"></a>join：等待该线程终止；</h4><p>​    join()方法的作用，是等待这个线程结束，是主线程等待子线程的终止。也就是说主线程的代码块中，如果碰到了t.join()方法，此时主线程需要等待（阻塞），等待子线程结束了(Waits for this thread to die.),才能继续执行t.join()之后的代码块。</p>
<h4 id="interrupt：中断该线程，"><a href="#interrupt：中断该线程，" class="headerlink" title="interrupt：中断该线程，"></a>interrupt：中断该线程，</h4><p>interrupt()方法的工作仅仅是改变中断状态，并不是直接中断正在运行的线程。中断的真正原理是当线程被Object.wait(),Thread.join()或sleep()方法阻塞时，调用interrupt()方法后改变中断状态，而wait/join/sleep这些方法内部会不断地检查线程的中断状态值，当发现中断状态值改变时则抛出InterruptedException异常；对于没有阻塞的线程，调用interrupt()方法是没有任何作用。</p>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><ul>
<li>wait：暂停当前正在执行的线程，直到调用notify()或notifyAll()方法或超时，退出等待状态；</li>
<li>notify：唤醒在该对象上等待的一个线程；</li>
<li>notifyAll：唤醒在该对象上等待的所有线程；</li>
</ul>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><h3 id="sleep-VS-wait"><a href="#sleep-VS-wait" class="headerlink" title="sleep VS wait"></a>sleep VS wait</h3><p>sleep()和wait()方法都是暂停当前正在执行的线程，出让CPU资源。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">所属类</th>
<th align="left">方法类型</th>
<th align="left">锁</th>
<th align="left">解除方法</th>
<th align="left">场景</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">sleep</td>
<td align="left">Thread</td>
<td align="left">静态方法</td>
<td align="left">不释放锁</td>
<td align="left">timeout,interrupt</td>
<td align="left">无限制</td>
<td align="left">线程内的控制</td>
</tr>
<tr>
<td align="left">wait</td>
<td align="left">Object</td>
<td align="left">非静态方法</td>
<td align="left">释放锁</td>
<td align="left">timeout,notify,interrupt</td>
<td align="left">同步语句块</td>
<td align="left">线程间的通信</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException </span></span><br><span class="line"><span class="function">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span></span><br><span class="line"><span class="function"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException </span></span><br><span class="line"><span class="function"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure>

<h3 id="wait-amp-amp-notify"><a href="#wait-amp-amp-notify" class="headerlink" title="wait &amp;&amp; notify"></a>wait &amp;&amp; notify</h3><p>调用对象的wait()、notify()、notifyAll()方法的线程，必须是作为此对象监视器的所有者。常见的场景便是就是synchronized关键字的语句块内部使用这3个方法，如果直接在线程中使用wait()、notify()、notifyAll()方法，那么会抛出异常IllegalMonitorStateException，抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。。</p>
<p>调用wait()方法的线程，在调用该线程的interrupt()方法，则会重新尝试获取对象锁。只有当获取到对象锁，才开始抛出相应的异常，则执行该线程之后的程序。</p>
<h2 id="怎么终止一个线程"><a href="#怎么终止一个线程" class="headerlink" title="怎么终止一个线程"></a>怎么终止一个线程</h2><p>首先，一个<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%BA%BF%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:89431513%7D">线程</a>不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。</p>
<p>所以，Thread.stop, Thread.suspend, Thread.resume 都已经被废弃了。</p>
<h3 id="interrupt："><a href="#interrupt：" class="headerlink" title="interrupt："></a>interrupt：</h3><p>Thread.interrupt 的作用其实也不是<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:89431513%7D">中断线程</a>，而是「通知线程应该中断了」，</p>
<p>具体到底中断还是继续运行，应该由被通知的线程自己处理。</p>
<p>具体来说，当对一个线程，调用 interrupt() 时，</p>
<p>① 如果线程处于被<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:89431513%7D">阻塞状态</a>（例如处于sleep, wait, join 等状态），那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。仅此而已。</p>
<p>② 如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true，仅此而已。被设置<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%B8%AD%E6%96%AD%E6%A0%87%E5%BF%97&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:89431513%7D">中断标志</a>的线程将继续正常运行，不受影响。</p>
<p><strong>interrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行。</strong></p>
<p>① 在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程。</p>
<p>② 在调用<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E9%98%BB%E5%A1%9E%E6%96%B9%E6%B3%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:89431513%7D">阻塞方法</a>时正确处理InterruptedException异常。（例如，catch异常后就结束线程。）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">    while (!Thread.interrupted()) &#123;</span><br><span class="line">        // do more work.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line">// 一段时间以后</span><br><span class="line">thread.interrupt();</span><br></pre></td></tr></table></figure>





<h3 id="stop"><a href="#stop" class="headerlink" title="stop():"></a>stop():</h3><p>弃用，因为在stop时会释放所有的锁，可能导致线程不同步，另一个也可能导致资源如文件文件数据库的关闭行为不被执行</p>
<blockquote>
<ol>
<li>调用 stop() 方法会立刻停止 run() 方法中剩余的全部工作，包括在 catch 或 finally 语句中的，并抛出ThreadDeath异常(通常情况下此异常不需要显示的捕获)，因此可能会导致一些清理性的工作的得不到完成，如文件，数据库等的关闭。</li>
<li>调用 stop() 方法会立即释放该线程所持有的所有的锁，导致数据得不到同步，出现数据不一致的问题。</li>
</ol>
</blockquote>
<h3 id="使用volatile标志位"><a href="#使用volatile标志位" class="headerlink" title="使用volatile标志位"></a>使用volatile标志位</h3><p>以标志位为循环条件 </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-07-08T09:20:14.000Z" title="7/8/2024, 5:20:14 PM">2024-07-08</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-07-25T09:18:59.126Z" title="7/25/2024, 5:18:59 PM">2024-07-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Common/">Common</a><span> / </span><a class="link-muted" href="/categories/Common/Network/">Network</a></span><span class="level-item">11 minutes read (About 1698 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/07/08/Https/">Https</a></h1><div class="content"><h1 id="Http和Https"><a href="#Http和Https" class="headerlink" title="Http和Https"></a>Http和Https</h1><ul>
<li>其实HTTPS就是从 HTTP 加上 SSL/TLS （加密处理+认证+完整性保护）</li>
</ul>
<p>完整的https通信过程，三次RTT：tcp握手一次RTT，TLS握手两次RTT</p>
<p><img src="/2024/07/08/Https/b25fb999193d980d1419422cea9f8eb9322855.png" alt="img"></p>
<h2 id="HTTPS工作原理"><a href="#HTTPS工作原理" class="headerlink" title="HTTPS工作原理"></a>HTTPS工作原理</h2><p><img src="/2024/07/08/Https/141293392-2748beda-9928-4efd-97aa-ec81b38b83e2.png" alt="image"></p>
<ul>
<li>一、首先客户端发起连接请求，将自身支持的加密（RSA）和哈希算法（sha256）连带发给服务器（服务器端有非对称加密的公钥和私钥）</li>
<li>二、服务器端接受请求，选取一组加密和哈希算法后，将服务器证书（含公钥）发送给客户端</li>
<li>三、客户端收到服务器端证书并使用根证书验证证书后，从中取出公钥，然后本地生成一段随机数，将此随机数用公钥加密后发送给服务器端</li>
<li>四、服务器端用私钥解密出这段随机数作为对称加密的秘钥。之后双方就可以进行对称加密（DES、AES等）。</li>
</ul>
<h2 id="证书校验过程"><a href="#证书校验过程" class="headerlink" title="证书校验过程"></a>证书校验过程</h2><p>校验证书的过程：</p>
<p><strong>第一步是校验证书网站域名、有效期等。</strong></p>
<p><strong>第二步是校验证书本身是否可信：主要是依靠验证证书的信任链条完成。</strong></p>
<p>  <strong>比如根证书A-&gt;B-&gt;服务端证书C，那么首先要验证C是由B签署的，这一步的具体步骤是：</strong></p>
<pre><code>1. **用B证书的公钥解密C证书的签名信息后拿到C证书的hash值（签署时该Hash值由B的私钥加密生成），**
2. **然后再用hash算法（B证书上带的签名算法）计算B证书的&lt;u&gt;待签名数据&lt;/u&gt;后得到计算hash值，**
3. **将证书解密的hash值与计算hash值比较即可。**
</code></pre>
<p><strong>第三步是使用CRL（证书吊销列表）或OCSP（在线证书状态协议）确认证书是否已被吊销。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">证书内容可简化为:</span><br><span class="line">待签名数据：</span><br><span class="line">  版本: v3</span><br><span class="line">  序列号: 123456</span><br><span class="line">  签名算法: SHA256withRSA</span><br><span class="line">  颁发者信息: CN&#x3D;A, O&#x3D;A Corporation, C&#x3D;US</span><br><span class="line">  有效期: 2022-01-01 至 2023-01-01</span><br><span class="line">  主题信息: CN&#x3D;B, O&#x3D;B Corporation, C&#x3D;US</span><br><span class="line">  主题公钥: (公钥数据)</span><br><span class="line">  扩展字段: (可选)</span><br><span class="line">签名：</span><br><span class="line">  签名: (签名数据)</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/08/Https/image-20240703175159171.png" alt="image-20240703175159171"></p>
<img src="/2024/07/08/Https/image-20211123141219076.png" alt="image-20211123141219076" style="zoom:30%;">

<img src="/2024/07/08/Https/image-20211123141130160.png" alt="image-20211123141130160" style="zoom:50%;">





<h2 id="抓包软件怎么实现的"><a href="#抓包软件怎么实现的" class="headerlink" title="抓包软件怎么实现的"></a>抓包软件怎么实现的</h2><p>以我熟悉的抓包软件<strong>whistle</strong>为例，抓包软件能抓https内容的核心是：你的手机安装了<strong>whistle的自签名根证书</strong>，同时你的<strong>请求都是代理给whistle</strong>的，然后whistle会发送给客户端<strong>经自签名根证书签署过的伪造服务器证书</strong>，故而能通过客户端的证书校验，从而拿到请求原文。</p>
<p><strong>手机安装了抓包软件的自签名证书后，抓包工具在作为代理进行HTTPS流量捕获时，实际上充当了中间人。抓包开启后，客户端https请求的握手对象实际上是抓包软件，服务端拿到的请求地址是 抓包软件的地址。手机的请求也实际上是与抓包软件在交互，抓包软件再与服务器交互。故而抓包软件能记录并修改客户端的请求与响应</strong></p>
<p><img src="/2024/07/08/Https/image-20240703170642767.png" alt="image-20240703170642767"></p>
<p><strong>自签名证书</strong>：抓包软件生成一个自签名的证书（自签名证书是一种灵活且方便的SSL/TLS证书解决方案，是由证书的所有者自己签发的，适用于于开发测试环境和内部网络。然而，由于它不是由受信任的三方证书颁发机构即CA签发的，使得它无法提供可靠的身份验证，无法适用于公网）</p>
<ol>
<li><strong>客户端信任自签名证书</strong>：<ul>
<li>当用户在设备上安装抓包软件的自签名证书后，这个证书被设备作为受信任的根证书。设备会信任由这个自签名证书签发的所有证书。</li>
</ul>
</li>
<li><strong>中间人代理握手</strong>：<ul>
<li>抓包软件充当“中间人”，拦截客户端的HTTPS请求。客户端发出的请求首先到达抓包软件。</li>
<li>抓包软件向客户端提供一个由它自己的自签名根证书签署的伪造服务器证书（目标服务器的替身证书）。</li>
<li>因为客户端已经信任抓包软件的自签名证书，所以它会信任这个伪造的服务器证书，并与抓包软件进行TLS握手。</li>
</ul>
</li>
</ol>
<p>这样，手机上的浏览器或应用程序在连接时<strong>实际上是与抓包软件建立的https握手</strong>。</p>
<p>抓包软件的主要目的是捕获、分析和调试网络流量。其工作步骤如下：</p>
<ol>
<li><strong>客户端通过代理发送请求</strong>：<ul>
<li>抓包软件配置为代理，客户端配置通过此代理发送所有网络请求。</li>
<li>抓包软件生成一个自签名证书，客户端将其安装为受信任的根证书。</li>
</ul>
</li>
<li><strong>代理解析并再发送请求</strong>：<ul>
<li>客户端的请求首先由抓包软件接收。对于HTTPS请求，抓包软件会使用自签名证书解密这些请求。</li>
<li>抓包软件记录和分析解密后的请求内容，然后重新加密并发送到目标服务器。</li>
</ul>
</li>
<li><strong>服务器响应经过代理返回客户端</strong>：<ul>
<li>目标服务器返回响应，抓包软件解密并记录这些响应数据。</li>
<li>抓包软件再重新加密这些数据并发送回客户端。</li>
</ul>
</li>
</ol>
<p>VPN与抓包软件的原理类似，都是通过一层中间人，将客户端的请求实际上代理到中间人层发起请求。</p>
<p>不同的是由于抓包软件使客户端安装的自签名证书，客户端在证书校验时遇到抓包软件自签名证书签署的伪造服务器证书会校验通过，使客户端的请求都能在中间人层解密后查看和修改，之后抓包再转发。</p>
<p>而VPN则是通过加密隧道（加密整个传输链路）：使用协议如IPsec、OpenVPN、L2TP等），在原本就由ssl/tls加密的数据上再加密一层，之后无法感知传输内容原原本本的转发。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-07-04T06:15:34.945Z" title="7/4/2024, 2:15:34 PM">2024-07-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-07-04T06:15:34.945Z" title="7/4/2024, 2:15:34 PM">2024-07-04</time></span><span class="level-item"><a class="link-muted" href="/categories/Common/">Common</a><span> / </span><a class="link-muted" href="/categories/Common/Jvm/">Jvm</a></span><span class="level-item">5 minutes read (About 736 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/07/04/LeakType/">LeakType</a></h1><div class="content"><h1 id="内存泄漏实质"><a href="#内存泄漏实质" class="headerlink" title="内存泄漏实质"></a>内存泄漏实质</h1><p>内存泄漏实质上是GC时候，被GC Root引用或间接引用着的对象无法被回收，而可以作为GC Root的对象在java中有几种：</p>
<ol>
<li><p>虚拟机栈或叫JVM栈（栈帧中的本地变量表）中引用的对象； （线程泄露）</p>
<blockquote>
<p>虚拟机栈是<strong>线程私有的</strong>，每个java方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于<strong>存储局部变量表</strong>、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
</blockquote>
</li>
<li><p>方法区中的类静态属性引用的对象；  （static变量）</p>
<blockquote>
<p>方法区存储<strong>类信息、常量、静态变量</strong>等数据，是线程共享的区域</p>
</blockquote>
</li>
<li><p>本地方法栈中JNI（即一般说的Native方法）中引用的对象  （Jni持有的对象）</p>
<blockquote>
<p>对应虚拟机栈为虚拟机执行java方法服务，而本地方法栈为虚拟机使用到的Native方法服务</p>
</blockquote>
</li>
<li><p>方法区中常量引用的对象； （final修饰的int/float/long等基本数据类型和String）   不常见</p>
</li>
</ol></div><a class="article-more button is-small is-size-7" href="/2024/07/04/LeakType/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-06-04T03:37:41.537Z" title="6/4/2024, 11:37:41 AM">2024-06-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-06-04T03:37:41.538Z" title="6/4/2024, 11:37:41 AM">2024-06-04</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">3 minutes read (About 427 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/04/FirstScreenCost/">FirstScreenCost.md</a></h1><div class="content"><h1 id="Activity启动耗时"><a href="#Activity启动耗时" class="headerlink" title="Activity启动耗时"></a>Activity启动耗时</h1><p>首先：测试方法：</p>
<p>AMS会打印启动Activity的耗时，Android 10之后打印tag为ActivityTaskManager，Android10之前打印ActivityManager;</p>
<blockquote>
<p>在Android 10（Q）版本中，Android系统引入了ActivityTaskManager（ATM），并在很大程度上取代了之前的ActivityManagerService（AMS）的许多职责。具体来说，AMS负责管理整个系统的活动生命周期和任务堆栈，而在Android 10中，这些职责被重新分配并分离到新的ActivityTaskManager和ActivityManager中。</p>
<p>ActivityTaskManager专注于任务和活动的管理，处理任务堆栈的操作和活动的启动、切换等。而ActivityManager则更多地处理与应用进程管理相关的功能，如进程的生命周期、内存管理等。</p>
<p>这一改变是为了简化代码结构、提升系统的模块化和可维护性，同时也是为了更好地支持多窗口和多任务操作等新的特性。</p>
<p>总结起来，ActivityTaskManager的引入和实现从Android 10开始正式应用，取代了原有的部分ActivityManagerService的功能。</p>
</blockquote>
<p><strong>ActivityManager : Display / startActivity Android6/7</strong></p>
<p> 简单结论：display 只统计A onPause之后（不包含A onPause）</p>
<p>AMS 启动新ActivityB 并 执行 B的onCreate、onstart、onresume 与 B向WMS注册窗口到编舞者发起的第一次测绘 完成</p>
<p>Activity的启动可以分为三个步骤，以ActivityA启动ActivityB为例，三步骤分别为：</p>
<ol>
<li><p>以ActivityA调用startActivity，到ActivityA成功pause为止</p>
<p>displayTimeStart</p>
</li>
<li><p>ActivityB成功初始化，到执行完resume为止</p>
</li>
<li><p>ActivityB向WSM注册窗口，到第一帧绘制完成为止<br>displayTimeEnd</p>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-04-24T11:55:00.000Z" title="4/24/2024, 7:55:00 PM">2024-04-24</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-07-04T06:15:34.932Z" title="7/4/2024, 2:15:34 PM">2024-07-04</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">37 minutes read (About 5518 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/04/24/ThreadPool/">ThreadPool</a></h1><div class="content"><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment"> * parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment"> *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment"> *        核心线程数量，线程常驻即使空闲，除非设置了allowCoreThreadTimeOut</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment"> *        pool</span></span><br><span class="line"><span class="comment"> *        最大线程数，整个线程池的线程数量（核心线程数+普通线程数）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment"> *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment"> *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment"> *        超过核心线程数后的空闲线程存活时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment"> * 				时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment"> *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment"> *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment"> *        工作队列：任务被执行前的存放队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory the factory to use when the executor</span></span><br><span class="line"><span class="comment"> *        creates a new thread</span></span><br><span class="line"><span class="comment"> *        executor创建线程的工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler the handler to use when execution is blocked</span></span><br><span class="line"><span class="comment"> *        because the thread bounds and queue capacities are reached</span></span><br><span class="line"><span class="comment"> *        ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/24/ThreadPool/31bad766983e212431077ca8da92762050214.png" alt="图4 任务调度流程"></p>
<p>通过<code>Executors</code>工具类可以创建多种类型的线程池，包括：</p>
<ul>
<li><p><code>FixedThreadPool</code>：固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。<strong>核心线程数为n，最大线程数为n，任务队列长度为Interger.MAX_VALUE的LinkedBlockingQueue</strong></p>
</li>
<li><p><code>SingleThreadExecutor</code>： 只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。<strong>核心线程数、最大线程数都为1，任务队列长度为Interger.MAX_VALUE的LinkedBlockingQueue</strong></p>
</li>
<li><p><code>CachedThreadPool</code>： 可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。<strong>核心线程数为0，最大线程数为Interger.MAX_VAULE，任务队列为无容量的SynchronousQueue</strong></p>
</li>
<li><p><code>ScheduledThreadPool</code>：给定的延迟后运行任务或者定期执行任务的线程池。<strong>核心线程为n，最大线程为Interger.MAX_VALUE，任务队列长度为最大Interger_MAX_VALUE的DelayQueue</strong></p>
</li>
</ul>
<p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<p><code>Executors</code> 返回线程池对象的弊端如下：</p>
<ul>
<li><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code>:使用的是无界的 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
<li><code>CachedThreadPool</code>:使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM。</li>
<li><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code>:使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
</ul>
<h2 id="ThreadPoolExecutor使用详解"><a href="#ThreadPoolExecutor使用详解" class="headerlink" title="ThreadPoolExecutor使用详解"></a>ThreadPoolExecutor使用详解</h2><p>其实java线程池的实现原理很简单，说白了就是一个线程集合workerSet和一个阻塞队列workQueue。当用户向线程池提交一个任务(也就是线程)时，线程池会先将任务放入workQueue中。workerSet中的线程会不断的从workQueue中获取线程然后执行。当workQueue中没有任务的时候，worker就会阻塞，直到队列中有任务了就取出来继续执行。</p>
<p><img src="/2024/04/24/ThreadPool/java-thread-x-executors-1.png" alt="img"></p>
<h3 id="Execute原理"><a href="#Execute原理" class="headerlink" title="# Execute原理"></a><a href="#execute%E5%8E%9F%E7%90%86">#</a> Execute原理</h3><p><img src="https://github.com/WhileCrow/BlackCrow/assets/26061465/f2b23a0e-ba3b-4be8-be4c-001699925978" alt="image"><br><a target="_blank" rel="noopener" href="https://excalidraw.com/#json=Y7a8uMRrIrZNGfr7GnQ0M,2qUB-ZmXM-hwP0a3MWnA1A">https://excalidraw.com/#json=Y7a8uMRrIrZNGfr7GnQ0M,2qUB-ZmXM-hwP0a3MWnA1A</a></p>
<p>当一个任务提交至线程池之后:</p>
<ol>
<li>线程池首先当前运行的线程数量是否少于corePoolSize。如果是，则创建一个新的工作线程来执行任务。如果都在执行任务，则进入2.</li>
<li>判断BlockingQueue是否已经满了，倘若还没有满，则将线程放入BlockingQueue。否则进入3.</li>
<li>如果创建一个新的工作线程将使当前运行的线程数量超过maximumPoolSize，则交给RejectedExecutionHandler来处理任务。</li>
</ol>
<blockquote>
<p>运行机制（当任务来了之后的执行流程）：</p>
<ol>
<li>判断核心线程数是否已满；如果未满创建核心线程执行任务；如果满了执行后续操作。</li>
<li>判断任务队列是否已满；如果未满将任务添加到队列；如果满了执行后续流程。</li>
<li>判断最大线程数是否已满；如果未满创建临时线程执行任务；如果满了执行后续流程。</li>
<li>执行拒绝策略（内置4种拒绝策略+自定义的拒绝策略）。</li>
</ol>
</blockquote>
<p>当ThreadPoolExecutor创建新线程时，通过CAS来更新线程池的状态ctl.</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="# 参数"></a><a href="#%E5%8F%82%E6%95%B0">#</a> 参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>corePoolSize</code> 线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize, 即使有其他空闲线程能够执行新来的任务, 也会继续创建线程；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</li>
<li><code>workQueue</code> 用来保存等待被执行的任务的阻塞队列. 在JDK中提供了如下阻塞队列: 具体可以参考<a href>JUC 集合: BlockQueue详解</a><ul>
<li><code>ArrayBlockingQueue</code>: 基于数组结构的有界阻塞队列，按FIFO排序任务；</li>
<li><code>LinkedBlockingQueue</code>: 基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQueue；</li>
<li><code>SynchronousQueue</code>: 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue；</li>
<li><code>PriorityBlockingQueue</code>: 具有优先级的无界阻塞队列；</li>
</ul>
</li>
</ul>
<p><code>LinkedBlockingQueue</code>比<code>ArrayBlockingQueue</code>在插入删除节点性能方面更优，但是二者在<code>put()</code>, <code>take()</code>任务的时均需要加锁，<code>SynchronousQueue</code>使用无锁算法，根据节点的状态判断执行，而不需要用到锁，其核心是<code>Transfer.transfer()</code>.</p>
<ul>
<li><code>maximumPoolSize </code> 线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize；当阻塞队列是无界队列, 则maximumPoolSize则不起作用, 因为无法提交至核心线程池的线程会一直持续地放入workQueue.</li>
<li><code>keepAliveTime </code> 线程空闲时的存活时间，即当线程没有任务执行时，该线程继续存活的时间；默认情况下，该参数只在线程数大于corePoolSize时才有用, 超过这个时间的空闲线程将被终止；</li>
<li><code>unit </code> keepAliveTime的单位</li>
<li><code>threadFactory </code> 创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名。默认为DefaultThreadFactory</li>
<li><code>handler </code> 线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略:<ul>
<li><code>AbortPolicy</code>: 直接抛出异常，默认策略；</li>
<li><code>CallerRunsPolicy</code>: 用调用者所在的线程来执行任务；</li>
<li><code>DiscardOldestPolicy</code>: 丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>
<li><code>DiscardPolicy</code>: 直接丢弃任务；</li>
</ul>
</li>
</ul>
<p>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p>
<h1 id="※线程池ThreadPoolExecutor"><a href="#※线程池ThreadPoolExecutor" class="headerlink" title="※线程池ThreadPoolExecutor"></a>※线程池ThreadPoolExecutor</h1><h2 id="常见的线程池有："><a href="#常见的线程池有：" class="headerlink" title="常见的线程池有："></a>常见的线程池有：</h2><h3 id="无缓存线程"><a href="#无缓存线程" class="headerlink" title="无缓存线程"></a>无缓存线程</h3><h4 id="·-定长线程池（最常见，如Glide）"><a href="#·-定长线程池（最常见，如Glide）" class="headerlink" title="· 定长线程池（最常见，如Glide）"></a>· 定长线程池（最常见，如Glide）</h4><p>FixedThreadPool：<strong>根据入参决定有多少个核心线程，无缓存线程。</strong> 可重用固定线程数的线程池。（适用于负载比较重的服务器） FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列，该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列 中的任务。</p>
<h4 id="·-单线程线程池"><a href="#·-单线程线程池" class="headerlink" title="· 单线程线程池"></a>· 单线程线程池</h4><p>SingleThreadExecutor：<strong>只有一个核心线程，最大线程也为1，无缓存线程。所有任务在此线程中FIFO进行</strong>只会创建一个线程执行任务。（适用于需要保证顺序执行各个任 务；并且在任意时间点，没有多线程活动的场景。） SingleThreadExecutorl也使用无界队列LinkedBlockingQueue作为工作队列 若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先 出的顺序执行队列中的任务。</p>
<h4 id="·-定时线程池"><a href="#·-定时线程池" class="headerlink" title="· 定时线程池"></a>· 定时线程池</h4><p>ScheduledThreadPool：<strong>只有入参数量的核心线程，无缓存线程</strong>。继承自ThreadPoolExecutor。它主要用来在给定的延迟之后运行 任务，或者定期执行任务。使用DelayQueue作为任务队列。如newScheduledThreadPool，用于定时任务。</p>
<h3 id="无核心线程"><a href="#无核心线程" class="headerlink" title="无核心线程"></a>无核心线程</h3><h4 id="·-缓存线程池"><a href="#·-缓存线程池" class="headerlink" title="· 缓存线程池"></a>· 缓存线程池</h4><p>CachedThreadPool：<strong>无核心线程，无限制地增加执行完成就销毁(根据keepaliveTime决定)的缓存线程</strong>，是一个会根据需要调整线程数量的线程池。（大小无界，适用于执行很 多的短期异步任务的小程序，或负载较轻的服务器） CachedThreadPool使用没有容量的SynchronousQueue作为线程池的工作队列，但 CachedThreadPool的maximumPool是无界的。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线 程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕 后，将返回线程池进行复用。</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li>降低资源消耗：通过重复利用现有的线程来执行任务，避免多次创建和销毁线程。<strong>一个线程保留1M大小的内存空间，有效降低OOM</strong></li>
<li>提高相应速度：因为省去了创建线程这个步骤，所以在拿到任务时，可以立刻开始执行。</li>
</ol>
<h2 id="线程数应该怎么设置"><a href="#线程数应该怎么设置" class="headerlink" title="线程数应该怎么设置"></a>线程数应该怎么设置</h2><ul>
<li>如果任务是IO密集型，一般线程数需要设置2倍CPU数以上（2N），以此来尽量利用CPU资源。</li>
<li>如果任务是CPU密集型，一般线程数量只需要设置CPU数加1即可，更多的线程数也只能增加上下文切换，不能增加CPU利用率。</li>
</ul>
<blockquote>
<p>在计算密集型任务中，将线程池大小设置为 CPU 核心数 + 1 的原因是为了应对可能出现的阻塞情况。 虽然计算密集型任务主要消耗 CPU 资源，但在实际应用中，任务内部可能仍然存在一些阻塞操作， 例如：<br>同步 IO： 如果任务需要进行磁盘读写或网络通信等 IO 操作，并且这些操作是同步阻塞的，那么当前线程会被阻塞， 无法继续执行计算任务。<br>锁竞争： 如果任务中存在对共享资源的访问，并且使用了锁机制进行同步， 那么当多个线程同时竞争锁时， 部分线程会被阻塞， 等待获取锁。<br>页面错误： 当线程访问的内存页面不在物理内存中时，会发生页面错误， 导致线程被阻塞， 等待操作系统将页面从磁盘加载到内存。  如果线程池大小刚好等于 CPU 核心数，那么当一个线程被阻塞时，CPU 就无法充分利用，导致整体性能下降。 而增加一个额外的线程，可以确保在某个线程被阻塞时， 仍然有足够的线程可以继续执行计算任务， 从而提高 CPU 利用率和整体性能。 当然，这只是一个经验法则，并不是绝对的。 在某些情况下， 如果任务中不存在阻塞操作， 或者阻塞情况非常少见， 那么将线程池大小设置为 CPU 核心数也可能足够。 最佳的线程池大小仍然需要根据你的具体应用场景和硬件环境进行调整和测试。 </p>
</blockquote>
<p>简单来说就是 io多，则用更多线程充分利用cpu；计算多，则用少的线程数减少线程切换，但仍存在的io操作使数量应为n+1;</p>
<p>Android一般认为多数操作是IO密集，如网络io，本地文件io，所以会设置2N</p>
<h3 id="Android系统对每个进程线程数限制"><a href="#Android系统对每个进程线程数限制" class="headerlink" title="Android系统对每个进程线程数限制"></a>Android系统对每个进程线程数限制</h3><p>root 下adb shell cat /proc/sys/kernel/threads-max</p>
<p>结果如：57439</p>
<p>但每个线程1M左右，基本上几百个线程就可能OOM了</p>
<h3 id="常见的三方库线程池默认数量"><a href="#常见的三方库线程池默认数量" class="headerlink" title="常见的三方库线程池默认数量"></a>常见的三方库线程池默认数量</h3><h4 id="Okhttp"><a href="#Okhttp" class="headerlink" title="Okhttp"></a>Okhttp</h4><p>OkHttp中的线程池是定义在分发器中的，即定义在Dispatcher</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">    executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> SynchronousQueue&lt;&gt;(), Util.threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>, <span class="keyword">false</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>用的其实相当于就是一个无核心线程，最大线程池为Integer.MAX_VALUE，任务队列为SynchronousQueue的缓存线程池</strong></p>
<p>高并发，最大吞吐量。SynchronousQueue队列是无容量队列，<br> 在OkHttp中，配置的线程池的核心线程数为0，最大线程数为Integer.MAX_VALUE，线程的存活时间为60s，采用的队列是SynchronousQueue。</p>
<ol>
<li>okhttp <code>默认同时支持 64 个异步请求(不考虑同步请求)，一个 host 同时最多请求 5 个</code></li>
<li>okhttp 内部的<code>线程池都是 CacheThreadPool</code>：核心线程数为 0，非核心线程数无限，永远添加不到等待队列中</li>
<li><code>okhttpClient 如果不单例，会出现 oom</code>：因为大量的 Dispatcher 对象，不同的对象会使用不同的线程去发起网络请求，从而导致线程过多，OOM</li>
</ol>
<h4 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h4><p><strong>Glide用的都是核心线程数与最大线程数一致（cpu数量与4的最小值），任务队列为PriorityBlockingQueue的定长线程池。</strong>（所以Glide的最大并发量是四个图片?）</p>
<p>glide加载的线程池的配置，使用cpu数量与4的最小值，即线程池的核心线程和最大线程数不超过4个</p>
<p><img src="/2024/04/24/ThreadPool/image-20240424204306358.png" alt="image-20240424204306358"></p>
<p><img src="/2024/04/24/ThreadPool/image-20240426113224120.png" alt="image-20240426113224120"></p>
<h2 id="线程池关闭方法区别"><a href="#线程池关闭方法区别" class="headerlink" title="线程池关闭方法区别"></a>线程池关闭方法区别</h2><p>shutdown() 、 shutdownNow() 、 awaitTermination() 的用法和区别</p>
<h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h4><p>将线程池状态置为SHUTDOWN,并不会立即停止：</p>
<ul>
<li>停止接收外部submit的任务</li>
<li>内部正在跑的任务和队列里等待的任务，会执行完</li>
<li>等到第二步完成后，才真正停止</li>
</ul>
<h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a>shutdownNow()</h4><p>将线程池状态置为STOP。企图立即停止，事实上不一定：</p>
<ul>
<li>跟shutdown()一样，先停止接收外部提交的任务</li>
<li>忽略队列里等待的任务</li>
<li>尝试将正在跑的任务interrupt中断</li>
</ul>
<p>返回未执行的任务列表</p>
<h4 id="awaitTermination"><a href="#awaitTermination" class="headerlink" title="awaitTermination()"></a>awaitTermination()</h4><p>awaitTermination(long timeOut, TimeUnit unit)</p>
<p>当前线程阻塞，直到</p>
<ul>
<li>等所有已提交的任务（包括正在跑的和队列中等待的）执行完</li>
<li>或者等超时时间到</li>
<li>或者线程被中断，抛出InterruptedException</li>
</ul>
<p>然后返回true（shutdown请求后所有任务执行完毕）或false（已超时）</p>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ul>
<li><strong>优雅的关闭</strong>，用shutdown()，<u>停止接受任务</u>并<u>等待进行中</u>的和<u>队列中的任务</u>都执行完后停止。</li>
<li><strong>想立马中断并关闭</strong>，并得到未执行任务列表，用shutdownNow()，会<u>interrupt正在进行的任务</u>并<u>忽略队列中任务</u>，返回未执行的任务队列</li>
<li><strong>优雅的关闭</strong>，并允许关闭声明后新任务能提交，用awaitTermination()</li>
</ul>
<h2 id="线程池都有哪几种工作队列？"><a href="#线程池都有哪几种工作队列？" class="headerlink" title="线程池都有哪几种工作队列？"></a>线程池都有哪几种工作队列？</h2><p><strong>ArrayBlockingQueue</strong>：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。</p>
<p><strong>LinkedBlockingQueue</strong>：是一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量 通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()、newSingleThreadExecutor使用了 这个队列。</p>
<p><strong>SynchronousQueue</strong>：是一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用 移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue。</p>
<p><strong>DelayedWorkQueue</strong>：是一个阻塞队列。保证添加到队列中的任务，会按照任务的延时时间进行排序，延时时间少的任务首先被获取。newScheduledThreadPool使用了这个队列。</p>
<p>假设向线程池提交任务时，核心线程都被占用的情况下：</p>
<p><code>ArrayBlockingQueue</code>：基于数组的阻塞队列，初始化需要指定固定大小。</p>
<p>​    当使用此队列时，向线程池提交任务，会首先加入到等待队列中，当等待队列满了之后，再次提交任务，尝试加入队列就会失败，这时就会检查如果当前线程池中的线程数未达到最大线程，则会新建线程执行新提交的任务。所以最终可能出现后提交的任务先执行，而先提交的任务一直在等待。</p>
<p><code>LinkedBlockingQueue</code>：基于链表实现的阻塞队列，初始化可以指定大小，也可以不指定。</p>
<p>​    当指定大小后，行为就和<code>ArrayBlockingQueu</code>一致。而如果未指定大小，则会使用默认的<code>Integer.MAX_VALUE</code>作为队列大小。这时候就会出现线程池的最大线程数参数无用，因为无论如何，向线程池提交任务加入等待队列都会成功。最终意味着所有任务都是在核心线程执行。如果核心线程一直被占，那就一直等待。</p>
<p><code>SynchronousQueue</code> : 无容量的队列。</p>
<p>​    使用此队列意味着希望获得最大并发量。因为无论如何，向线程池提交任务，往队列提交任务都会失败。而失败后如果没有空闲的非核心线程，就会检查如果当前线程池中的线程数未达到最大线程，则会新建线程执行新提交的任务。完全没有任何等待，唯一制约它的就是最大线程数的个数。因此一般配合<code>Integer.MAX_VALUE</code>就实现了真正的无等待。</p>
<p>//lqr:TODO  <a target="_blank" rel="noopener" href="https://juejin.cn/post/6847902225730109454">https://juejin.cn/post/6847902225730109454</a></p>
<h2 id="拒绝策略rejectHander"><a href="#拒绝策略rejectHander" class="headerlink" title="拒绝策略rejectHander"></a>拒绝策略rejectHander</h2><p>当 Executor 已关闭时，以及当 Executor 对最大线程和工作队列容量使用有限界限且已饱和时，在方法execute(Runnable)中提交的新任务将被拒绝。在任一情况下， execute方法都会调用其<code>RejectedExecutionHandler</code>的<code>RejectedExecutionHandler.rejectedExecution(Runnable, ThreadPoolExecutor)</code>方法。提供了四种预定义的处理程序策略：</p>
<ol>
<li><p>在默认的ThreadPoolExecutor.AbortPolicy中，处理程序在被拒绝时会抛出运行时<code>RejectedExecutionException </code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">   <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">   e.toString());</span><br></pre></td></tr></table></figure></li>
<li><p>在ThreadPoolExecutor.CallerRunsPolicy中，调用execute的线程本身会运行任务。这提供了一种简单的反馈控制机制，可以减慢提交新任务的速度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">		r.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在ThreadPoolExecutor.DiscardPolicy中，无法执行的任务将被直接丢弃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;do nothing</span><br></pre></td></tr></table></figure></li>
<li><p>在ThreadPoolExecutor.DiscardOldestPolicy中，如果执行器未关闭，则工作队列头部的任务将被删除，然后重试执行（这可能会再次失败，导致重复此操作。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">    e.getQueue().poll();</span><br><span class="line">    e.execute(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="如果提交任务时，线程池队列已满，会发生什么"><a href="#如果提交任务时，线程池队列已满，会发生什么" class="headerlink" title="如果提交任务时，线程池队列已满，会发生什么"></a>如果提交任务时，线程池队列已满，会发生什么</h2><p>如果使用的LinkedBlockingQueue，也就是无界队列的话，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以无限存放任务；如果使用的是有界队列比方说ArrayBlockingQueue的话，则会使用拒绝策略RejectedExecutionHandler处理满了的任务。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-04-19T02:53:39.123Z" title="4/19/2024, 10:53:39 AM">2024-04-19</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-04-19T02:53:39.123Z" title="4/19/2024, 10:53:39 AM">2024-04-19</time></span><span class="level-item">a few seconds read (About 58 words)</span></div></div><div class="content"><p>JMM<br>30 张图，以 DEBUG 方式深入理解线程的底层运行原理<br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1818100">https://cloud.tencent.com/developer/article/1818100</a></p>
<p>JVM栈<br>20张图助你了解JVM运行时数据区，你还觉得枯燥吗？<br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1823397?areaId=106001">https://cloud.tencent.com/developer/article/1823397?areaId=106001</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-04-19T02:53:39.122Z" title="4/19/2024, 10:53:39 AM">2024-04-19</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-04-25T06:46:23.755Z" title="4/25/2024, 2:46:23 PM">2024-04-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Common/">Common</a><span> / </span><a class="link-muted" href="/categories/Common/Jvm/">Jvm</a></span><span class="level-item">37 minutes read (About 5553 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/04/19/JMM/">JvmMemoryStructure</a></h1><div class="content"><p><img src="/2024/04/19/JMM/image-20240425141403378.png" alt="image-20240425141403378"></p>
<p>程序计数器不会OOM和StackOverflow</p>
<p>有栈的结构（栈 java stack、navtive stack）可能发生 StackOverflowError（栈过深） 和 OOM </p>
<blockquote>
<p><strong>StackOverFlowError</strong> ︰若Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java 虚拟机栈的最大深度的时候，就抛出StackOverFlowError错误。<br><strong>OutOfMemoryError</strong> :如果虚拟机栈可以动态扩展（当前大部分的 Java 虚拟机都可动态扩展，只不过 Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出 OutOfMemoryError 异常。</p>
</blockquote>
<p>没栈的结构（堆heap、方法区Method Area）只可能发生 OOM</p></div><a class="article-more button is-small is-size-7" href="/2024/04/19/JMM/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-03-25T07:35:03.229Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-05-14T09:49:26.170Z" title="5/14/2024, 5:49:26 PM">2024-05-14</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">13 minutes read (About 1991 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/03/25/GraphicsOverriew/">Graphics</a></h1><div class="content"><h3 id="移动端渲染"><a href="#移动端渲染" class="headerlink" title="移动端渲染"></a><strong>移动端渲染</strong></h3><p><img src="/2024/03/25/GraphicsOverriew/3d5bf360cf944e2ab413b60b93c31515~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p></div><a class="article-more button is-small is-size-7" href="/2024/03/25/GraphicsOverriew/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-03-25T07:35:02.998Z" title="3/25/2024, 3:35:02 PM">2024-03-25</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:02.998Z" title="3/25/2024, 3:35:02 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Common/">Common</a><span> / </span><a class="link-muted" href="/categories/Common/Code/">Code</a></span><span class="level-item">4 minutes read (About 598 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/03/25/CodeOptimization/">CodeOptimization</a></h1><div class="content"><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="# 代码优化"></a># 代码优化</h2><h2 id="1：纯函数"><a href="#1：纯函数" class="headerlink" title="1：纯函数"></a>1：纯函数</h2><p>纯函数是函数编程中的一个概念，指的是一个方法函数，就像一个数学的函数式一样，同样的参数输入会得到同样的输出。<br>可以近似理解为函数内部不依赖任何的外部状态，外部变量。</p>
<h2 id="2：空安全"><a href="#2：空安全" class="headerlink" title="2：空安全"></a>2：空安全</h2><p>java是强对象类型语言，故对于java来说我们很容易关注到类型强转的错误</p></div><a class="article-more button is-small is-size-7" href="/2024/03/25/CodeOptimization/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-02-21T03:26:37.000Z" title="2/21/2024, 11:26:37 AM">2024-02-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-09-05T08:55:29.885Z" title="9/5/2024, 4:55:29 PM">2024-09-05</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">26 minutes read (About 3954 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/02/21/WorkNote/">WorkNote</a></h1><div class="content"><h1 id="APM基建"><a href="#APM基建" class="headerlink" title="APM基建"></a>APM基建</h1><p>方案有dokit和matrix，dokit功能更多，线下监控；Matrix优化更好，支持线上监控；</p>
<p>最终选择了功能更全一点的dokit，以期达到线下监控，线下处理，线上预防。</p>
<p>基于滴滴开源框架Dokit + 自定义扩展的性能监控（如图片尺寸浪费、内存泄露误报、）</p>
<p>其中dokit中包括了原理与BlockCanary类似的耗时方法监控、Choreographer帧耗时统计、图片尺寸超限、函数耗时、启动耗时</p>
<p>耗时方法监控核心是根据handler原理，通过给Looper.loop() 中设置printer(无论是通过反射替换Looper的<em>mLogging</em>还是通过<em>setMessageLogging</em>设置printer)，监控超过 设定阈值(matrix700ms) 的主线程消息（超过5s报为ANR），printer 中判断start和end，来获取主线程dispatch该message的开始和结束时间，并判定该时间超过阈值为主线程卡慢发生，并 打印当时堆栈 + 方法耗时(matrix/dokit)</p>
<p>堆栈和方法耗时 dokit和matrix是每个方法插桩，但matrix的优化更细节</p>
<p>帧率检测核心是利用系统 Choreographer 模块，向该模块注册一个 FrameCallback 监听对象，同时通过另外一条线程循环记录主线程堆栈信息，并在每次 Vsync 事件 doFrame 通知回来时，循环注册该监听对象，间接统计两次 Vsync 事件的时间间隔，当超出阈值时，取出记录的堆栈进行分析上报。</p>
<p>帧率检测新版本可以考虑用</p>
<h1 id="一次完整的图片优化过程"><a href="#一次完整的图片优化过程" class="headerlink" title="一次完整的图片优化过程"></a>一次完整的图片优化过程</h1><ol>
<li><p>域名收敛，使用正则将多个域名收敛成一个，提高链接复用；</p>
<p>推服务端使用Http2，减少堵塞</p>
<p>同时收敛webp格式，若该图片存在webp则替换为webp链接，兜底为原链接，节省下载流量和加载速度；</p>
<p>调整链接中图片尺寸以符合CDN裁切尺寸（300，500等）；</p>
<p>单元测试覆盖（如果是现在我会用chatgpt写）</p>
</li>
<li><p>开发网络图片大小不当报警，通过插桩图片加载框架，上报图片下载尺寸与实际尺寸不符的case（页面类名+view id）</p>
<p><strong>目标：</strong>监控图片下载尺寸浪费，优化图片渲染速度，减少图片下行流量（优化磁盘大小，fresco本身能够裁剪图片获得适当的内存大小。）</p>
<p><strong>细节：</strong> 从 调用图片加载 到 图片真正加载完成 的时机和代码是分离的，那么 调用图片加载时候拿到的view信息 需要和 图片加载完成时拿到的<strong>下载尺寸</strong> 匹配，于是维护了一个key为url，value为view信息的ConcurrentHashMap，在加载完成时从中取出对应值判断</p>
<p><strong>其他：</strong>这个功能同时也能识别图片过小带来的尺寸拉伸导致的图片模糊问题。</p>
</li>
<li><p>修复了fresco加载gif图片bug带来的内存暴涨</p>
<p>细节：首先描述一下现象，fresco加载gif图片，当该gif图是多次轮播时，通过Android profile的内存监控可看到内存一路上升，直到gc后又继续上涨；原因：gif图中的每一帧会在解析时包裹成一个内部对象<code>AnimatedImageResult</code>，复用gif图帧的开关默认是关闭的，且复用代码有bug，复用缓存的key被设置为<code>AnimatedImageResult</code>的hashcode值，导致每次播放同一帧时，每次都会重新解析加载到内存，每一帧会有多份内存存在；</p>
<p>解决方案：1、打开复用开关；2、修改复用的key，为解析后ByteBuffer的System.identityHashCode值 + option的hashcode值</p>
<p>相当于用解析后单帧的hashcode作为缓存key</p>
<p>PS:fresco 后续补充：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/facebook/fresco/commit/40937a700e76e0f68353857f5bd0b567b6e909f1">https://github.com/facebook/fresco/commit/40937a700e76e0f68353857f5bd0b567b6e909f1</a></p>
<p>fresco将之前试验性质的代码移除，有较大的缓存改动。故PR不再会被接收（如ExperimentalBitmapAnimationDrawableFactory这个类已经被替换了），同时gif图缓存新增一个AnimatedCache.kt的类，通过source(gif图url)+frameIndexNumber的方式生成缓存key。</p>
<p>现在通过更新frasco版本应该就可以有正常的gif图缓存了</p>
</li>
</ol>
<ol>
<li>基于内部框架奥创完成了购物车、订单页面的重构</li>
<li>完成一次完整的页面直开优化</li>
</ol>
<h1 id="一次基于内部框架奥创、MVVM设计的购物车、订单重构"><a href="#一次基于内部框架奥创、MVVM设计的购物车、订单重构" class="headerlink" title="一次基于内部框架奥创、MVVM设计的购物车、订单重构"></a>一次基于内部框架奥创、MVVM设计的购物车、订单重构</h1><p>背景是项目是14年左右开始迭代的，模块的耦合很重，设计落后，维护性很差，于是当时借助一次产品发起的改版方案，重构了订单。</p>
<p>奥创是一个前后端协作的组件化协议，将页面根据各自功能拆分为多个组件，奥创协议下发每个组件所需的字段、组件对应的页面层级位置等。</p>
<p>端侧可以获得一份清晰的组件列表、组件位置（只分粘顶、滑动、粘底）。端侧在RecyclerView中注册每个组件对应的ViewModel和ViewHolder，解析协议中组件的数据得到组件ViewModel，recyclerView中每个组件ViewHodle将根据组件唯一Id取到对应的ViewModel。</p>
<p>整体设计是由数据驱动，MVVM架构下，viewmodel中的数据由生命周期安全的LiveData持有，ViewHolder作为View层监听相对应数据的变化。网络请求放在页面ViewModel的Repository层中。</p>
<h1 id="一次完整的页面秒开方案"><a href="#一次完整的页面秒开方案" class="headerlink" title="一次完整的页面秒开方案"></a>一次完整的页面秒开方案</h1><h2 id="预请求"><a href="#预请求" class="headerlink" title="预请求"></a>预请求</h2><h3 id="精细化推测下单"><a href="#精细化推测下单" class="headerlink" title="精细化推测下单"></a>精细化推测下单</h3><p>购物车页刷新完数据后通过对用户行为的预测，直接发起下个页面的请求并缓存内存LRUCache，这种情况进入下个页面时大概率能直接拿到缓存。节省了整个请求时间。</p>
<p>一个商品、当天加购、商品数量为1。整点前后十分钟内不启用。</p>
<p>优点是速度很快，缺点是必不可免的存在流量浪费，需要根据线上的数据调整规则，以达到最佳的请求能效。</p>
<p>经调整后的缓存利用率能达到30%左右。调整前20%不到。</p>
<h3 id="前一页面中曝光即加载（失败尝试）"><a href="#前一页面中曝光即加载（失败尝试）" class="headerlink" title="前一页面中曝光即加载（失败尝试）"></a>前一页面中曝光即加载（失败尝试）</h3><p>从搜索列表到detail的缓存利用率只有5%不到，从购物车到detail的缓存利用率有14%。流量浪费比较严重。</p>
<p>最后只保留了购物车的曝光即加载。</p>
<h2 id="提前请求"><a href="#提前请求" class="headerlink" title="提前请求"></a>提前请求</h2><h3 id="页面请求前置-京喜方案"><a href="#页面请求前置-京喜方案" class="headerlink" title="页面请求前置(京喜方案)"></a>页面请求前置(京喜方案)</h3><p>直接将请求前置，在onCreate最前面就发起请求，节省了inflateLayout的开销(几十到几百ms)，（<del>为什么不用AsyncLayoutInflater：限制较多，如异步线程中没有初始化looper，view需手动加到Viewparent等</del>）</p>
<p>需要注意的是，如果请求直接失败的情况下，由于布局未inflate完成可能导致失败视图展示有问题，这种情况下失败视图操作需要post一下。</p>
<p>优点是改动小，适用性广；</p>
<h3 id="路由层请求"><a href="#路由层请求" class="headerlink" title="路由层请求"></a>路由层请求</h3><p>将目标页面的请求抽离到预请求框架提供的接口实现类中，路由层提供注册对应页面的url处理的能力，一旦监听到路由层有相关的url跳转，预请求接口实现类发起一次预请求，在页面实际发起请求时，转为向预请求框架请求数据。如有已发起预请求的标记则走预请求框架，否则继续走正常发起请求逻辑。</p>
<p>节省了路由耗时+activity启动耗（十几ms）、inflate耗时(几十到几百ms)</p>
<h3 id="异步布局"><a href="#异步布局" class="headerlink" title="异步布局"></a>异步布局</h3><p>AsyncLayoutInflater框架是Google提供的可用于异步线程中解析布局的工具，原理就是在新建的<strong>单线程</strong>中<strong>循环执行</strong>提交到**任务队列(容量固定为10的ArrayBlockingQueue)**的任务。</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>所填充的布局中自定义View中不能直接使用Handler，因为其布局中所有子View都是在异步线程中创建的，故默认没有初始化Looper</li>
<li>单线程易阻塞</li>
<li>提交超过10个任务会导致主线程等待</li>
<li>view需手动加到Viewparent</li>
<li>不支持设置LayoutInflater. Factory或LayoutInflater. Factory2</li>
<li>锁可能导致inflater不及时，导致反而比不用异步布局慢</li>
</ol>
<h4 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h4><p>但是异步布局<strong>并不需要担心View测绘</strong>时抛出<code>&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</code>异常。</p>
<p>因为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ViewRootImpl.java</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(</span><br><span class="line">                <span class="string">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>checkThread判断的是更新UI（<code>requestLayout or invalidate</code>）时，<strong>ViewRootImpl的创建线程与更新UI线程</strong>是否一致</p>
<p>ViewRootImpl线程是在初始化的时候赋值的。而ViewRootImpl的初始化是在：</p>
<ol>
<li><p>PhoneWindow(如Activity)在setContentView时先installDecor()，然后将setContentView的入参view添加到DecorView布局中的R.id.content上</p>
</li>
<li><p>之后会等到AMS发来Resume消息的时候，走ActivityThread.handleResumeActivity时，调用<code>wm.addView(decor, l);</code>，走到activity.mWindowManager.addView -&gt; WindowManagerImpl.addView -&gt; WindowManagerGlobal.addView</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WindowManagerGlobal.java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">            Display display, Window parentWindow, <span class="keyword">int</span> userId)</span>  </span>&#123;</span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    ...</span><br><span class="line">    root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">    view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">    mViews.add(view);</span><br><span class="line">    mRoots.add(root);</span><br><span class="line">    mParams.add(wparams);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于ActivityThread所在线程其实就是主线程（ActivityThread.main调用了Looper.prepareMainLooper()、Looper.loop()，整个应用都是存活在这个looper的调度中的），所以调用ActivityThread.handleResumeActivity初始化ViewRootImpl的时候，就是在主线程。</p>
</li>
</ol>
<p><strong>故而不管是不是用异步布局填充最后checkThread时还是比较是否为主线程</strong></p>
<h4 id="改进方式"><a href="#改进方式" class="headerlink" title="改进方式"></a>改进方式</h4><p>可以通过拷贝一份AsyncLayoutInflater，然后改动代码的方式：</p>
<ol>
<li><p>通过增加线程池调度，规避只能单线程inflater的弊端，解决注意事项2</p>
</li>
<li><p>可以通过在inflater前，反射调用线程池中每个线程设置MainLooper()，解决注意事项1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forceSetMainLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Field field = Looper.class.getDeclaredField(<span class="string">&quot;sThreadLocal&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object object = field.get(Looper.getMainLooper());</span><br><span class="line">        <span class="keyword">if</span> (object <span class="keyword">instanceof</span> ThreadLocal) &#123;</span><br><span class="line">            ThreadLocal threadLocal = (ThreadLocal&lt;Looper&gt;) object;</span><br><span class="line">            threadLocal.set(Looper.getMainLooper());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>页面没出来之前（空闲时渲染）直接填充布局，生成View后缓存到内存中，使用时直接取用，空间换时间的方式降低页面耗时，简单将就是填充一份View备用，需要时直接取用后再异步填充取代回去。</p>
</li>
<li><p><del>重写cloneInContext（LayoutInflater.from(context)最后走到的是ContextThemeWrapper的getSystemService。<code>mInflater = LayoutInflater.from(getBaseContext()).cloneInContext(this);</code>故重写该方法直接返回新的LayoutInflater即可）</del></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ContextThemeWrapper.java</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (LAYOUT_INFLATER_SERVICE.equals(name)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInflater == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInflater = LayoutInflater.from(getBaseContext()).cloneInContext(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mInflater;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getBaseContext().getSystemService(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改进后be like:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">cloneInContext</span><span class="params">(Context newContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BasicInflater(newContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>现在we对异步布局的使用都是在实际填充前就使用异步布局填充完布局生成viewCache（key为resId，value为View），使用时如果发现存在view cache则直接使用并移除缓存，没有就走普通的LayoutInflater在主线程直接inflater</p>
<p>//比如首页现在是在启动阶段就异步填充布局，详情在路由跳转时候开三个线程去填充。</p>
<h3 id="Chunk流式加载"><a href="#Chunk流式加载" class="headerlink" title="Chunk流式加载"></a>Chunk流式加载</h3><p>借助Http1.1的chunk机制，服务端将数据拆分，服务端较耗时的数据拆分到第二个chunk返回，第一个chunk只返回必要的信息。</p>
<p>如营销类、活动等信息接口查询较慢，放到第二个chunk中返回。</p>
<p>现在responese格式大致是：</p>
<p>id:1</p>
<p>xxxx</p>
<p>id:2</p>
<p>yyyy</p>
<p>然后okhttp架构组那边解析成原格式，分两次回调。</p>
<p>本身okhttp就支持chunk，端侧只需要根据两次返回合并结果（floorcontainer）就行。</p>
<p>优点是首屏渲染耗时加快了，服务端第一次接口返回耗时减少。</p>
<p>缺点是会导致闪烁，比如价格组件由于第一次返回的数据不正确需隐藏，需要等第二次数据回来才显示，会有一次跳变。</p>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><h3 id="一、首屏的定义："><a href="#一、首屏的定义：" class="headerlink" title="一、首屏的定义："></a>一、首屏的定义：</h3><p>起点一定是从点击开始；</p>
<p>结束可为：</p>
<ul>
<li>下个页面onResume执行一个handle.post()</li>
<li>（淘宝定义）在固定机型(最多的占比)下，下个页面前三张图加载完成（用户体验视角定义首屏时间）</li>
</ul>
<p>现在自己首屏起点是activity的oncreate（路由匹配到detail的起点）到recyclerView第一屏viewholder所有onbind调用中，注册viewTreeObserver.OnGlobalLayoutListener都返回。</p>
<h3 id="二、优化首屏的手段："><a href="#二、优化首屏的手段：" class="headerlink" title="二、优化首屏的手段："></a>二、优化首屏的手段：</h3><ol>
<li><p>预加载</p>
<p>上述几种方案，可以普遍使用路由拦截请求方案</p>
</li>
<li><p>磁盘缓存</p>
<p>如购物车数据使用本地缓存、购物车中的商品数据请求后缓存磁盘。</p>
</li>
<li><p>闲时资源预热</p>
<p>主要针对dx模板之类的</p>
<p>模板预下载，即在启动后idleHandle中提交一个下载dx模板的线程到线程池中；</p>
</li>
<li><p>引擎预热</p>
<p>dx引擎预热</p>
<p>在请求没回来前提前初始化dxengine</p>
</li>
<li><p>推后端优化</p>
<p>减少机器内RT</p>
</li>
<li><p>上下行包大小优化</p>
<p>精简协议，减少包大小</p>
</li>
<li><p>上个页面onPause时间排查</p>
<p>比如上个页面onPause中处理太多事情导致下一页面唤起延迟</p>
</li>
<li><p>布局加载优化</p>
</li>
<li><p>异步布局</p>
</li>
</ol>
<h1 id="一次rtl引发的惨案"><a href="#一次rtl引发的惨案" class="headerlink" title="一次rtl引发的惨案"></a>一次rtl引发的惨案</h1><h2 id="Case-1："><a href="#Case-1：" class="headerlink" title="Case 1："></a>Case 1：</h2><p>原始数据为</p>
<p><img src="/2024/02/21/WorkNote/image-20240318195423266.png" alt="image-20240318195423266"></p>
<p>端侧显示为</p>
<img src="/2024/02/21/WorkNote/image-20240318201435400.png" alt="image-20240318201435400" style="zoom: 50%;">

<p>前提：  数字18,186.37、美元$、冒号、逗号、小数点是弱字符； 空格是中性字符；  阿拉伯语是强rtl字符； 字母MXN是强ltr字符；</p>
<p><strong>BIDI算法基本规则：</strong></p>
<ol>
<li><p><strong>文本的全局方向取决于句子中首个强字符</strong></p>
</li>
<li><p><strong>确定了文本的全局显示方向后，若局部出现了反向字符，则连续的反向字符保持其局部顺序</strong><br><strong>e.g: 若在连续的阿拉伯文中出现了中文单词，如”奔跑吧”，则其仍按照中文顺序显示，不会显示为”吧跑奔”</strong></p>
</li>
<li><p><strong>弱字符保持自身方向</strong></p>
</li>
<li><p><strong>没有被强字符包裹的中性字符追随全局方向</strong></p>
</li>
</ol>
<p>解析：</p>
<p>首先，整体的文本方向是由第一个强字符决定的，也就是rtl方向；</p>
<p><img src="/2024/02/21/WorkNote/image-20240318202931647.png" alt="image-20240318202931647" style="zoom:33%;">阿拉伯文本强rtl字符</p>
<p>冒号 为弱字符保持自身方向(单个看不出来)，按全局方向摆放在其左</p>
<p>空格 为中性字符追随全局方向(单个看不出来)，按全局方向摆放在其左</p>
<p>18,186.37 整个弱字符方向串保持自身方向，为ltr，按全局方向摆放在其左</p>
<p>MXN为强ltr字符，按全局方向摆放在其左</p>
<p>$为弱字符方向，按全局方向摆放在其后</p>
<p>解决：</p>
<p>使用强制ltr的领宽度字符 u202A 和 终止符u202C</p>
<p>使 Total + “\u202A” + 价格 + “\u202C”</p>
<p>强制价格（金额+货币单位）作为一个方向串走 ltr</p>
<h2 id="Case2"><a href="#Case2" class="headerlink" title="Case2:"></a>Case2:</h2></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-12-22T06:24:28.000Z" title="12/22/2023, 2:24:28 PM">2023-12-22</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-06-13T06:09:15.701Z" title="6/13/2024, 2:09:15 PM">2024-06-13</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">10 minutes read (About 1496 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/22/Fragment/">Fragment</a></h1><div class="content"><p><a target="_blank" rel="noopener" href="https://developer.android.com/guide/fragments/lifecycle?hl=zh-cn">https://developer.android.com/guide/fragments/lifecycle?hl=zh-cn</a></p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>//简述：还有一个生命周期是<code> onViewCreated()</code>，该生命周期会在onCreateView后立即调用（此时布局inflate已完成），故而一般fragment的onCreateView中执行inflate layout操作后返回rootView，之后在<code>onViewCreated</code>中执行具体的View操作。    </p>
<p><img src="/2023/12/22/Fragment/168137f2adfe6b44~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75-8250473.png" alt="168137f2adfe6b44~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75"></p>
<h1 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h1><h2 id="FragmentTransaction的4种提交方式"><a href="#FragmentTransaction的4种提交方式" class="headerlink" title="FragmentTransaction的4种提交方式"></a>FragmentTransaction的4种提交方式</h2><h3 id="commit-："><a href="#commit-：" class="headerlink" title="commit()："></a>commit()：</h3><p>commit是<strong>非同步提交（我认为不应称为异步）</strong>且<strong>检查是否存储状态</strong>的</p>
<blockquote>
<p>The commit does not happen immediately; it will be scheduled as work on the main thread to be done the next time that thread is ready.</p>
</blockquote>
<p>非同步提交：即操作会被post到主线程handler的消息队列中，等候轮到时执行；</p>
<p>检查存储状态：如果宿主(FragmentActivity)已经执行了onSaveInstanceState再执行该操作，会抛出异常</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FragmentManager.class</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkStateLoss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isStateSaved()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Can not perform this action after onSaveInstanceState&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="commitAllowingStateLoss"><a href="#commitAllowingStateLoss" class="headerlink" title="commitAllowingStateLoss():"></a><strong>commitAllowingStateLoss</strong>():</h3><p><strong>非同步提交</strong>且<strong>不检查状态</strong></p>
<p>如果在宿主执行了onSaveInstanceSate之后再执行该操作，不会去检查宿主状态,不会抛出异常。但该操作不会被Activity记录，恢复时也就没办法恢复这些提交操作，所以该操作适用不重要的事务。同属于异步事务。 </p>
<h3 id="commitNow"><a href="#commitNow" class="headerlink" title="commitNow():"></a>commitNow():</h3><p><strong>同步提交</strong>且<strong>检查状态</strong>。</p>
<p>会立刻执行当前提交的transaction事务。</p>
<h3 id="commitNowAllowingStateLoss"><a href="#commitNowAllowingStateLoss" class="headerlink" title="commitNowAllowingStateLoss():"></a><strong>commitNowAllowingStateLoss</strong>():</h3><p><strong>同步提交</strong>且<strong>不检查状态</strong></p>
<p>既是同步执行，也不会检查宿主的状态,有可能该操作不会被正确恢复</p>
<p>同时：<strong>使用 commitNow() 或 commitNowAllowingStateLoss() 提交的事务不允许加入回退栈</strong> </p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commitNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    disallowAddToBackStack();</span><br><span class="line">    mManager.execSingleAction(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commitNowAllowingStateLoss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    disallowAddToBackStack();</span><br><span class="line">    mManager.execSingleAction(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="Principle"><a href="#Principle" class="headerlink" title="Principle"></a>Principle</h1><p>源码中fragment的生命周期方法回调在于 内置定义的五种状态的转移：</p>
<p>当宿主生命周期发生变化时，Fragment 的状态会同步到宿主的状态。从源码看，体现在宿主生命周期回调中会调用 FragmentManager 中一系列 dispatchXXX() 方法来触发 Fragment 状态转移。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FragmentActivity</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    mFragmentLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);</span><br><span class="line">    mFragments.dispatchCreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//android.fragment:fragment:1.3.6   Fragment		</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIALIZING = -<span class="number">1</span>;          <span class="comment">// Not yet attached.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ATTACHED = <span class="number">0</span>;               <span class="comment">// Attached to the host.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CREATED = <span class="number">1</span>;                <span class="comment">// Created.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VIEW_CREATED = <span class="number">2</span>;           <span class="comment">// View Created.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AWAITING_EXIT_EFFECTS = <span class="number">3</span>;  <span class="comment">// Downward state, awaiting exit effects</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTIVITY_CREATED = <span class="number">4</span>;       <span class="comment">// Fully created, not started.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STARTED = <span class="number">5</span>;                <span class="comment">// Created and started, not resumed.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AWAITING_ENTER_EFFECTS = <span class="number">6</span>; <span class="comment">// Upward state, awaiting enter effects</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESUMED = <span class="number">7</span>;                <span class="comment">// Created started and resumed.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mState = INITIALIZING;</span><br></pre></td></tr></table></figure>

<p><strong>INITIALIZING，ATTACHED，CREATED，VIEW_CREATED，ACTIVITY_CREATED，STARTED，RESUMED</strong>七种状态轮换，每个状态轮换之间，生命周期也就自然被调用到</p>
<p>如一次创建流程，</p>
<p>枚举状态INITALIZING-&gt;RESUME，就会依次调用到：<strong>onAttach(), onCreate(), onCreateView(), onActivityCreate(), onStart(), onResume();</strong> </p>
<p>反之，RESUME-&gt;INITIALIZING，就会依次调用:<strong>onPause(), onStop(), onSaveInstanceState(), onDestroyView(), onDestroy(), onDetach()</strong></p>
<p>当然，是否需要被调用，case也会自己判断；</p>
<img src="/2023/12/22/Fragment/image-20231225150420117.png" alt="image-20231225150420117" style="zoom:30%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(<span class="meta">@NonNull</span> Fragment f, <span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    FragmentStateManager fragmentStateManager = mFragmentStore.getFragmentStateManager(f.mWho);</span><br><span class="line">    <span class="keyword">if</span> (fragmentStateManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Ideally, we only call moveToState() on active Fragments. However,</span></span><br><span class="line">        <span class="comment">// in restoreSaveState() we can call moveToState() on retained Fragments</span></span><br><span class="line">        <span class="comment">// just to clean them up without them ever being added to mActive.</span></span><br><span class="line">        <span class="comment">// For these cases, a brand new FragmentStateManager is enough.</span></span><br><span class="line">        fragmentStateManager = <span class="keyword">new</span> FragmentStateManager(mLifecycleCallbacksDispatcher,</span><br><span class="line">                mFragmentStore, f);</span><br><span class="line">        <span class="comment">// Only allow this FragmentStateManager to go up to CREATED at the most</span></span><br><span class="line">        fragmentStateManager.setFragmentManagerState(Fragment.CREATED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// When inflating an Activity view with a resource instead of using setContentView(), and</span></span><br><span class="line">    <span class="comment">// that resource adds a fragment using the &lt;fragment&gt; tag (i.e. from layout and in layout),</span></span><br><span class="line">    <span class="comment">// the fragment will move to the VIEW_CREATED state before the fragment manager</span></span><br><span class="line">    <span class="comment">// moves to CREATED. So when moving the fragment manager moves to CREATED and the</span></span><br><span class="line">    <span class="comment">// inflated fragment is already in VIEW_CREATED we need to move new state up from CREATED</span></span><br><span class="line">    <span class="comment">// to VIEW_CREATED. This avoids accidentally moving the fragment back down to CREATED</span></span><br><span class="line">    <span class="comment">// which would immediately destroy the Fragment&#x27;s view. We rely on computeExpectedState()</span></span><br><span class="line">    <span class="comment">// to pull the state back down if needed.</span></span><br><span class="line">    <span class="keyword">if</span> (f.mFromLayout &amp;&amp; f.mInLayout &amp;&amp; f.mState == Fragment.VIEW_CREATED) &#123;</span><br><span class="line">        newState = Math.max(newState, Fragment.VIEW_CREATED);</span><br><span class="line">    &#125;</span><br><span class="line">    newState = Math.min(newState, fragmentStateManager.computeExpectedState());</span><br><span class="line">    <span class="keyword">if</span> (f.mState &lt;= newState) &#123;</span><br><span class="line">        <span class="comment">// If we are moving to the same state, we do not need to give up on the animation.</span></span><br><span class="line">        <span class="keyword">if</span> (f.mState &lt; newState &amp;&amp; !mExitAnimationCancellationSignals.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// The fragment is currently being animated...  but!  Now we</span></span><br><span class="line">            <span class="comment">// want to move our state back up.  Give up on waiting for the</span></span><br><span class="line">            <span class="comment">// animation and proceed from where we are.</span></span><br><span class="line">            cancelExitAnimation(f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (f.mState) &#123;</span><br><span class="line">            <span class="keyword">case</span> Fragment.INITIALIZING:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.INITIALIZING) &#123;</span><br><span class="line">                    fragmentStateManager.attach();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> Fragment.ATTACHED:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.ATTACHED) &#123;</span><br><span class="line">                    fragmentStateManager.create();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> Fragment.CREATED:</span><br><span class="line">                <span class="comment">// We want to unconditionally run this anytime we do a moveToState that</span></span><br><span class="line">                <span class="comment">// moves the Fragment above INITIALIZING, including cases such as when</span></span><br><span class="line">                <span class="comment">// we move from CREATED =&gt; CREATED as part of the case fall through above.</span></span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.INITIALIZING) &#123;</span><br><span class="line">                    fragmentStateManager.ensureInflatedView();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.CREATED) &#123;</span><br><span class="line">                    fragmentStateManager.createView();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> Fragment.VIEW_CREATED:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.VIEW_CREATED) &#123;</span><br><span class="line">                    fragmentStateManager.activityCreated();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> Fragment.ACTIVITY_CREATED:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.ACTIVITY_CREATED) &#123;</span><br><span class="line">                    fragmentStateManager.start();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> Fragment.STARTED:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.STARTED) &#123;</span><br><span class="line">                    fragmentStateManager.resume();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f.mState &gt; newState) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (f.mState) &#123;</span><br><span class="line">            <span class="keyword">case</span> Fragment.RESUMED:</span><br><span class="line">                <span class="keyword">if</span> (newState &lt; Fragment.RESUMED) &#123;</span><br><span class="line">                    fragmentStateManager.pause();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> Fragment.STARTED:</span><br><span class="line">                <span class="keyword">if</span> (newState &lt; Fragment.STARTED) &#123;</span><br><span class="line">                    fragmentStateManager.stop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> Fragment.ACTIVITY_CREATED:</span><br><span class="line">                <span class="keyword">if</span> (newState &lt; Fragment.ACTIVITY_CREATED) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isLoggingEnabled(Log.DEBUG)) &#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">&quot;movefrom ACTIVITY_CREATED: &quot;</span> + f);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (f.mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// Need to save the current view state if not</span></span><br><span class="line">                        <span class="comment">// done already.</span></span><br><span class="line">                        <span class="keyword">if</span> (mHost.onShouldSaveFragmentState(f) &amp;&amp; f.mSavedViewState == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            fragmentStateManager.saveViewState();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> Fragment.VIEW_CREATED:</span><br><span class="line">                <span class="keyword">if</span> (newState &lt; Fragment.VIEW_CREATED) &#123;</span><br><span class="line">                    FragmentAnim.AnimationOrAnimator anim = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (f.mView != <span class="keyword">null</span> &amp;&amp; f.mContainer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// Stop any current animations:</span></span><br><span class="line">                        f.mContainer.endViewTransition(f.mView);</span><br><span class="line">                        f.mView.clearAnimation();</span><br><span class="line">                        <span class="comment">// If parent is being removed, no need to handle child animations.</span></span><br><span class="line">                        <span class="keyword">if</span> (!f.isRemovingParent()) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (mCurState &gt; Fragment.INITIALIZING &amp;&amp; !mDestroyed</span><br><span class="line">                                    &amp;&amp; f.mView.getVisibility() == View.VISIBLE</span><br><span class="line">                                    &amp;&amp; f.mPostponedAlpha &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                anim = FragmentAnim.loadAnimation(mHost.getContext(),</span><br><span class="line">                                        f, <span class="keyword">false</span>, f.getPopDirection());</span><br><span class="line">                            &#125;</span><br><span class="line">                            f.mPostponedAlpha = <span class="number">0</span>;</span><br><span class="line">                            <span class="comment">// Robolectric tests do not post the animation like a real device</span></span><br><span class="line">                            <span class="comment">// so we should keep up with the container and view in case the</span></span><br><span class="line">                            <span class="comment">// fragment view is destroyed before we can remove it.</span></span><br><span class="line">                            ViewGroup container = f.mContainer;</span><br><span class="line">                            View view = f.mView;</span><br><span class="line">                            <span class="keyword">if</span> (anim != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                FragmentAnim.animateRemoveFragment(f, anim,</span><br><span class="line">                                        mFragmentTransitionCallback);</span><br><span class="line">                            &#125;</span><br><span class="line">                            container.removeView(view);</span><br><span class="line">                            <span class="keyword">if</span> (FragmentManager.isLoggingEnabled(Log.VERBOSE)) &#123;</span><br><span class="line">                                Log.v(FragmentManager.TAG, <span class="string">&quot;Removing view &quot;</span> + view + <span class="string">&quot; for &quot;</span></span><br><span class="line">                                        + <span class="string">&quot;fragment &quot;</span> + f + <span class="string">&quot; from container &quot;</span> + container);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// If the local container is different from the fragment</span></span><br><span class="line">                            <span class="comment">// container, that means onAnimationEnd was called, onDestroyView</span></span><br><span class="line">                            <span class="comment">// was dispatched and the fragment was already moved to state, so</span></span><br><span class="line">                            <span class="comment">// we should early return here instead of attempting to move to</span></span><br><span class="line">                            <span class="comment">// state again.</span></span><br><span class="line">                            <span class="keyword">if</span> (container != f.mContainer) &#123;</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// If a fragment has an exit animation (or transition), do not destroy</span></span><br><span class="line">                    <span class="comment">// its view immediately and set the state after animating</span></span><br><span class="line">                    <span class="keyword">if</span> (mExitAnimationCancellationSignals.get(f) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        fragmentStateManager.destroyFragmentView();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> Fragment.CREATED:</span><br><span class="line">                <span class="keyword">if</span> (newState &lt; Fragment.CREATED) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mExitAnimationCancellationSignals.get(f) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// We are waiting for the fragment&#x27;s view to finish animating away.</span></span><br><span class="line">                        newState = Fragment.CREATED;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        fragmentStateManager.destroy();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> Fragment.ATTACHED:</span><br><span class="line">                <span class="keyword">if</span> (newState &lt; Fragment.ATTACHED) &#123;</span><br><span class="line">                    fragmentStateManager.detach();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f.mState != newState) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isLoggingEnabled(Log.DEBUG)) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;moveToState: Fragment state for &quot;</span> + f + <span class="string">&quot; not updated inline; &quot;</span></span><br><span class="line">                    + <span class="string">&quot;expected state &quot;</span> + newState + <span class="string">&quot; found &quot;</span> + f.mState);</span><br><span class="line">        &#125;</span><br><span class="line">        f.mState = newState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-12-20T08:33:02.000Z" title="12/20/2023, 4:33:02 PM">2023-12-20</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.402Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a><span> / </span><a class="link-muted" href="/categories/Android/Framework/">Framework</a></span><span class="level-item">10 minutes read (About 1480 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/20/ServiceManager/">ServiceManager</a></h1><div class="content"><h1 id="ServiceManager的启动"><a href="#ServiceManager的启动" class="headerlink" title="ServiceManager的启动"></a>ServiceManager的启动</h1><p>ServiceManager进程<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/frameworks/native/+/refs/heads/android10-android13-mainline-tzdata-release/cmds/servicemanager/service_manager.c">service_manager.c</a>并没有使用libbinder框架代码，而是自行编写了<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/frameworks/native/+/refs/heads/android10-android13-mainline-tzdata-release/cmds/servicemanager/binder.c">binder.c</a>直接和Binder驱动来通信，ServiceManager是单线程的进程， 不断地循环在binder_loop()过程来读取和处理事务，从而对外提供查询和注册服务的功能，这样的好处是简单而高效。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service_manager.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *driver;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        driver = argv[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        driver = <span class="string">&quot;/dev/binder&quot;</span>; <span class="comment">// 默认的Binder设备节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Step 1: 打开binder驱动，申请128k字节内存</span></span><br><span class="line">    bs = binder_open(driver, <span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Step 2: 成为上下文管理者</span></span><br><span class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Step 3: 进入无限循环，处理client端发来的请求</span></span><br><span class="line">    binder_loop(bs, svcmgr_handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动过程主要划分为以下几个阶段：(每个阶段具体见<a target="_blank" rel="noopener" href="https://gityuan.com/2014/01/02/servicemanager/">5.2.1 启动ServiceManager服务</a>)</p>
<p><img src="/2023/12/20/ServiceManager/create_servicemanager.jpg" alt="create_servicemanager"></p>
<ul>
<li><p>首先，打开设备驱动：调用binder_open()方法来打开binder驱动，默认地采用/dev/binder设备节点，申请地内存空间大小为128KB；</p>
</li>
<li><p>其次，注册成为大管家：调用binder_become_context_manager()方法，将自己注册成为binder服务的唯一管家；</p>
<blockquote>
<p>通过ioctl系统调用向Binder驱动发送命令BINDER_SET_CONTEXT_MGR，成为上下文的管理者，<strong>由于servicemanager进程启动非常早（先于Zygote）</strong>，可以确定在Binder整体机制正式投入产线之前，就能完成向Binder驱动注册成为大管家的工作。 关于驱动层处理BINDER_SET_CONTEXT_MGR命令的主要任务：</p>
<ul>
<li>保证每个Binder上下文有且仅有一个binder管家实体，如果已存在则不再创建</li>
<li>创建binder管家实体，初始化异步事务和binder工作两个队列，并分别增加其强弱引用计数</li>
<li>初始化当前binder_context的管家实体（binder_context_mgr_node）和管家uid(binder_context_mgr_uid)信息</li>
<li>handle等于0的服务实体都是指servicemanager管家实体</li>
</ul>
</blockquote>
</li>
<li><p>最后，等待客户请求：调用binder_loop()方法进入无限循环，作为守护进程，随时待命等待处理client端发来的请求。</p>
</li>
</ul>
<blockquote>
<p>servicemanager先向Binder驱动发送BC_ENTER_LOOPER协议，让ServiceManager进入循环。然后再向驱动发送BINDER_WRITE_READ命令， 进入内核态，等待客户端的请求数据。若没有数据，则进入等待状态，直到收到数据后返回用户态，解析并处理，周而复始地不断循环该过程。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; servicemanager&#x2F;binder.c</span><br><span class="line">void binder_loop(struct binder_state *bs, binder_handler func) &#123;</span><br><span class="line">    int res;</span><br><span class="line">    struct binder_write_read bwr;</span><br><span class="line">    uint32_t readbuf[32];</span><br><span class="line"></span><br><span class="line">    bwr.write_size &#x3D; 0;</span><br><span class="line">    bwr.write_consumed &#x3D; 0;</span><br><span class="line">    bwr.write_buffer &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    readbuf[0] &#x3D; BC_ENTER_LOOPER;</span><br><span class="line">    &#x2F;&#x2F;向binder驱动发送BC_ENTER_LOOPER协议</span><br><span class="line">    binder_write(bs, readbuf, sizeof(uint32_t));</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        bwr.read_size &#x3D; sizeof(readbuf);</span><br><span class="line">        bwr.read_consumed &#x3D; 0;</span><br><span class="line">        bwr.read_buffer &#x3D; (uintptr_t) readbuf;</span><br><span class="line">        &#x2F;&#x2F;等待客户的数据</span><br><span class="line">        res &#x3D; ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">        &#x2F;&#x2F;解析binder信息</span><br><span class="line">        res &#x3D; binder_parse(bs, 0, (uintptr_t) readbuf, bwr.read_consumed, func);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<h1 id="ServiceManager提供的服务"><a href="#ServiceManager提供的服务" class="headerlink" title="ServiceManager提供的服务"></a>ServiceManager提供的服务</h1><p>ServiceManager对外提供查询/注册功能，通过接收到客户端进程发送过来的BR_TRANSACTION协议。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; service_manager.c</span><br><span class="line">int svcmgr_handler(struct binder_state *bs,</span><br><span class="line">                   struct binder_transaction_data *txn,</span><br><span class="line">                   struct binder_io *msg,</span><br><span class="line">                   struct binder_io *reply)</span><br><span class="line">&#123;</span><br><span class="line">    struct svcinfo *si;</span><br><span class="line">    uint16_t *s;</span><br><span class="line">    size_t len;</span><br><span class="line">    uint32_t handle;</span><br><span class="line">    uint32_t strict_policy;</span><br><span class="line">    int allow_isolated;</span><br><span class="line">    ...</span><br><span class="line">    strict_policy &#x3D; bio_get_uint32(msg);</span><br><span class="line">    s &#x3D; bio_get_string16(msg, &amp;len);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    switch(txn-&gt;code) &#123;</span><br><span class="line">    case SVC_MGR_GET_SERVICE:</span><br><span class="line">    case SVC_MGR_CHECK_SERVICE:</span><br><span class="line">        s &#x3D; bio_get_string16(msg, &amp;len); &#x2F;&#x2F;服务名</span><br><span class="line">        &#x2F;&#x2F;根据名称查找相应服务</span><br><span class="line">        handle &#x3D; do_find_service(bs, s, len, txn-&gt;sender_euid, txn-&gt;sender_pid);</span><br><span class="line">        bio_put_ref(reply, handle);</span><br><span class="line">        return 0;</span><br><span class="line">    </span><br><span class="line">    case SVC_MGR_ADD_SERVICE:</span><br><span class="line">        s &#x3D; bio_get_string16(msg, &amp;len); &#x2F;&#x2F;服务名</span><br><span class="line">        handle &#x3D; bio_get_ref(msg); &#x2F;&#x2F;服务实体在servicemanager中的handle</span><br><span class="line">        allow_isolated &#x3D; bio_get_uint32(msg) ? 1 : 0;</span><br><span class="line">         &#x2F;&#x2F;注册指定服务</span><br><span class="line">        if (do_add_service(bs, s, len, handle, txn-&gt;sender_euid,</span><br><span class="line">            allow_isolated, txn-&gt;sender_pid))</span><br><span class="line">            return -1;</span><br><span class="line">        break;</span><br><span class="line">    </span><br><span class="line">    case SVC_MGR_LIST_SERVICES: &#123;  </span><br><span class="line">        uint32_t n &#x3D; bio_get_uint32(msg);</span><br><span class="line">        if (!svc_can_list(txn-&gt;sender_pid)) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        si &#x3D; svclist;</span><br><span class="line">        while ((n-- &gt; 0) &amp;&amp; si)</span><br><span class="line">            si &#x3D; si-&gt;next;</span><br><span class="line">        if (si) &#123;</span><br><span class="line">            bio_put_string16(reply, si-&gt;name);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bio_put_uint32(reply, 0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<p>该方法的功能：查询服务，注册服务，以及列举所有服务。不同的code对应不同的工作，定义在IBinder.h文件，跟IServiceManager.h中定义的code具有一一对应关系，具体关系如下所示。</p>
<table>
<thead>
<tr>
<th align="left">code</th>
<th align="left">IBinder.h</th>
<th align="left">IServiceManager.h</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">SVC_MGR_GET_SERVICE</td>
<td align="left">GET_SERVICE_TRANSACTION</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">SVC_MGR_CHECK_SERVICE</td>
<td align="left">CHECK_SERVICE_TRANSACTION</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">SVC_MGR_ADD_SERVICE</td>
<td align="left">ADD_SERVICE_TRANSACTION</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">SVC_MGR_LIST_SERVICES</td>
<td align="left">LIST_SERVICES_TRANSACTION</td>
</tr>
</tbody></table>
<h2 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h2><p>servicemanager进程里面有一个链表svclist，记录着所有注册的服务svcinfo，每一个服务用svcinfo结构体来表示，该handle值是在注册服务的过程中，由服务所在进程那一端所确定的。svcinfo结构体如下所示。</p>
<img src="/2023/12/20/ServiceManager/5-2-1-service_manager.jpg" alt="ServiceManager进程" style="zoom:80%;">


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> handle; <span class="comment">//服务的handle值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_death</span> <span class="title">death</span>;</span></span><br><span class="line">    <span class="keyword">int</span> allow_isolated;</span><br><span class="line">    <span class="keyword">size_t</span> len; <span class="comment">//服务名的长度</span></span><br><span class="line">    <span class="keyword">uint16_t</span> name[<span class="number">0</span>]; <span class="comment">//服务名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>整个ServiceManager启动过程的完整流程，这里整个过程都的都离不开Binder驱动层的实现。</p>
<p><img src="/2023/12/20/ServiceManager/5-2-2.start_service_manager.jpg" alt="ServiceManager启动过程"></p>
<h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><h3 id="vndservicemanager"><a href="#vndservicemanager" class="headerlink" title="vndservicemanager"></a>vndservicemanager</h3><p>以前，Binder 服务通过 <code>servicemanager</code> 注册，其他进程可从中检索这些服务。在 Android 8 中，<code>servicemanager</code> 现在专供框架使用，而应用进程和供应商进程无法再对其进行访问。</p>
<p>不过，供应商服务现在可以使用 <code>vndservicemanager</code>，这是一个使用 <code>/dev/vndbinder</code>（作为构建基础的源代码与框架 <code>servicemanager</code> 的相同）而非 <code>/dev/binder</code> 的 <code>servicemanager</code> 的新实例。供应商进程无需更改即可与 <code>vndservicemanager</code> 通信；当供应商进程打开 /<code>dev/vndbinder</code> 时，服务查询会自动转至 <code>vndservicemanager</code>。</p>
<p><code>vndservicemanager</code> 二进制文件包含在 Android 的默认设备 Makefile 中。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-10-26T03:34:39.000Z" title="10/26/2023, 11:34:39 AM">2023-10-26</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-04-17T06:45:43.567Z" title="4/17/2024, 2:45:43 PM">2024-04-17</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">25 minutes read (About 3729 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/26/Animation/">Animation</a></h1><div class="content"><p>Android动画分三种：View动画、帧动画、属性动画</p>
<p><img src="/2023/10/26/Animation/image-20231027151841094.png" alt="image-20231027151841094"></p>
<p>是的， check， √</p>
<h2 id="View动画"><a href="#View动画" class="headerlink" title="View动画"></a>View动画</h2><p>View动画定义了渐变Alpha、旋转Rotate、缩放Scale、平移Translate四种基本动画，并且通过这四种基本动画的组合使用，可以实现多种交互效果。<br>View动画使用非常简单，不仅可以通过XML文件来定义动画，同样可以通过Java代码来实现动画过程。</p>
<p>原理：</p>
<p>首先view的绘制是 drawBackground() -&gt; onDraw() -&gt; dispatchDraw() -&gt; onDrawForeground() 的顺序，</p>
<p>//android/view/View.java中的boolean draw(Canvas canvas, ViewGroup parent, long drawingTime)方法</p>
<p>View.setAnimation会将旋转、缩放、平移等动画存下来，动画启动后通过invalidate() ，每一帧中在draw的时候通过canvas.translate、canvas.scale、cavas.setLayerAlpha等方式，执行动画。</p>
<p>故而view动画只会影响view的视觉效果，而不影响起事件响应区域，因为只有draw中处理了，measure和layout都没动</p>
<h3 id="Xml文件实现"><a href="#Xml文件实现" class="headerlink" title="Xml文件实现"></a>Xml文件实现</h3><p>通过xml来定义View动画涉及到一些公有的属性（在AndroidStudio上不能提示）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android:duration     动画持续时间</span><br><span class="line">android:fillAfter    为true动画结束时，View将保持动画结束时的状态</span><br><span class="line">android:fillBefore   为true动画结束时，View将还原到开始开始时的状态</span><br><span class="line">android:repeatCount  动画重复执行的次数</span><br><span class="line">android:repeatMode   动画重复模式 ，重复播放时restart重头开始，reverse重复播放时倒叙回放，该属性需要和android:repeatCount一起使用</span><br><span class="line">android:repeatCount 默认是0，-1是无限循环</span><br><span class="line">android:interpolator 插值器，相当于变速器，改变动画的不同阶段的执行速度</span><br></pre></td></tr></table></figure>

<p>这些属性是从Animation中继承下来的，在<code>alpha</code>、<code>rotate</code>、<code>scale</code>、<code>translate</code>标签中都可以直接使用。<br>利用xml文件定义View动画需要在工程的res目录下创建anim文件夹，所有的xml定义的View动画都要放在anim目录下。其中标签   translate、scale、alpha、rotate，就是对应四种动画。set标签是动画集合，对应AnimationSet类，有多个动画构成。</p>
<p>其中android:duration是指动画时间，fillAfter为true是动画结束后保持，false会回到初始状态。interpolator是指动画的执行速度，默认是先加速后减速。其他标签及属性较简单可自行研究验证。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">&quot;5000&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fillAfter</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:interpolator</span>=<span class="string">&quot;@android:anim/accelerate_decelerate_interpolator&quot;</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--set里面的duration如果有值，会覆盖子标签的duration--&gt;</span></span><br><span class="line"></span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration=&quot;1000&quot;</span><br><span class="line">        android:fromXDelta=&quot;0&quot;</span><br><span class="line">        android:toXDelta=&quot;400&quot; /&gt;</span><br><span class="line">    &lt;scale</span><br><span class="line">        android:duration=&quot;2000&quot;</span><br><span class="line">        android:fromXScale=&quot;0.5&quot;</span><br><span class="line">        android:fromYScale=&quot;0.5&quot;</span><br><span class="line">        android:toXScale=&quot;1&quot;</span><br><span class="line">        android:toYScale=&quot;1&quot; /&gt;</span><br><span class="line">    &lt;alpha</span><br><span class="line">        android:duration=&quot;3000&quot;</span><br><span class="line">        android:fromAlpha=&quot;0.2&quot;</span><br><span class="line">        android:toAlpha=&quot;1&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;rotate</span><br><span class="line">        android:fromDegrees=&quot;0&quot;</span><br><span class="line">        android:toDegrees=&quot;90&quot; /&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>定义好动画后，使用也很简单，调用view的startAnimation方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//view动画使用，方式一：xml，建议使用。</span></span><br><span class="line">      Animation animation = AnimationUtils.loadAnimation(<span class="keyword">this</span>, R.anim.animation_test);</span><br><span class="line">      textView1.startAnimation(animation);</span><br></pre></td></tr></table></figure>

<p><code>rotate</code>、<code>scale</code>动画的<code>android:pivotX</code>和<code>android:pivotY</code>属性、<code>translate</code>动画的<code>android:toXDelta</code>和<code>android:toYDelta</code>属性的取值都可以是都可以数值、百分数、百分数<code>p</code>，比如：<code>50</code>、<code>50%</code>、<code>50%p</code>，他们取值的代表的意义各不相同：<br><code>50</code>表示以View左上角为原点沿坐标轴正方向(<code>x</code>轴向右，<code>y</code>轴向下)偏移<code>50px</code>的位置；<br><code>50%</code>表示以View左上角为原点沿坐标轴正方向(<code>x</code>轴向右，<code>y</code>轴向下)偏移View宽度或高度的50%处的位置；<br><code>50%p</code>表示以View左上角为原点沿坐标轴正方向(<code>x</code>轴向右，<code>y</code>轴向下)偏移父控件宽度或高度的50%处的位置（<code>p</code>表示相对于<code>ParentView</code>的位置）。</p>
<p>“50”：<img src="/2023/10/26/Animation/207f5681fbd42866692f260039ceaca8~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img" style="zoom: 50%;">  ； </p>
<p> “50%”<img src="/2023/10/26/Animation/8fafba2a2171db1efb63052a0370faed~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img" style="zoom:50%;">；</p>
<p>“50%p”<img src="/2023/10/26/Animation/613da23e462d2d04b9afa15d27029749~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img" style="zoom:50%;"></p>
<h3 id="代码动态实现"><a href="#代码动态实现" class="headerlink" title="代码动态实现"></a>代码动态实现</h3><p>在平常的业务逻辑中也可以直接用Java代码来实现Veiw动画，Android系统给我们提供了<code>AlphaAnimation</code>、<code>RotateAnimation</code>、<code>ScaleAnimation</code>、<code>TranslateAnimation</code>四个动画类分别来实现View的渐变、旋转、缩放、平移动画。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;view动画使用，方式二：new 动画对象</span><br><span class="line">        AnimationSet animationSet &#x3D; new AnimationSet(false);</span><br><span class="line">        animationSet.setDuration(3000);</span><br><span class="line">        animationSet.addAnimation(new TranslateAnimation(0, 100, 0, 0));</span><br><span class="line">        animationSet.addAnimation(new ScaleAnimation(0.1f, 1f, 0.1f, 1f));</span><br><span class="line">        animationSet.setFillAfter(true);</span><br><span class="line">        textView2.startAnimation(animationSet);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;view动画使用，方式二：new 动画对象,使用setAnimation</span><br><span class="line">        AnimationSet animationSet2 &#x3D; new AnimationSet(false);</span><br><span class="line">        animationSet2.setDuration(3000);</span><br><span class="line">        animationSet2.addAnimation(new TranslateAnimation(0, 100, 0, 0));</span><br><span class="line">        animationSet2.addAnimation(new ScaleAnimation(0.1f, 1f, 0.1f, 1f));</span><br><span class="line">        animationSet2.setFillAfter(true);</span><br><span class="line">        animationSet2.setAnimationListener(new Animation.AnimationListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationStart(Animation animation) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationEnd(Animation animation) &#123;</span><br><span class="line">                MyToast.showMsg(AnimationTestActivity.this, &quot;View动画：代码 set：View动画结束~&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationRepeat(Animation animation) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        textView3.setAnimation(animationSet2);</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ol>
<li>startAnimation方法是立刻播放动画；setAnimation是设置要播放的下一个动画。</li>
<li>setAnimationListener可以监听动画的开始、结束、重复。</li>
</ol>
<h3 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904105589080078#heading-3">[3D旋转动画]</a></p>
<p>Like:ProgressBarAnimation</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProgressBarAnimation</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> progressBar: ProgressBar, <span class="keyword">private</span> <span class="keyword">val</span> from: <span class="built_in">Int</span>, <span class="keyword">private</span> <span class="keyword">val</span> to: <span class="built_in">Int</span>) :</span><br><span class="line">    Animation() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">applyTransformation</span><span class="params">(interpolatedTime: <span class="type">Float</span>, t: <span class="type">Transformation</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.applyTransformation(interpolatedTime, t)</span><br><span class="line">        <span class="keyword">val</span> value = from + (to - from) * interpolatedTime</span><br><span class="line">        progressBar.progress = value.toInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="布局动画"><a href="#布局动画" class="headerlink" title="布局动画"></a>布局动画</h3><h4 id="LayoutTransition"><a href="#LayoutTransition" class="headerlink" title="LayoutTransition"></a>LayoutTransition</h4><p>使用LayoutAnimation给ViewGroup指定child的出场动画，方法如下：</p>
<p>1.先用xml定义标签LayoutAnimation：</p>
<ul>
<li>android:animation设置child的出场动画</li>
<li>android:animationOrder设置child的出场顺序，normal就是顺序</li>
<li>delay是指：每个child延迟（在android:animation中指定的动画时间）0.8倍后播放动画。如果android:animation中的动画时间是100ms，那么每个child都会延迟800ms后播放动画。 如果不设置delay，那么所有child同时执行动画。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layoutAnimation xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    android:animation&#x3D;&quot;@anim&#x2F;enter_from_left_for_child_of_group&quot;</span><br><span class="line">    android:animationOrder&#x3D;&quot;normal&quot;</span><br><span class="line">    android:delay&#x3D;&quot;0.8&quot;&gt;</span><br><span class="line">&lt;&#x2F;layoutAnimation&gt;</span><br><span class="line">R.anim.enter_from_left_for_child_of_group</span><br><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;set xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;</span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration&#x3D;&quot;1000&quot;</span><br><span class="line">        android:fromXDelta&#x3D;&quot;-100%p&quot;</span><br><span class="line">        android:toXDelta&#x3D;&quot;0&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;set&gt;</span><br></pre></td></tr></table></figure>

<p>2.把LayoutAnimation设置给ViewGroup</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout</span><br><span class="line">    android:id=&quot;@+id/ll_layout_animation&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:orientation=&quot;horizontal&quot;</span><br><span class="line">    android:layoutAnimation=&quot;@anim/layout_animation&quot;&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=&quot;50dp&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:textColor=&quot;#ff0000&quot;</span><br><span class="line">        android:text=&quot;呵呵呵&quot;/&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=&quot;60dp&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:textColor=&quot;#ff0000&quot;</span><br><span class="line">        android:text=&quot;qq&quot;</span><br><span class="line">        android:background=&quot;@color/colorPrimary&quot;/&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=&quot;30dp&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:textColor=&quot;#ff0000&quot;</span><br><span class="line">        android:text=&quot;啊啊&quot;/&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>除了xml，当然也可以使用LayoutAnimationController 指定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码设置LayoutAnimation，实现ViewGroup的child的出场动画</span></span><br><span class="line">Animation enterAnim = AnimationUtils.loadAnimation(<span class="keyword">this</span>, R.anim.enter_from_left_for_child_of_group);</span><br><span class="line">LayoutAnimationController controller = <span class="keyword">new</span> LayoutAnimationController(enterAnim);</span><br><span class="line">controller.setDelay(<span class="number">0.8f</span>);</span><br><span class="line">controller.setOrder(LayoutAnimationController.ORDER_NORMAL);</span><br><span class="line">llLayoutAnimation.setLayoutAnimation(controller);</span><br></pre></td></tr></table></figure>



<h4 id="animateLayoutChanges用处及原理"><a href="#animateLayoutChanges用处及原理" class="headerlink" title="animateLayoutChanges用处及原理"></a>animateLayoutChanges用处及原理</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:animateLayoutChanges=&quot;true&quot;</span><br></pre></td></tr></table></figure>

<p><strong>animateLayoutChanges的实际实现就是LayoutTransition，</strong></p>
<p>android.view.ViewGroup.java</p>
<p><img src="/2023/10/26/Animation/image-20231026114011752.png" alt="image-20231026114011752"></p>
<h3 id="Dialog-Activity转场动画"><a href="#Dialog-Activity转场动画" class="headerlink" title="Dialog/Activity转场动画"></a>Dialog/Activity转场动画</h3><h4 id="Activity转场"><a href="#Activity转场" class="headerlink" title="Activity转场"></a>Activity转场</h4><p>overridePendingTransition</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class XXActivity : Activity() &#123;</span><br><span class="line">	override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">      super.onCreate(savedInstanceState)</span><br><span class="line">      setContentView(R.layout.activity_checkout_rec)</span><br><span class="line">      overridePendingTransition(</span><br><span class="line">          R.anim.slide_in_down, R.anim.slide_in_down</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;set</span><br><span class="line">  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">  android:interpolator=&quot;@android:anim/decelerate_interpolator&quot; &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">translate</span> <span class="attr">android:duration</span>=<span class="string">&quot;200&quot;</span> <span class="attr">android:fromYDelta</span>=<span class="string">&quot;100%p&quot;</span> <span class="attr">android:toYDelta</span>=<span class="string">&quot;0%p&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;set</span><br><span class="line">  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">  android:interpolator=&quot;@android:anim/decelerate_interpolator&quot; &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">translate</span> <span class="attr">android:duration</span>=<span class="string">&quot;200&quot;</span> <span class="attr">android:fromYDelta</span>=<span class="string">&quot;0%p&quot;</span> <span class="attr">android:toYDelta</span>=<span class="string">&quot;100%p&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Dialog转场"><a href="#Dialog转场" class="headerlink" title="Dialog转场"></a>Dialog转场</h4><p>Window?.setWindowAnimatinos()</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXDialog</span></span>(context: Context, <span class="keyword">val</span> anim: PointBean.PointAnimation) :Dialog(context) &#123;</span><br><span class="line">  <span class="keyword">init</span> &#123;</span><br><span class="line">    setContentView(R.layout.threshold_dialog)</span><br><span class="line">    setCanceledOnTouchOutside(<span class="literal">true</span>)</span><br><span class="line">    window?.setGravity(Gravity.CENTER)</span><br><span class="line">    window?.setLayout(MATCH_PARENT, AndroidUtil.getScreenWidth(context))</span><br><span class="line">    window?.setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT));</span><br><span class="line">    window?.setWindowAnimations(R.style.XXDialogAnim)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;XXDialogAnim&quot;</span> <span class="attr">mce_bogus</span>=<span class="string">&quot;1&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;android:Animation&quot;</span>&gt;</span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowEnterAnimation&quot;</span>&gt;</span>@anim/cart_threshold_dialog_enter_anim<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowExitAnimation&quot;</span>&gt;</span>@anim/cart_threshold_dialog_exit_anim<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>







<h2 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h2><p>属性动画本质上是 使用反射调用对象的setXX()、getXX()方法，根据插值器的值变化曲线修改对象属性，所以是视图实实在在的位置、尺寸等属性发生变化并会触发measure、layout，因此点击区域也就发生变化。</p>
<p>属性动画可对任意对象做动画，不仅仅是View。默认动画时间是300ms，10ms/帧。具体理解就是：<strong>可在给定的时间间隔内 实现 对象的某属性值 从 value1 到 value2的改变。</strong></p>
<p>使用很简单，可以直接<strong>代码实现</strong>（推荐），也可xml实现，举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//属性动画使用，方式一：代码，建议使用。 横移</span></span><br><span class="line">      ObjectAnimator translationX = ObjectAnimator</span><br><span class="line">              .ofFloat(textView6, <span class="string">&quot;translationX&quot;</span>, <span class="number">0</span>, <span class="number">200</span>)</span><br><span class="line">              .setDuration(<span class="number">1000</span>);</span><br><span class="line">      translationX.setInterpolator(<span class="keyword">new</span> LinearInterpolator());</span><br><span class="line">      setAnimatorListener(translationX);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//属性动画使用，方式二：xml。   竖移</span></span><br><span class="line">      Animator animatorUpAndDown = AnimatorInflater.loadAnimator(<span class="keyword">this</span>, R.animator.animator_test);</span><br><span class="line">      animatorUpAndDown.setTarget(textView6);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//文字颜色变化</span></span><br><span class="line">      ObjectAnimator textColor = ObjectAnimator</span><br><span class="line">              .ofInt(textView6, <span class="string">&quot;textColor&quot;</span>, <span class="number">0xffff0000</span>, <span class="number">0xff00ffff</span>)</span><br><span class="line">              .setDuration(<span class="number">1000</span>);</span><br><span class="line">      textColor.setRepeatCount(ValueAnimator.INFINITE);</span><br><span class="line">      textColor.setRepeatMode(ValueAnimator.REVERSE);</span><br><span class="line">      <span class="comment">//注意，这里如果不设置 那么颜色就是跳跃的，设置ArgbEvaluator 就是连续过度的颜色变化</span></span><br><span class="line">      textColor.setEvaluator(<span class="keyword">new</span> ArgbEvaluator());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//animatorSet</span></span><br><span class="line">      mAnimatorSet = <span class="keyword">new</span> AnimatorSet();</span><br><span class="line">      mAnimatorSet</span><br><span class="line">              .play(animatorUpAndDown)</span><br><span class="line">              .with(textColor)</span><br><span class="line">              .after(translationX);</span><br><span class="line"></span><br><span class="line">      mAnimatorSet.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置属性动画的监听</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> translationX</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setAnimatorListener</span><span class="params">(ObjectAnimator translationX)</span> </span>&#123;</span><br><span class="line">      translationX.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">              <span class="comment">//每播放一帧，都会调用</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">          translationX.addPauseListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationResume</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">super</span>.onAnimationResume(animation);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      translationX.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">super</span>.onAnimationEnd(animation);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>R.animator.animator_test，是放在res/animator中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--属性动画test,一般建议采用代码实现，不用xml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:ordering</span>=<span class="string">&quot;sequentially&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--repeatCount：默认是0，-1是无限循环--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--repeatMode：重复模式：restart-从头来一遍、reverse-反向来一遍--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--valueType：指定propertyName的类型可选intType、floatType--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--android:pathData=&quot;&quot;</span></span><br><span class="line"><span class="comment">        android:propertyXName=&quot;&quot;</span></span><br><span class="line"><span class="comment">        android:propertyYName=&quot;&quot;--&gt;</span></span><br><span class="line">    &lt;objectAnimator</span><br><span class="line">        android:propertyName=&quot;translationY&quot;</span><br><span class="line">        android:duration=&quot;1000&quot;</span><br><span class="line">        android:valueFrom=&quot;0&quot;</span><br><span class="line">        android:valueTo=&quot;120&quot;</span><br><span class="line">        android:startOffset=&quot;0&quot;</span><br><span class="line">        android:repeatCount=&quot;0&quot;</span><br><span class="line">        android:repeatMode=&quot;reverse&quot;</span><br><span class="line">        android:valueType=&quot;floatType&quot;</span><br><span class="line">        android:interpolator=&quot;@android:interpolator/accelerate_decelerate&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--animator对用vueAnimator，比objectAnimator少了propertyName--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;animator--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--android:duration=&quot;2000&quot;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--android:valueFrom=&quot;&quot;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--android:valueTo=&quot;&quot;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--android:startOffset=&quot;&quot;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--android:repeatCount=&quot;&quot;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--android:repeatMode=&quot;&quot;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--android:valueType=&quot;&quot;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--android:interpolator=&quot;&quot;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--android:pathData=&quot;&quot;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--android:propertyXName=&quot;&quot;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--android:propertyYName=&quot;&quot;/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>translationX是实现横移，animatorUpAndDown是实现竖移、textColor是实现文字颜色变化。其中animatorUpAndDown是使用xml定义，标签含义也很好理解。 最后使用AnimatorSet的play、with、after 实现 先横移，然后 竖移和颜色变化 同时的动画集合效果。</p>
<p><strong>注意点</strong>：</p>
<ol>
<li><strong>关于View动画和属性动画的平移</strong>，<strong>属性动画改变属性值setTranslationX 的视图效果像view动画的平移一样，都是view实际的layout位置没变，只改变了视图位置；不同点是属性动画 给触摸点生效区域增加了位移（而view动画仅改变了视图位置）。</strong></li>
<li><strong>插值器</strong>：Interpolator，根据 时间流逝的百分比，计算当前属性值改变的百分比。    例如duration是1000，start后过了200，那么时间百分比是0.2，那么如果差值器是LinearInterpolator线性差值器，那么属性值改变的百分比也是0.2</li>
<li><strong>估值器</strong>：Evaluator，就是根据 差值器获取的 属性值百分比，计算改变后的属性值。  ofInt、onFloat内部会自动设置IntEvaluator、FloatEvaluator。如果使用ofInt且是颜色相关的属性，就要设置ArgbEvaluator。 上面例子中 文字颜色变化动画 设置了ArgbEvaluator：textColor.setEvaluator(new ArgbEvaluator())。</li>
<li><strong>动画监听</strong>：主要是两个监听接口，AnimatorUpdateListener、AnimatorListenerAdapter。AnimatorUpdateListener的回调方法在每帧更新时都会调用一次；AnimatorListenerAdapter可以监听开始、结束、暂停、继续、重复、取消，重写你要关注的方法即可。</li>
</ol>
<h3 id="对任意属性做动画"><a href="#对任意属性做动画" class="headerlink" title="对任意属性做动画"></a>对任意属性做动画</h3><p>一个问题，针对下面的Button，如何实现 的宽度逐渐拉长的动画，即文字不变，仅拉长背景宽度？</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">    android:id=&quot;@+id/button_animator_test&quot;</span><br><span class="line">    android:layout_width=&quot;180dp&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:text=&quot;任意属性动画-宽度拉长&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>首先，View动画的ScaleAnimation是无法实现的，因为view的scale是把view的视图放大，这样文字也会拉长变形。那么属性动画呢？试试~</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator width1 = ObjectAnimator.ofInt(button, &quot;width&quot;, 1000);</span><br><span class="line">width1.setDuration(2000);</span><br><span class="line">width1.start();</span><br></pre></td></tr></table></figure>

<p>但是发现，没有效果！这是为啥呢？解释如下.</p>
<p><strong>对object 的任意属性做动画 要求两个条件：</strong></p>
<ol>
<li>object有 对应属性 的set方法，动画中没设置初始值 还要有get方法，系统要去取初始值（不满足则会crash）。</li>
<li>set方法要对object有所改变，如UI的变化。不满足则会没有动画效果</li>
</ol>
<p>上面Button没有动画效果，就是没有满足第二条。看下Button的setWidth方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> pixels)</span> </span>&#123;</span><br><span class="line">    mMaxWidth = mMinWidth = pixels;</span><br><span class="line">    mMaxWidthMode = mMinWidthMode = PIXELS;</span><br><span class="line">    requestLayout();</span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际就是TextView的setWidth方法，看到设置进去的值仅影响了宽度最大值和最小值。按照官方注释和实测，发现只有当Button/TextView在xml中设置android:layout_width为”wrap_content”时，才会setWidth改变宽度；而当Button/TextView在xml中设置android:layout_width为固定dp值时，setWidth无效。 而我们上面给出的Button xml中确实是固定值180dp，所以是属性”width”的setWidth是无效的，即不满足第二条要求，就没有动画效果了。（当修改Button xml中设置android:layout_width为”wrap_content”时，上面执行的属性动画是生效的。）</p>
<p>那么，当不满足条件时，如何解决此问题呢？ 有如下处理方法：</p>
<ol>
<li>给object添加set、get方法，如果有权限。（一般不行，如TextView是SDK里面的不能直接改）</li>
<li><strong>给Object包装一层，在包装类中提供set、get方法。</strong></li>
<li><strong>使用ValueAnimator，监听Value变化过程，自己实现属性的改变。</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testAnimatorAboutButtonWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Button width 属性动画：如果xml中宽度是wrap_content，那么动画有效。</span></span><br><span class="line">        <span class="comment">// 如果设置button确切的dp值，那么无效，因为对应属性&quot;width&quot;的setWidth()方法就是 在wrap_content是才有效。</span></span><br><span class="line">        ObjectAnimator width1 = ObjectAnimator.ofInt(button, <span class="string">&quot;width&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">        width1.setDuration(<span class="number">2000</span>);</span><br><span class="line"><span class="comment">//        width1.start();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//那么，想要在button原本有确切dp值时，要能对width动画，怎么做呢？</span></span><br><span class="line">        <span class="comment">//方法一，包一层，然后用layoutParams</span></span><br><span class="line">        ViewWrapper wrapper = <span class="keyword">new</span> ViewWrapper(button);</span><br><span class="line">        ObjectAnimator width2 = ObjectAnimator.ofInt(wrapper, <span class="string">&quot;width&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">        width2.setDuration(<span class="number">2000</span>);</span><br><span class="line"><span class="comment">//        width2.start();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法二，使用ValueAnimator，每一帧自己显示宽度的变化</span></span><br><span class="line">        ValueAnimator valueAnimator = ValueAnimator.ofInt(button.getLayoutParams().width, <span class="number">1000</span>);</span><br><span class="line">        valueAnimator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> animatedValue = (Integer) animation.getAnimatedValue();</span><br><span class="line">                Log.i(<span class="string">&quot;hfy&quot;</span>, <span class="string">&quot;onAnimationUpdate: animatedValue=&quot;</span> + animatedValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">//                IntEvaluator intEvaluator = new IntEvaluator();</span></span><br><span class="line"><span class="comment">////                获取属性值改变比例、计算属性值</span></span><br><span class="line"><span class="comment">//                float animatedFraction = animation.getAnimatedFraction();</span></span><br><span class="line"><span class="comment">//                Integer evaluate = intEvaluator.evaluate(animatedFraction, 300, 600);</span></span><br><span class="line"><span class="comment">//                Log.i(&quot;hfy&quot;, &quot;onAnimationUpdate: evaluate=&quot;+evaluate);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (button != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    button.getLayoutParams().width = animatedValue;</span><br><span class="line">                    button.requestLayout();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        valueAnimator.setDuration(<span class="number">4000</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包一层，提供对应属性的set、get方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> View mView;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ViewWrapper</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            mView = view;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mView.getLayoutParams().width;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">            ViewGroup.LayoutParams layoutParams = mView.getLayoutParams();</span><br><span class="line">            layoutParams.width = width;</span><br><span class="line">            mView.setLayoutParams(layoutParams);</span><br><span class="line">            mView.requestLayout();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h3 id="属性动画的原理"><a href="#属性动画的原理" class="headerlink" title="属性动画的原理"></a>属性动画的原理</h3><p>属性动画，要求对象有这个属性的set方法，执行时会根据传入的 属性初始值、最终值，在每帧更新时调用set方法设置当前时刻的 属性值。随着时间推移，set的属性值会接近最终值，从而达到动画效果。如果没传入初始值，那么对象还要有get方法，用于获取初始值。</p>
<p><strong>在获取初始值、set属性值时，都是使用  反射  的方式，进行 get、set方法的调用。</strong> 见PropertyValuesHolder的setupValue、setAnimatedValue方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupValue</span><span class="params">(Object target, Keyframe kf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mProperty != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object value = convertBack(mProperty.get(target));</span><br><span class="line">        kf.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mGetter == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Class targetClass = target.getClass();</span><br><span class="line">                setupGetter(targetClass);</span><br><span class="line">                <span class="keyword">if</span> (mGetter == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Already logged the error - just return to avoid NPE</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Object value = convertBack(mGetter.invoke(target));</span><br><span class="line">            kf.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;PropertyValuesHolder&quot;</span>, e.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;PropertyValuesHolder&quot;</span>, e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAnimatedValue</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mProperty != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mProperty.set(target, getAnimatedValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mSetter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mTmpValueArray[<span class="number">0</span>] = getAnimatedValue();</span><br><span class="line">            mSetter.invoke(target, mTmpValueArray);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;PropertyValuesHolder&quot;</span>, e.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;PropertyValuesHolder&quot;</span>, e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上效果图：</p>
<p><img src="/2023/10/26/Animation/17121317607bf110~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<h3 id="使用动画的注意事项"><a href="#使用动画的注意事项" class="headerlink" title="使用动画的注意事项"></a>使用动画的注意事项</h3><ol>
<li><p>使用帧动画，避免OOM。因为图片多。</p>
</li>
<li><p>属性动画 如果有循环动画，在页面退出时要及时停止，避免内存泄漏。</p>
</li>
<li><p>使用View动画后，调用setVisibility(View.GONE)失效时，使用view.clearAnimation()可解决。</p>
</li>
<li><p>属性动画，可能会由于View属性变化导致频繁触发重新measure layout，注意性能</p>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-10-10T07:40:35.000Z" title="10/10/2023, 3:40:35 PM">2023-10-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.376Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a><span> / </span><a class="link-muted" href="/categories/Android/AAC/">AAC</a></span><span class="level-item">a few seconds read (About 1 word)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/10/Lifecycle/">Lifecycle</a></h1><div class="content"><span id="more"></span>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-10-10T07:40:13.000Z" title="10/10/2023, 3:40:13 PM">2023-10-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.415Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a><span> / </span><a class="link-muted" href="/categories/Android/AAC/">AAC</a></span><span class="level-item">16 minutes read (About 2408 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/10/ViewModel/">ViewModel</a></h1><div class="content"><p>简述：<code>fragment</code>或<code>componentActivity</code>实现了<code>ViewModelStoreOwner</code>接口，实现该接口方法<code>getViewModelStore()</code>，当调用<code>ViewModelProvider(ViewModelStoreOwner owner).get(Class&lt;T&gt; modelClass)</code>时，会使用工厂模式创建<code>viewModel</code>，之后将其以<code>canonicalName（全限定名）</code>为key存入<code>mViewModelStore</code>中，<code>ViewModelStore</code>内部是个<code>HashMap&lt;String, ViewModel&gt;</code>。</p>
<p>当屏幕旋转或切换系统语言等配置修改的行为发生时，<code>Activity</code> 生命周期从销毁再重建，在销毁时（系统杀死或配置修改），如果判断系统配置没有变化（即<code>!isChangingConfigurations</code>）清空保存的<code>ViewModel</code>（即<code> getViewModelStore().clear();</code>）</p>
<p>如果发生变化则调用<code>onRetainNonConfigurationInstance()</code> 方法将 <code>viewModelStore</code> 保存起来，当Activity重建时则从<code>getLastNonConfigurationInstance()</code>中获取保存的<code>mViewModelStore</code></p>
<p>ps：如果ViewModelProvider传入Activity，则取得是Activity的ViewModelStore，如果传入了fragment，则根据以下代码取ViewModelStore，即先取父fragment的FragmentManager的ViewModelStore，再取hostActivty的ViewModelStore，最后才是新建一个。</p></div><a class="article-more button is-small is-size-7" href="/2023/10/10/ViewModel/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-08-17T03:31:21.000Z" title="8/17/2023, 11:31:21 AM">2023-08-17</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.005Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">14 minutes read (About 2097 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/08/17/Design-Pattrens/">Design Pattrens</a></h1><div class="content"><h1 id="设计模式的六个原则"><a href="#设计模式的六个原则" class="headerlink" title="设计模式的六个原则"></a>设计模式的六个原则</h1><ol>
<li>单一原则<br>每个类或方法都应该只被一个原因影响</li>
<li>开闭原则<br>类或方法应该对扩展开放, 对修改封闭</li>
<li>里氏替换原则<br>子类出现的地方一定可以被父类替换</li>
<li>接口隔离原则<br>接口的粒度要尽量的小</li>
<li>依赖倒置原则<br>抽象依赖抽象, 具体依赖抽象</li>
<li>迪米特原则<br>尽量无知, 朋友的朋友不是我的朋友</li>
</ol></div><a class="article-more button is-small is-size-7" href="/2023/08/17/Design-Pattrens/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-07-12T09:00:29.000Z" title="7/12/2023, 5:00:29 PM">2023-07-12</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-04-24T09:35:45.497Z" title="4/24/2024, 5:35:45 PM">2024-04-24</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">5 minutes read (About 767 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/07/12/BIDI-%E7%AE%97%E6%B3%95/">bidi 算法</a></h1><div class="content"><h2 id="逻辑顺序与视觉顺序"><a href="#逻辑顺序与视觉顺序" class="headerlink" title="逻辑顺序与视觉顺序"></a><strong>逻辑顺序与视觉顺序</strong></h2><p>[I] 逻辑顺序：指人们阅读和从键盘上输入的文字顺序，文本在内存里也是以逻辑顺序存储的。<br>[II] 视觉顺序：则是文本在屏幕或是打印机中显示的顺序。</p>
<h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><p><strong>[I] 阿拉伯文、希伯来文及其派生语言的本土字符为“强RTL字符”</strong><br><strong>[II] 我们通常见到的中文、英文等语言的本土字符为“强LTR字符”</strong><br><strong>[III] 欧洲数字、东方阿拉伯，数字，逗号，冒号，句号（即小数点）等为“弱字符”</strong><br><strong>[IV] 括号，中括号，尖括号，空格符，大多数标点符号为“中性字符”</strong></p>
<p><img src="/2023/07/12/BIDI-%E7%AE%97%E6%B3%95/image-20230818153319225.png" alt="image-20230818153319225"></p></div><a class="article-more button is-small is-size-7" href="/2023/07/12/BIDI-%E7%AE%97%E6%B3%95/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-03-16T07:49:00.000Z" title="3/16/2023, 3:49:00 PM">2023-03-16</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.272Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">a few seconds read (About 0 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/03/16/InputMangerService/">InputMangerService</a></h1><div class="content"></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-03-14T03:05:17.000Z" title="3/14/2023, 11:05:17 AM">2023-03-14</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.414Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">4 minutes read (About 664 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/03/14/Tools/">Tools</a></h1><div class="content"><h3 id="AOSP"><a href="#AOSP" class="headerlink" title="AOSP"></a>AOSP</h3><p>Android 代码搜索 ( <a target="_blank" rel="noopener" href="https://cs.android.com/?hl=zh-cn">cs.android.com</a> ) </p>
<p><a target="_blank" rel="noopener" href="https://developers.google.com/code-search?hl=zh-cn">代码搜索文档</a>。</p>
<h3 id="ClipBoard"><a href="#ClipBoard" class="headerlink" title="ClipBoard"></a>ClipBoard</h3><p>Download the <a target="_blank" rel="noopener" href="https://github.com/majido/clipper/releases/download/v1.2.1/clipper.apk">application apk</a> and manually install application on your android device.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># am broadcast -a clipper.set -e text &quot;this can be pasted now&quot;</span><br><span class="line"># am broadcast -a clipper.get</span><br></pre></td></tr></table></figure>





<h3 id="BookMark"><a href="#BookMark" class="headerlink" title="BookMark"></a>BookMark</h3><p><a target="_blank" rel="noopener" href="https://www.processon.com/apps/6239af581e085306f8cba701">ProcessOn</a></p>
<p><a target="_blank" rel="noopener" href="https://write.youdao.com/edit/#/index?from=index_top">语法</a></p>
<p><a target="_blank" rel="noopener" href="https://apilevels.com/">API Levels | Android versions, SDK/API levels, version codes, codenames, and cumulative usage</a></p>
<p><a target="_blank" rel="noopener" href="https://www.qrcode-monkey.com/">QRCode生成</a></p>
<p><a target="_blank" rel="noopener" href="http://gityuan.com/2016/01/02/memory-analysis-command/">Android内存分析命令 - Gityuan博客 | 袁辉辉的技术博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.myfixguide.com/color-converter/">Color Converter - RGB, HEX, HSL, ARGB, RGBA</a></p>
<p><a target="_blank" rel="noopener" href="https://www.unixtimestamp.com/">Unix Time Stamp - Epoch Converter</a></p>
<p><a target="_blank" rel="noopener" href="https://time.is/zh/Los_Angeles">Time 洛杉矶: 01:04</a></p>
<p><a target="_blank" rel="noopener" href="https://chat.openai.com/chat">chatGpt-New chat</a></p>
<h3 id="Watching"><a href="#Watching" class="headerlink" title="Watching"></a>Watching</h3><ul>
<li>TechPlatform<a target="_blank" rel="noopener" href="https://deepin-wine.i-m.dev/">软件包列表</a><a target="_blank" rel="noopener" href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站</a><a target="_blank" rel="noopener" href="http://linuxcommand.org/lc3_lts0010.php">Learning the shell - Lesson 1: What is the shell?</a><a target="_blank" rel="noopener" href="https://juejin.cn/team/6930545192860647431/posts">字节跳动技术团队 的团队主页</a><a target="_blank" rel="noopener" href="https://www.infoq.cn/">InfoQ - 促进软件开发及相关领域知识与创新的传播-极客邦</a><a target="_blank" rel="noopener" href="https://time.geekbang.org/">极客时间-轻松学习，高效学习-极客邦</a></li>
<li><a target="_blank" rel="noopener" href="http://gityuan.com/2017/01/01/input-anr/">Input系统—ANR原理分析 - Gityuan博客 | 袁辉辉的技术博客</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/fWoXprt2TFL1tTapt7esYg">微信Android客户端的ANR监控方案</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ApNSEWxQdM19QoCNijagtg">今日头条 ANR 优化实践系列 - 设计原理及影响因素</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huansky/p/14954020.html">深入理解 Android ANR 触发原理以及信息收集过程 - huansky - 博客园</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7062552765117136903">一文读懂直播卡顿优化那些事儿 - 掘金</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7072198840035573790">一文读懂 Android FFmpeg 视频解码过程与实战分析 - 掘金</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7052625610295738382">btrace 开源！基于 Systrace 高性能 Trace 工具 - 掘金</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1821336">深入剖析虚拟内存工作原理 - 云+社区 - 腾讯云</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6874916707543187463">OutOfMemoryError 可以被 try catch 吗？ - 掘金</a></li>
<li><a target="_blank" rel="noopener" href="https://ata.alibaba-inc.com/articles/249046">Android高性能高稳定性代码覆盖率方案探索实践 - ATA</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1xy4y1K71K/?buvid=XY2DD82264BAE13B4DF90BC5EA9D8E57584EE&is_story_h5=false&mid=in/X7XJiuX641FpfUXYHvw==&p=1&plat_id=114&share_from=ugc&share_medium=android&share_plat=android&share_session_id=06adf935-8599-4e31-b1fc-22e0bc2c2cbb&share_source=COPY&share_tag=s_i&timestamp=1675050106&unique_k=nI06Mby&up_id=1902539924">word list 1_哔哩哔哩_bilibili</a></li>
<li><a target="_blank" rel="noopener" href="https://source.android.com/source/code-style?hl=zh-cn#follow-field-naming-conventions">面向贡献者的 AOSP 代码样式指南  | Android 开源项目  | Android Open Source Project</a></li>
</ul>
<h3 id="Doc"><a href="#Doc" class="headerlink" title="Doc"></a>Doc</h3><h3 id="doc"><a href="#doc" class="headerlink" title="doc"></a>doc</h3><ul>
<li><a target="_blank" rel="noopener" href="https://shimo.im/docs/gXqmezbm8piQZWqo">Articles</a></li>
<li><a target="_blank" rel="noopener" href="https://shimo.im/docs/WlArzKMYxlFvJ7A2">technology</a></li>
<li><a target="_blank" rel="noopener" href="https://shimo.im/docs/2wAlXDBwrMSGONAP">Other</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-03-06T07:19:06.000Z" title="3/6/2023, 3:19:06 PM">2023-03-06</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:02.999Z" title="3/25/2024, 3:35:02 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">18 minutes read (About 2761 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/03/06/CustomView/">CustomView</a></h1><div class="content"><img src="/2023/03/06/CustomView/image-20230306192616454.png" alt="image-20230306192616454" style="zoom:33%;"></div><a class="article-more button is-small is-size-7" href="/2023/03/06/CustomView/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-02-22T03:46:25.000Z" title="2/22/2023, 11:46:25 AM">2023-02-22</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.434Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">2 minutes read (About 247 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/02/22/bash-profile/">.bash_profile</a></h1><div class="content"><p>#jdk<br>#jdk-11.0.12.jdk or jdk1.8.0_291.jdk<br>export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_291.jdk/Contents/Home<br>#export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-11.0.12.jdk/Contents/Home<br>export PATH=$JAVA_HOME/bin:$PATH<br>export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar<br>#android sdk<br>export ANDROID_HOME=/Users/crow/Library/Android/sdk<br>export PATH=${PATH}:${ANDROID_HOME}/tools<br>export PATH=${PATH}:${ANDROID_HOME}/platform-tools<br>#android ndk<br>export ANDROID_NDK_HOME=/Users/crow/Library/Android/sdk/ndk-bundle<br>export PATH=$PATH:$ANDROID_NDK_HOME</p>
<p>#alias<br>#screen shot phone<br>alias ss=’adb shell screencap /sdcard/screenshot.png &amp;&amp; adb pull /sdcard/screenshot.png . &amp;&amp; open ./screenshot.png’<br>alias screenShot=’adb shell screencap /sdcard/screenshot.png &amp;&amp; adb pull /sdcard/screenshot.png . &amp;&amp; open ./screenshot.png’</p>
<p>#screen record<br>alias sr=’adb shell screenrecord /sdcard/video.mp4’<br>alias startRecord=’adb shell screenrecord /sdcard/video.mp4’<br>#control + c to stop<br>alias showRecord=’adb pull /sdcard/video.mp4 . &amp;&amp; open ./video.mp4’</p>
<p>#adb input text to phone<br>myinput() { adb shell input text “$1” }<br>alias input=’myinput ‘</p>
<p>#adb stop/start app<br>alias stopApp=’adb shell am force-stop com.alibaba.aliexpresshd’<br>alias startApp=’adb shell am start “com.alibaba.aliexpresshd/com.alibaba.aliexpresshd.home.ui.MainActivity”‘</p>
<p>#adb debug app<br>alias debugApp=’adb shell am start -D “com.alibaba.aliexpresshd/com.alibaba.aliexpresshd.home.ui.MainActivity”‘</p>
<p>#gradle<br>dependencies() { ./gradlew “$1”:dependencies –configuration debugRuntimeClasspath }<br>alias depen=’dependencies’</p>
<p>#incremental command<br>alias increment=’bash &lt;(curl -s <a target="_blank" rel="noopener" href="https://gitlab.alibaba-inc.com/chenzhong.cz/incremental_scripts/raw/dev_parallel_aliexpress_mtl4/incremental.sh)&#39;">https://gitlab.alibaba-inc.com/chenzhong.cz/incremental_scripts/raw/dev_parallel_aliexpress_mtl4/incremental.sh)&#39;</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-08-10T07:25:27.000Z" title="8/10/2022, 3:25:27 PM">2022-08-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.414Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">a few seconds read (About 0 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/08/10/Throwable/">Throwable</a></h1><div class="content"></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-08-08T09:14:02.000Z" title="8/8/2022, 5:14:02 PM">2022-08-08</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:02.929Z" title="3/25/2024, 3:35:02 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a><span> / </span><a class="link-muted" href="/categories/Android/Framework/">Framework</a></span><span class="level-item">34 minutes read (About 5028 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/08/08/Binder/">Binder</a></h1><div class="content"><p>为什么是Binder</p>
<p><img src="/2022/08/08/Binder/v2-30dce36be4e6617596b5fab96ef904c6_1440w.jpg" alt="img"></p>
<p>具体见QA。</p>
<p>一次完整的 Binder IPC 通信过程通常是这样：</p>
<ol>
<li></li>
</ol>
<p>其内存流向是这样的：</p>
<ol>
<li>首先 Binder 驱动在内核空间创建一个数据接收缓存区；</li>
<li>接着在内核空间开辟一块内核缓存区，建立<strong>内核缓存区</strong>和<strong>内核中数据接收缓存区</strong>之间的映射关系，以及<strong>内核中数据接收缓存区</strong>和<strong>接收进程用户空间地址</strong>的映射关系；</li>
<li>发送方进程通过系统调用 copy_from_user() 将数据 copy 到内核中的<strong>内核缓存区</strong>，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。</li>
</ol>
<p>如下图：</p>
<p><img src="/2022/08/08/Binder/nzNJUA.png" alt="nzNJUA.png"></p></div><a class="article-more button is-small is-size-7" href="/2022/08/08/Binder/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-07-26T03:36:06.000Z" title="7/26/2022, 11:36:06 AM">2022-07-26</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.218Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">9 minutes read (About 1303 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/26/Git/">Git</a></h1><div class="content"><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p><strong>Q：每次commit，Git储存的是全新的文件快照还是储存文件的变更部分？</strong></p>
<p><strong>A: 全新的文件快照</strong></p>
<p>Git储存的是全新的文件快照，而不是文件的变更记录。也就是说，就算你只是在文件中添加一行，Git也会新建一个全新的blob object。那这样子是不是很浪费空间呢?</p>
<p>这其实是Git在空间和时间上的一个取舍，思考一下你要checkout一个commit，或对比两个commit之间的差异。如果Git储存的是问卷的变更部分，那么为了拿到一个commit的内容，Git都只能从第一个commit开始，然后一直计算变更，直到目标commit，这会花费很长时间。而相反，Git采用的储存全新文件快照的方法能使这个操作变得很快，直接从快照里面拿取内容就行了。</p>
<p>当然，在涉及网络传输或者Git仓库真的体积很大的时候，Git会有垃圾回收机制gc，不仅会清除无用的object，还会把已有的相似object打包压缩。</p></div><a class="article-more button is-small is-size-7" href="/2022/07/26/Git/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-07-05T11:28:18.000Z" title="7/5/2022, 7:28:18 PM">2022-07-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.056Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">3 hours read (About 27678 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/05/Full-QA/">Full-QA</a></h1><div class="content"><h1 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h1><h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a><strong>TCP三次握手</strong></h3><p> <strong>三次握手过程：</strong></p>
<p> 客户端——发送带有SYN标志的数据包——服务端 <strong>一次握手</strong> Client进入syn_sent状态</p>
<p> 服务端——发送带有SYN/ACK标志的数据包——客户端 <strong>二次握手</strong> 服务端进入syn_rcvd</p>
<p> 客户端——发送带有ACK标志的数据包——服务端 <strong>三次握手</strong> 连接就进入Established状态</p></div><a class="article-more button is-small is-size-7" href="/2022/07/05/Full-QA/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-03-16T08:02:24.000Z" title="3/16/2022, 4:02:24 PM">2022-03-16</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.410Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">4 minutes read (About 614 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/03/16/TaskPerFrame/">TaskPerFrame</a></h1><div class="content"><h3 id="16ms-内都需要完成什么？"><a href="#16ms-内都需要完成什么？" class="headerlink" title="16ms 内都需要完成什么？"></a><strong>16ms 内都需要完成什么</strong>？</h3><p>from :  <a target="_blank" rel="noopener" href="https://juejin.cn/post/7062552765117136903">https://juejin.cn/post/7062552765117136903</a></p>
<p><img src="/2022/03/16/TaskPerFrame/039f2506191a4c738fba6fb40545123e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="图片"></p>
<h4 id="Vsync顶层"><a href="#Vsync顶层" class="headerlink" title="// Vsync顶层"></a>// Vsync顶层</h4><ol>
<li><p><strong>Vsync 调度</strong>：硬件每隔16.6ms发出硬件Vsync信号，需要经过软件调度，类似注册，才能收到回调</p>
</li>
<li><p><strong>消息调度</strong>：主要是 doframe 的消息调度，如果消息被阻塞，会直接造成卡顿；</p>
</li>
<li><p><strong>input 处理</strong>：触摸事件的处理；</p>
</li>
<li><p><strong>动画处理</strong>：animator 动画执行和渲染；</p>
</li>
<li><p><strong>view 处理</strong>：主要是 view 相关的遍历和三大流程；</p>
</li>
<li><p><strong>measure、layout、draw</strong>：view 三大流程的执行；</p>
<h4 id="Vsync底层"><a href="#Vsync底层" class="headerlink" title="//Vsync底层"></a>//Vsync底层</h4></li>
<li><p><strong>DisplayList 更新</strong>：view 硬件加速后的 draw op；</p>
</li>
<li><p><strong>OpenGL 指令转换</strong>：canvas指令转换为 OpenGL 指令；</p>
</li>
<li><p><strong>指令 buffer 交换</strong>：OpenGL 的指令交换到 GPU 内部执行；</p>
</li>
<li><p><strong>GPU 处理</strong>：GPU 对数据的处理过程；</p>
</li>
<li><p><strong>layer 合成</strong>：surface buffer 合成屏幕显示 buffer 的流程；</p>
</li>
<li><p><strong>光栅化</strong>：将矢量图转换为位图；</p>
</li>
<li><p><strong>Display</strong>：显示控制；</p>
</li>
<li><p><strong>buffer 切换</strong>：切换屏幕显示的帧 buffer；</p></li></ol></div><a class="article-more button is-small is-size-7" href="/2022/03/16/TaskPerFrame/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-03-10T08:16:46.000Z" title="3/10/2022, 4:16:46 PM">2022-03-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-07-04T06:15:34.931Z" title="7/4/2024, 2:15:34 PM">2024-07-04</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">33 minutes read (About 4951 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/03/10/RenderBlock/">RenderBlock</a></h1><div class="content"><p>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7062552765117136903">https://juejin.cn/post/7062552765117136903</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/topic/performance/rendering/profile-gpu?hl=zh-cn">https://developer.android.com/topic/performance/rendering/profile-gpu?hl=zh-cn</a></p>
<h3 id="RenderThread的作用："><a href="#RenderThread的作用：" class="headerlink" title="RenderThread的作用："></a>RenderThread的作用：</h3><p>主线程的 draw 函数并没有真正的执行 drawCall ，而是把要 draw 的内容记录到 DIsplayList 里面（在 Measure、Layout、Draw 的 Draw 这个环节，Android 使用 DisplayList 进行绘制而非直接使用 CPU 绘制每一帧。），同步到 RenderThread 中，一旦同步完成，主线程就可以被释放出来做其他的事情，RenderThread 则继续进行渲染工作<br><img src="https://github.com/WhileCrow/BlackCrow/assets/26061465/174fcbc3-c736-45c7-8613-c73bbb81cd7f" alt="image"></p>
<h3 id="2-3-生产者和消费者"><a href="#2-3-生产者和消费者" class="headerlink" title="2.3 生产者和消费者"></a>2.3 生产者和消费者</h3><p><img src="/2022/03/10/RenderBlock/e76602c2c7b34d7ba98b8cdf8719445a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="图片"></p>
<p>我们再回到 Vsync 的话题，消费 Vsync 的双方分别是 App 和 sf，<strong>其中 App 代表的是生产者，sf 代表的是消费者，两者交付的中间产物则是 surface buffer</strong>。</p>
<p><strong>再具体一点，生产者大致可以分为两类，一类是以 window 为代表的页面，也就是我们平时所看到的 view 树这一套；另一类是以视频流为代表的可以直接和 surface 完成数据交换的来源，比如相机预览等。</strong></p>
<p>对于一般的生产者和消费者模式，我们知道会存在<strong>相互阻塞</strong>的问题。比如生产者速度快但是消费者速度慢，亦或是生产者速度慢消费者速度快，都会导致整体速度慢且造成资源浪费。所以 Vsync 的协同以及双缓冲甚至三缓冲的作用就体现出来了。</p>
<blockquote>
<p>思考一个问题：是否缓冲的个数越多越好？过多的缓冲会造成什么问题？</p>
<p> 答案是会造成另一个严重的问题：lag，响应延迟</p>
</blockquote>
<p>这里结合 view 的一生，我们可以把两个流程合在一起，让我们的视角再高一层：</p>
<p><img src="/2022/03/10/RenderBlock/52a7e6f5fd734b1db159b76a0b21d3ba~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="图片"></p>
<p>我们一般都比较了解 view 渲染的三大流程，但是 view 的渲染远不止于此：</p>
<blockquote>
<p>此处以一个通用的硬件加速流程来表征</p>
</blockquote>
<p><img src="/2022/03/10/RenderBlock/039f2506191a4c738fba6fb40545123e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="图片"></p>
<ol>
<li><strong>Vsync 调度</strong>：很多同学的一个认知误区在于认为 vsync 是每 16ms 都会有的，但是其实 vsync 是需要调度的，没有调度就不会有回调；</li>
<li><strong>消息调度</strong>：主要是 doframe 的消息调度，如果消息被阻塞，会直接造成卡顿；</li>
<li><strong>input 处理</strong>：触摸事件的处理；</li>
<li><strong>动画处理</strong>：animator 动画执行和渲染；</li>
<li><strong>view 处理</strong>：主要是 view 相关的遍历和三大流程；</li>
<li><strong>measure、layout、draw</strong>：view 三大流程的执行；</li>
<li><strong>DisplayList 更新</strong>：view 硬件加速后的 draw op；</li>
<li><strong>OpenGL 指令转换</strong>：绘制指令转换为 OpenGL 指令；</li>
<li><strong>指令 buffer 交换</strong>：OpenGL 的指令交换到 GPU 内部执行；</li>
<li><strong>GPU 处理</strong>：GPU 对数据的处理过程；</li>
<li><strong>layer 合成</strong>：surface buffer 合成屏幕显示 buffer 的流程；</li>
<li><strong>光栅化</strong>：将矢量图转换为位图；</li>
<li><strong>Display</strong>：显示控制；</li>
<li><strong>buffer 切换</strong>：切换屏幕显示的帧 buffer；</li>
</ol></div><a class="article-more button is-small is-size-7" href="/2022/03/10/RenderBlock/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-02-24T09:33:41.000Z" title="2/24/2022, 5:33:41 PM">2022-02-24</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-06-06T03:26:17.576Z" title="6/6/2024, 11:26:17 AM">2024-06-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a><span> / </span><a class="link-muted" href="/categories/Android/AAC/">AAC</a></span><span class="level-item">31 minutes read (About 4645 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/02/24/LiveData/">LiveData</a></h1><div class="content"><p>简述：</p>
<p><strong>数据实时更新、安全更新：当liveData的setValue被调用时，会遍历自身所有observer并considerNotify，此时会判断observer的活跃状态（shouldBeActive）和内部版本，决定是否向其发送通知。</strong></p>
<p><strong>避免内存泄漏：传入lifeCycleOwner即走observe()的LiveData会在lifeCycleOwner回调onStateChanged为DESTROYED的时候移除掉observer防止内存泄露，而相对的observeForever则由于没有owner而无此特性。</strong></p>
<p><strong>解决Configuration Change问题、粘性数据：一般而言observer是在onCreate中调用的，liveData.observer方法在调用时也会立即被推送liveData中最后一次数据。（会导致所谓的数据倒灌）。Configuration Change时会ViewModel会从当前Activity或fragmentManager的viewModelStore的缓存中重新取出，而ViewModel中的liveData自然也会保留。</strong></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/593472898">https://zhuanlan.zhihu.com/p/593472898</a></p>
<h2 id="Featrue"><a href="#Featrue" class="headerlink" title="Featrue"></a>Featrue</h2><ul>
<li><p><strong>UI和实时数据保持一致</strong> 因为LiveData采用的是观察者模式，这样一来就可以在数据发生改变时获得通知，更新UI。</p>
</li>
<li><p><strong>避免内存泄漏</strong> 观察者被绑定到组件的生命周期上，当被绑定的组件销毁（destroy）时，观察者会立刻自动清理自身的数据。</p>
</li>
<li><p><strong>不会再产生由于Activity处于stop状态而引起的崩溃</strong>，例如：当Activity处于后台状态时，是不会收到LiveData的任何事件的。</p>
</li>
<li><p><strong>不需要再解决生命周期带来的问题</strong> LiveData可以感知被绑定的组件的生命周期，只有在活跃状态才会通知数据变化。</p>
</li>
<li><p><strong>实时数据刷新</strong> 当组件处于活跃状态或者从不活跃状态到活跃状态时总是能收到最新的数据。</p>
</li>
<li><p><strong>解决Configuration Change问题</strong> 在屏幕发生旋转或者被回收再次启动，立刻就能收到最新的数据。</p></li></ul></div><a class="article-more button is-small is-size-7" href="/2022/02/24/LiveData/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-02-16T09:12:36.000Z" title="2/16/2022, 5:12:36 PM">2022-02-16</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.380Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">5 minutes read (About 679 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/02/16/Mmap/">Mmap</a></h1><div class="content"><h1 id="Binder-内存拷贝的本质和变迁"><a href="#Binder-内存拷贝的本质和变迁" class="headerlink" title="Binder | 内存拷贝的本质和变迁"></a>Binder | 内存拷贝的本质和变迁</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/user/149189312913511/posts">芦半山</a></p>
<h3 id="虚拟地址和数据的关系"><a href="#虚拟地址和数据的关系" class="headerlink" title="虚拟地址和数据的关系"></a>虚拟地址和数据的关系</h3><p>所有的数据都存储在物理内存中，而进程访问内存只能通过虚拟地址。因此，若是想成功访问必须得有个前提：</p>
<blockquote>
<p>虚拟地址和物理内存之间建立映射关系</p>
</blockquote>
<p>若是这层映射关系不建立，则访问会出错。信号11(SIGSEGV)的MAPERR就是专门用来描述这种错误的。</p>
<p>虚拟地址和物理地址间建立映射关系通过mmap完成。这里我们不考虑file-back的mapping，只考虑anonymous mapping。当mmap被调用(flag=MAP_ANONYMOUS)时，实际上会做以下两件事：</p>
<ol>
<li>分配一块连续的虚拟地址空间。</li>
<li>更新这些虚拟地址对应的PTE(Page Table Entry)。</li>
</ol>
<p>mmap做完这两件事后，就会返回连续虚拟地址空间的起始地址。在mmap调用结束后，其实并不会立即分配物理页。如果此时不分配物理页，那么就会有如下两个问题：</p>
<ol>
<li>没有新的物理页分配，那么PTE都更新了哪些内容？</li>
<li>如果后续使用mmap返回的虚拟地址访问内存，会有什么情况产生呢？</li>
</ol>
<h4 id="1-1-1-没有新的物理页分配，那么PTE都更新了些什么内容呢？"><a href="#1-1-1-没有新的物理页分配，那么PTE都更新了些什么内容呢？" class="headerlink" title="1.1.1 没有新的物理页分配，那么PTE都更新了些什么内容呢？"></a>1.1.1 没有新的物理页分配，那么PTE都更新了些什么内容呢？</h4><p>PTE也即页表的条目，它的内容反映了一个虚拟地址到物理地址之间的映射关系。如果没有新的物理页分配，那这些新的虚拟地址都和哪些物理地址之间建立了映射关系呢？答案是所有的虚拟地址都和同一个zero page（页内容全为0）建立了映射关系。</p>
<h4 id="1-1-2-如果后续使用mmap返回的虚拟地址访问内存，会有什么情况产生呢？"><a href="#1-1-2-如果后续使用mmap返回的虚拟地址访问内存，会有什么情况产生呢？" class="headerlink" title="1.1.2 如果后续使用mmap返回的虚拟地址访问内存，会有什么情况产生呢？"></a>1.1.2 如果后续使用mmap返回的虚拟地址访问内存，会有什么情况产生呢？</h4><p>拿到mmap返回的虚拟地址后，并不会有新的物理页分配。此时若是直接读取虚拟地址中的值，则会通过PTE追踪到刚刚建立映射关系的zero page，因此读取出来的值都是0。</p>
<p>如果此时往虚拟地址中写入数据，将会在page fault handler中触发一个正常的copy-on-write机制。需要写多少页，就会新分配多少物理页。所以我们可以看到，真实的物理页是符合lazy(on-demand) allocation原则的。这一点，极大地保证了物理资源的合理分配和使用。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">Previous</a></div><div class="pagination-next"><a href="/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatarPng.png" alt="White Crow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">White Crow</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">79</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">4</p></a></div></div></nav></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a><p class="is-size-7"><span>&copy; 2024 white crow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://github.com/WhileCrow"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>