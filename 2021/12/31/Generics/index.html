<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Generics - Crow&#039;s Sky</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Crow&#039;s Sky"><meta name="msapplication-TileImage" content="/img/avatarCircle.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Crow&#039;s Sky"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Java泛型简述： 理解的泛型，其实是这样的：假如没有泛型，出现在泛型类型位置的就会是Object类，而程序员在使用该类型的时候再手动将类型强转一下，不仅代码啰嗦、而且有类型不匹配的crash可能。 而java1.5提供泛型同时为了兼容旧版，本质上也是用了Object，只不过编译器将.java编译成.class时进行“泛型擦除”时会把泛型类型替代成Object或上限类型（字节码中就不存在泛型了），"><meta property="og:type" content="blog"><meta property="og:title" content="Generics"><meta property="og:url" content="http://example.com/2021/12/31/Generics/"><meta property="og:site_name" content="Crow&#039;s Sky"><meta property="og:description" content="Java泛型简述： 理解的泛型，其实是这样的：假如没有泛型，出现在泛型类型位置的就会是Object类，而程序员在使用该类型的时候再手动将类型强转一下，不仅代码啰嗦、而且有类型不匹配的crash可能。 而java1.5提供泛型同时为了兼容旧版，本质上也是用了Object，只不过编译器将.java编译成.class时进行“泛型擦除”时会把泛型类型替代成Object或上限类型（字节码中就不存在泛型了），"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/2021/12/31/Generics/Generics//image-20240428144654122.png"><meta property="article:published_time" content="2021-12-31T03:51:04.000Z"><meta property="article:modified_time" content="2024-05-06T08:42:39.750Z"><meta property="article:author" content="White Crow"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="Generics//image-20240428144654122.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/12/31/Generics/"},"headline":"Generics","image":["http://example.com/2021/12/31/Generics/Generics//image-20240428144654122.png"],"datePublished":"2021-12-31T03:51:04.000Z","dateModified":"2024-05-06T08:42:39.750Z","author":{"@type":"Person","name":"white crow"},"publisher":{"@type":"Organization","name":"Crow's Sky","logo":{"@type":"ImageObject","url":"http://example.com/img/avatarCircle.png"}},"description":"Java泛型简述： 理解的泛型，其实是这样的：假如没有泛型，出现在泛型类型位置的就会是Object类，而程序员在使用该类型的时候再手动将类型强转一下，不仅代码啰嗦、而且有类型不匹配的crash可能。 而java1.5提供泛型同时为了兼容旧版，本质上也是用了Object，只不过编译器将.java编译成.class时进行“泛型擦除”时会把泛型类型替代成Object或上限类型（字节码中就不存在泛型了），"}</script><link rel="canonical" href="http://example.com/2021/12/31/Generics/"><link rel="icon" href="/img/avatarCircle.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/WhileCrow"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-10-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-12-31T03:51:04.000Z" title="12/31/2021, 11:51:04 AM">2021-12-31</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-05-06T08:42:39.750Z" title="5/6/2024, 4:42:39 PM">2024-05-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">23 minutes read (About 3436 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">Generics</h1><div class="content"><h1 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h1><p>简述：</p>
<p>理解的泛型，其实是这样的：假如没有泛型，出现在泛型类型位置的就会是Object类，而程序员在使用该类型的时候再手动将类型强转一下，不仅代码啰嗦、而且有类型不匹配的crash可能。</p>
<p>而java1.5提供泛型同时为了兼容旧版，本质上也是用了Object，只不过<strong>编译器将.java编译成.class时</strong>进行“泛型擦除”时会把泛型类型替代成<strong>Object</strong>或<strong>上限类型</strong>（字节码中就不存在泛型了），再自动地使用处前加上原始类型的强转，之后再加载到JVM中。而在编译期存在的泛型可以借由IDE有效的进行<strong>类型检测</strong>和<strong>可读的扩展</strong>，防止类型不匹配。</p>
<p>//<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28665443/answer/118148143">java伪泛型的设计原因主要为了兼容老版本的java。真泛型并非做不到，而是因为如果用真泛型（即类型保留），老程序都需要修改。</a></p>
<p>//另外泛型类中基础数据类型需要使用Integer、Long等封装类的原因也是因为“擦除后会把泛型类型替代成<strong>Object</strong>或<strong>上限类型</strong>”</p>
<p>而kotlin的泛型是跟java一样的，在编译时会被擦除。但是kotlin提供了新的特性可以保留类型，就是**内联函数+reified(ˈriːɪfʌɪ/)**，泛型实化，可以说是真泛型：内联函数(inline)会把方法体copy到调用处（即不会创建新的虚拟机栈帧），</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> C : Activity&gt;</span> Context.<span class="title">startActivityKtx</span><span class="params">()</span></span> &#123;</span><br><span class="line">    startActivity(Intent(<span class="keyword">this</span>, C::<span class="keyword">class</span>.java))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>协变：①<strong>协变</strong>：<strong>父子关系一致</strong>→<strong>子类也可以作为参数传进来</strong>→java<code>&lt;? extends Entity&gt;</code>→<strong>上界通配符</strong>→kotlin<code>&lt;out Entity&gt;</code></p>
<p>逆变：②<strong>逆变</strong>：<strong>父子关系颠倒</strong>→<strong>父类也可以作为参数传进来</strong>→java<code>&lt;? super Article&gt;</code>→<strong>下界通配符</strong>→kotlin<code>&lt;in Entiry&gt;</code></p>
<p>不变：③不变：只能</p>
<p>无限通配符<code>&lt;?&gt;</code> == java <code>&lt;? extend Object&gt;</code> == kotlin<code>&lt;*&gt;</code> == kotlin<code>&lt;out Any&gt;</code></p>
<span id="more"></span>

<p>不变比如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 支持添加和删除元素的通用有序元素集合。</span></span><br><span class="line"><span class="comment"> * 参数：</span></span><br><span class="line"><span class="comment"> * E - 列表中包含的元素的类型。可变列表的元素类型是不变的。 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MutableList</span>&lt;<span class="type">E</span>&gt; : <span class="type">List</span>&lt;<span class="type">E</span>&gt;, <span class="type">MutableCollection</span>&lt;<span class="type">E</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>协变比如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用的有序元素集合。该接口中的方法仅支持对列表的只读访问；通过MutableList接口支持读/写访问。</span></span><br><span class="line"><span class="comment"> * 参数：</span></span><br><span class="line"><span class="comment"> * E - 列表中包含的元素的类型。该列表的元素类型是协变的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="type">out E</span>&gt; : <span class="type">Iterable</span>&lt;<span class="type">E</span>&gt; </span></span><br></pre></td></tr></table></figure>















<p>与普通的 Object 代替一切类型这样简单粗暴而言，</p>
<p>简述：泛型提供了可以使类型像参数一样由外部传递进来的扩展能力，同时还提供了编译时的类型检测机制，即当传入数据类型为泛型 时才能编译通过，提高了可读性。</p>
<blockquote>
<p>但出于规范的目的，Java 还是建议我们用单个大写字母来代表类型参数。常见的如：</p>
<p>T 代表一般的任何类。<br>E 代表 Element 的意思，或者 Exception 异常的意思。<br>K 代表 Key 的意思。<br>V 代表 Value 的意思，通常与 K 一起配合使用。<br>S 代表 Subtype 的意思，文章后面部分会讲解示意。</p>
</blockquote>
<p>泛型可以为类和方法分别定义泛型参数，</p>
<p>泛型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尖括号 &lt;&gt;中的 T 被称作是类型参数，用于指代任何类型。事实上，T 只是一种习惯性写法，如果你愿意。你可以这样写。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	T field1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>泛型方法始终以自己定义的类型参数为准</strong>。</p>
<p><strong>通配符的出现是为了指定泛型中的类型范围</strong>。</p>
<p>通配符有 3 种形式。</p>
<ol>
<li><code>&lt;?&gt;</code>被称作无限定的通配符。</li>
<li><code>&lt;? extends T&gt;</code>被称作有上限的通配符。</li>
<li><code>&lt;? super T&gt;</code>被称作有下限的通配符。</li>
</ol>
<p><strong>泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除</strong></p>
<p>在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 <code>&lt;T&gt;</code>则会被转译成普通的 Object 类型，如果指定了上限如 <code>&lt;T extends String&gt;</code>则类型参数就被替换成类型上限。</p>
<h2 id="Java获取泛型的class方法："><a href="#Java获取泛型的class方法：" class="headerlink" title="Java获取泛型的class方法："></a>Java获取泛型的class方法：</h2><h3 id="一：在构造类时传递泛型类型参数"><a href="#一：在构造类时传递泛型类型参数" class="headerlink" title="一：在构造类时传递泛型类型参数"></a>一：在构造类时传递泛型类型参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClass&lt;String&gt; myObj = <span class="keyword">new</span> MyClass&lt;&gt;(String.class);</span><br><span class="line">        myObj.printType(); <span class="comment">// Output: Type: java.lang.String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="二：反射获取"><a href="#二：反射获取" class="headerlink" title="二：反射获取"></a>二：反射获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Type superclass = getClass().getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (superclass <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            Type[] typeArguments = ((ParameterizedType) superclass).getActualTypeArguments();</span><br><span class="line">						typeArguments[<span class="number">0</span>]<span class="comment">//泛型类型可能多个</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>匿名内部类在初始化的时候就会绑定父类或者父接口的信息，这样就能通过获取父类或父接口的泛型类型信息，来实现我们的需求</strong></p>
<p>如Gson中的<strong>TypeToken或FastJson中的TypeReference</strong>，使用创建继承于特定抽象类的匿名内部类对象获得<img src="Generics//image-20240428144654122.png" alt="image-20240428144654122"></p>
<h1 id="kotlin-泛型"><a href="#kotlin-泛型" class="headerlink" title="kotlin 泛型"></a>kotlin 泛型</h1><p>Kotlin 泛型系统继承于 Java泛型，依然是一种语法糖的伪泛型，会在编译时发生类型擦除。但可以通过inline+reified实现泛型实化的真泛型</p>
<h2 id="Inline-reified-泛型实化的原理："><a href="#Inline-reified-泛型实化的原理：" class="headerlink" title="Inline+reified 泛型实化的原理："></a>Inline+reified 泛型实化的原理：</h2><p>我们都知道内联函数的原理，编译器把实现内联函数的字节码动态插入到每次的调用点。那么实化的原理正是基于这个机制，<strong>每次调用带实化类型参数的函数时，编译器都知道此次调用中作为泛型类型实参的具体类型。所以编译器只要在每次调用时生成对应不同类型实参调用的字节码插入到调用点即可。</strong> 总之一句话很简单，就是带实化参数的函数每次调用都生成不同类型实参的字节码，动态插入到调用点。由于生成的字节码的类型实参引用了具体的类型，而不是类型参数所以不会存在擦除问题。</p>
<p>简述：<strong>由于inline的存在，泛型类型实参的调用处在同一个方法体内，相当于直接知道了类型，所以只要编译时直接生成对应的不同类型实参即可</strong></p>
<h3 id="实化类型参数函数的使用限制"><a href="#实化类型参数函数的使用限制" class="headerlink" title="实化类型参数函数的使用限制"></a>实化类型参数函数的使用限制</h3><p>这里说的使用限制主要有两点:</p>
<h4 id="1、Java调用Kotlin中的实化类型参数函数限制"><a href="#1、Java调用Kotlin中的实化类型参数函数限制" class="headerlink" title="1、Java调用Kotlin中的实化类型参数函数限制"></a>1、Java调用Kotlin中的实化类型参数函数限制</h4><p>明确回答Kotlin中的实化类型参数函数不能在Java中的调用，我们可以简单的分析下，首先Kotlin的实化类型参数函数主要得益于inline函数的内联功能，但是Java可以调用普通的内联函数但是失去了内联功能，失去内联功能也就意味实化操作也就化为泡影。故重申一次<strong>Kotlin中的实化类型参数函数不能在Java中的调用</strong></p>
<h4 id="2、Kotlin实化类型参数函数的使用限制"><a href="#2、Kotlin实化类型参数函数的使用限制" class="headerlink" title="2、Kotlin实化类型参数函数的使用限制"></a>2、Kotlin实化类型参数函数的使用限制</h4><ul>
<li>不能使用非实化类型形参作为类型实参调用带实化类型参数的函数</li>
<li>不能使用实化类型参数创建该类型参数的实例对象</li>
<li>不能调用实化类型参数的伴生对象方法</li>
<li>reified关键字只能标记实化类型参数的内联函数，不能作用与类和属性。</li>
</ul>
<h2 id="泛型类型获取方式"><a href="#泛型类型获取方式" class="headerlink" title="泛型类型获取方式"></a>泛型类型获取方式</h2><p>在Kotlin中可以通过下述方法获取泛型的类型</p>
<h3 id="通过匿名内部类获得泛型参数类型"><a href="#通过匿名内部类获得泛型参数类型" class="headerlink" title="通过匿名内部类获得泛型参数类型"></a><strong>通过匿名内部类获得泛型参数类型</strong></h3><p>具体示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Java </span><br><span class="line">ArrayList arrayList &#x3D; new ArrayList&lt;String&gt;()&#123;&#125;;</span><br><span class="line">System.out.println(arrayList.getClass().getGenericSuperclass());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Kotlin</span><br><span class="line">val clazz &#x3D; object :ArrayList&lt;String&gt;()&#123;&#125;&#x2F;&#x2F; Kotlin 的匿名内部类</span><br><span class="line">println(clazz.javaClass.genericSuperclass)</span><br></pre></td></tr></table></figure>

<p>为什么可以通过匿名内部类可以在运行期获得泛型参数的类型呢？这是因为 <strong>泛型的类型擦除并不是完全的将所有信息擦除</strong>，而会 <strong>将类型信息放在所属 class 的常量池中</strong>，这样我们就可以通过相应的方式获得类型信息，而匿名内部类就可以实现这个功能。</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/937933/where-are-generic-types-stored-in-java-class-files/937999#937999">Java 将泛型信息存储在何处</a>：类信息的签名中。</p>
<p><strong>匿名内部类在初始化的时候就会绑定父类或者父接口的信息，这样就能通过获取父类或父接口的泛型类型信息，来实现我们的需求</strong>，可以通过利用此来设计一个获得所有类型信息的泛型类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">open class GenericsToken&lt;T&gt;&#123;</span><br><span class="line">    var type : Type &#x3D; Any::class.java</span><br><span class="line">    init &#123;</span><br><span class="line">        val superClass &#x3D; this.javaClass.genericSuperclass</span><br><span class="line">        type &#x3D; (superClass as ParameterizedType).actualTypeArguments[0]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建一个匿名内部类</span><br><span class="line">    val oneKt &#x3D; object:GenericsToken&lt;Map&lt;String,String&gt;&gt;()&#123;&#125;</span><br><span class="line">    println(oneKt.type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.Map&lt;java.lang.String, ? extends java.lang.String&gt;</span><br></pre></td></tr></table></figure>

<p>至于如果获得参数化类型，可参见此博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/datouniao1/article/details/53788018">ParameterizedType应用，java反射，获取参数化类型的class实例</a></p>
<p>其实正是因为类型擦除的原因，在使用 Gson 反序列化对象的时候除了制定泛型参数，还需要传入一个 class ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T fromJson(String json, Class&lt;T&gt; classOfT) throws JsonSyntaxException &#123; </span><br><span class="line">   ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 Gson 没有办法根据 T 直接去反序列化，所以 Gson 也是使用了相同的设计，通过匿名内部类获得相应的类型参数，然后传到 fromJson 中进行反序列化。</p>
<p>看一下在 Kotlin 中我们使用 Gson 来进行泛型类的反序列化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val  json &#x3D; &quot;....&quot;</span><br><span class="line">val rType &#x3D; object: TypeToken&lt;List&lt;String&gt;&gt;()&#123;&#125;.type&#x2F;&#x2F; 获得反序列化的数据类型</span><br><span class="line">val stringList &#x3D; Gson().fromJson&lt;List&lt;String&gt;&gt;(json,rType)</span><br></pre></td></tr></table></figure>

<p>当然可以直接传输数据类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 存在局限，比如不能传入 List&lt;String&gt; 的数据类型</span><br><span class="line">val stringList &#x3D; Gson().fromJson&lt;String::class.java&gt;(json,rType)</span><br></pre></td></tr></table></figure>

<p>在 Kotlin 中除了使用匿名内部类获得泛型参数外，还可以使用内联函数来获取。</p>
<h3 id="使用内联函数获取泛型的参数类型"><a href="#使用内联函数获取泛型的参数类型" class="headerlink" title="使用内联函数获取泛型的参数类型"></a><strong>使用内联函数获取泛型的参数类型</strong></h3><p>内联函数的特征：</p>
<p>内联函数(<code>inline</code>)在编译时会将具体的函数字节码插入调用的地方，类型插入相应的字节码中，这就意味着泛型参数类型也会被插入到字节码中，那么就可以实现在运行时就可以获得对应的参数类型了。</p>
<p>使用内联函数获取泛型的参数类型十分的简单，只要加上 <strong><code>reified</code></strong> 关键字，意思是：在编译时会将 <strong>具体的类型</strong> 插入到相应的字节码中，那么就可以获得对应参数的类型，与 Java 中的泛型在编译器进行类型擦除不同，Kotlin 中使用 <strong>reified</strong> 修饰泛型，<strong>该泛型类型信息不会被抹去</strong>，所以 Kotiln 中的该泛型为 <strong>真泛型</strong>。</p>
<blockquote>
<p><strong>reified</strong> 为 Kotlin 中的一个关键字，还有一个叫做 <strong>inline</strong>，后者可以将函数定义为内联函数，前者可以将内联函数的泛型参数当做真实类型使用.</p>
</blockquote>
<p>可以借此来为 Gson 定义一个扩展函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline fun &lt;reified T</span><br><span class="line">: Any&gt; Gson.fromJson(json: String): T&#123; </span><br><span class="line">     return fromJson(json, T::class.java) </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>有了此扩展方法，就无须在 Kotlin 当中显式的传入一个 class 对象就可以直接反序列化 json 了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Person(var id: Int, var name: String) </span><br><span class="line">　 </span><br><span class="line">fun test()&#123; </span><br><span class="line">    val person: Person &#x3D; Gson().fromJson&lt;User&gt;(&quot;&quot;&quot;&#123;&quot;id&quot;: 0, &quot;name&quot;: &quot;Jack&quot; &#125;&quot;&quot;&quot;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>Gson.fromJson</code> 是内联函数，方法调用时插入调用位置，T 的类型在编译时就可以确定了，反编译之后的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static final void test() &#123; </span><br><span class="line">  Gson $receiver$iv &#x3D; new Gson(); </span><br><span class="line">  String json$iv &#x3D; &quot;&#123;\&quot;id\&quot;: 0, \&quot;name\&quot;: \&quot;Jack\&quot; &#125;&quot;; </span><br><span class="line">  Person person &#x3D; (Person)$receiver$iv.fromJson(json$iv, Person.class); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是 Kotin 的泛型被称为 <strong>真泛型</strong> 的原因。</p>
<p>但是 refied 存在一个问题：<code>reified</code> 只能修饰方法，而当定义一个泛型类时，reified 是无法通过类似以上的方式获得泛型参数的，但是仍然可以通过其他方式获得泛型类中的泛型参数类型，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class View&lt;T&gt;(val clazz:Class&lt;T&gt;)&#123;</span><br><span class="line">    val presenter by lazy &#123; clazz.newInstance() &#125;</span><br><span class="line">    companion object&#123;</span><br><span class="line">        &#x2F;&#x2F; 在构造函数执行之前，执行了此处，真泛型的重载函数。</span><br><span class="line">        inline operator fun &lt;reified T&gt; invoke() &#x3D; View(T::class.java)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Presenter</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    &#x2F;&#x2F; 两者等效，具体实现如下</span><br><span class="line">    val p &#x3D; View&lt;Presenter&gt;().presenter</span><br><span class="line">    val a  &#x3D; View.Companion.invoke&lt;Presenter&gt;().presenter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法特别适合在 android 中的 MVP，不用再在 Activity 中显式的显示 Presenter 的类名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//接受多个类型参数。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiType</span> &lt;<span class="title">E</span>,<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	E value1;</span><br><span class="line">	T value2;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">getValue1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getValue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型类与泛型方法的共存</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">		System.out.println(t.getClass().getName());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span>  &lt;T&gt; <span class="function">T <span class="title">testMethod1</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述泛型类与泛型方法共存的testMethod1实际上其类型参数是自己在函数申明的pulic &lt;T&gt; 中，与 整个类的T没关系，</span></span><br><span class="line"><span class="comment">//为了避免混淆，如果在一个泛型类中存在泛型方法，那么两者的类型参数最好不要同名。应该像下面这样写。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">		System.out.println(t.getClass().getName());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span>  &lt;E&gt; <span class="function">E <span class="title">testMethod1</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> e;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="article-licensing box"><div class="licensing-title"><p>Generics</p><p><a href="http://example.com/2021/12/31/Generics/">http://example.com/2021/12/31/Generics/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>white crow</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2021-12-31</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-05-06</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/01/06/DNS/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">DNS</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/12/13/VirtualMemory/"><span class="level-item">VirtualMemory</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Java泛型"><span class="level-left"><span class="level-item">1</span><span class="level-item">Java泛型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Java获取泛型的class方法："><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Java获取泛型的class方法：</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#一：在构造类时传递泛型类型参数"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">一：在构造类时传递泛型类型参数</span></span></a></li><li><a class="level is-mobile" href="#二：反射获取"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">二：反射获取</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#kotlin-泛型"><span class="level-left"><span class="level-item">2</span><span class="level-item">kotlin 泛型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Inline-reified-泛型实化的原理："><span class="level-left"><span class="level-item">2.1</span><span class="level-item">Inline+reified 泛型实化的原理：</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#实化类型参数函数的使用限制"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">实化类型参数函数的使用限制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、Java调用Kotlin中的实化类型参数函数限制"><span class="level-left"><span class="level-item">2.1.1.1</span><span class="level-item">1、Java调用Kotlin中的实化类型参数函数限制</span></span></a></li><li><a class="level is-mobile" href="#2、Kotlin实化类型参数函数的使用限制"><span class="level-left"><span class="level-item">2.1.1.2</span><span class="level-item">2、Kotlin实化类型参数函数的使用限制</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#泛型类型获取方式"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">泛型类型获取方式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#通过匿名内部类获得泛型参数类型"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">通过匿名内部类获得泛型参数类型</span></span></a></li><li><a class="level is-mobile" href="#使用内联函数获取泛型的参数类型"><span class="level-left"><span class="level-item">2.2.2</span><span class="level-item">使用内联函数获取泛型的参数类型</span></span></a></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatarPng.png" alt="White Crow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">White Crow</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">80</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">4</p></a></div></div></nav></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a><p class="is-size-7"><span>&copy; 2025 white crow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://github.com/WhileCrow"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>