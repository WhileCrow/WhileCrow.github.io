<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>fresco - Crow&#039;s Sky</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Crow&#039;s Sky"><meta name="msapplication-TileImage" content="/img/avatarCircle.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Crow&#039;s Sky"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Fresco（2.5.0）以MVC的 Fresco架构入手，层层递进分析fresco的整体思路。"><meta property="og:type" content="blog"><meta property="og:title" content="fresco"><meta property="og:url" content="http://example.com/2021/04/09/Fresco/"><meta property="og:site_name" content="Crow&#039;s Sky"><meta property="og:description" content="Fresco（2.5.0）以MVC的 Fresco架构入手，层层递进分析fresco的整体思路。"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/2021/04/09/Fresco/169321f499462590~tplv-t2oaga2asx-watermark.awebp"><meta property="og:image" content="http://example.com/2021/04/09/Fresco/Fresco%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84.png"><meta property="og:image" content="http://example.com/2021/04/09/Fresco/DraweeHolder%E5%AF%B9%E4%BA%8EUI%E5%B1%82%E7%9A%84%E7%B2%98%E5%90%88.png"><meta property="og:image" content="http://example.com/2021/04/09/Fresco/16974f610f81b570~tplv-t2oaga2asx-watermark-20210930154120059.awebp"><meta property="og:image" content="http://example.com/2021/04/09/Fresco/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%B9%8B%E5%89%8D%E7%9A%84%E9%80%BB%E8%BE%91-20211013112634806.png"><meta property="og:image" content="http://example.com/2021/04/09/Fresco/169492b769e12c8d~tplv-t2oaga2asx-watermark.awebp"><meta property="og:image" content="http://example.com/2021/04/09/Fresco/169492b769eccce9~tplv-t2oaga2asx-watermark-20210930151741056.awebp"><meta property="article:published_time" content="2021-04-09T06:09:45.000Z"><meta property="article:modified_time" content="2024-04-24T09:35:45.498Z"><meta property="article:author" content="White Crow"><meta property="article:tag" content="CoreProcess"><meta property="article:tag" content="Core"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2021/04/09/Fresco/169321f499462590~tplv-t2oaga2asx-watermark.awebp"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/04/09/Fresco/"},"headline":"fresco","image":["http://example.com/2021/04/09/Fresco/Fresco%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84.png","http://example.com/2021/04/09/Fresco/DraweeHolder%E5%AF%B9%E4%BA%8EUI%E5%B1%82%E7%9A%84%E7%B2%98%E5%90%88.png","http://example.com/2021/04/09/Fresco/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%B9%8B%E5%89%8D%E7%9A%84%E9%80%BB%E8%BE%91-20211013112634806.png"],"datePublished":"2021-04-09T06:09:45.000Z","dateModified":"2024-04-24T09:35:45.498Z","author":{"@type":"Person","name":"white crow"},"publisher":{"@type":"Organization","name":"Crow's Sky","logo":{"@type":"ImageObject","url":"http://example.com/img/avatarCircle.png"}},"description":"Fresco（2.5.0）以MVC的 Fresco架构入手，层层递进分析fresco的整体思路。"}</script><link rel="canonical" href="http://example.com/2021/04/09/Fresco/"><link rel="icon" href="/img/avatarCircle.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/WhileCrow"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-10-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-04-09T06:09:45.000Z" title="4/9/2021, 2:09:45 PM">2021-04-09</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-04-24T09:35:45.498Z" title="4/24/2024, 5:35:45 PM">2024-04-24</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a><span> / </span><a class="link-muted" href="/categories/Android/ThirdPartyLib/">ThirdPartyLib</a></span><span class="level-item">an hour read (About 7816 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">fresco</h1><div class="content"><h1 id="Fresco（2-5-0）"><a href="#Fresco（2-5-0）" class="headerlink" title="Fresco（2.5.0）"></a>Fresco（2.5.0）</h1><p>以MVC的 Fresco架构入手，层层递进分析fresco的整体思路。</p>
<p><img src="/2021/04/09/Fresco/169321f499462590~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<span id="more"></span>



<p> 个人理解会将 图中的UI层进一步分为 DraweeView为View层（负责渲染），DraweeHierarchy为Model层（记录配置与数据Drawable[6]），DraweeController为Controller层（分离PorducerSequence加载缓存责任链条）</p>
<p>ps：MVC现在很多变种中都会有View层与Model层 交互，View层与Controller层 交互。但一般都不会有Model持有Controller。所以我会将fresco理解为MVC。</p>
<p><img src="/2021/04/09/Fresco/Fresco%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84.png" alt="img"><img src="/2021/04/09/Fresco/DraweeHolder%E5%AF%B9%E4%BA%8EUI%E5%B1%82%E7%9A%84%E7%B2%98%E5%90%88.png" alt="img"></p>
<h2 id="View—DraweeView"><a href="#View—DraweeView" class="headerlink" title="View—DraweeView"></a>View—DraweeView</h2><p>也就是我们直接接触到的具体实现类 <code>SimpleDraweeView</code> 。早期是继承imageView类的，后来是改成view并由draweeView自己渲染图层</p>
<p>继承于 <a target="_blank" rel="noopener" href="http://developer.android.com/reference/android/view/View.html">View</a>, 负责图片的显示。持有DraweeHolder<DH extends draweehierarchy> （DraweeHolder中含有<DH>的model层 和 DraweeController 的controller层）。//见上图</DH></DH></p>
<p>SimpleDraweeView中，setImageUrl方法中直接调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbstractDraweeControllerBuilder.build()</span><br></pre></td></tr></table></figure>

<p>以构造Controller。</p>
<p>至于AbstractDraweeControllerBuilder唯一继承类，是PipelineDraweeControllerBuilder。</p>
<p>PipelineDraweeControllerBuilder中obtainController是借助PipelineDraweeControllerFactory完成的</p>
<p>具体看下面的Controler—DraweeController解析</p>
<h2 id="Model—DraweeHierarchy"><a href="#Model—DraweeHierarchy" class="headerlink" title="Model—DraweeHierarchy"></a>Model—DraweeHierarchy</h2><p>直接用到的是<strong>GenericDraweeHierarchy</strong>，这一层保存和管理图片的六个图层（layers），如果有overlay的话再加一层</p>
<h3 id="Fresco-图片渲染-——-六层drawable"><a href="#Fresco-图片渲染-——-六层drawable" class="headerlink" title="Fresco 图片渲染 —— 六层drawable"></a>Fresco 图片渲染 —— 六层drawable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DraweeView</span>&lt;<span class="title">DH</span> <span class="keyword">extends</span> <span class="title">DraweeHierarchy</span>&gt; <span class="keyword">extends</span> <span class="title">ImageView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setController</span><span class="params">(<span class="meta">@Nullable</span> DraweeController draweeController)</span> </span>&#123;</span><br><span class="line">        mDraweeHolder.setController(draweeController);</span><br><span class="line">        <span class="keyword">super</span>.setImageDrawable(mDraweeHolder.getTopLevelDrawable()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用<code>SimpleDraweeView.setImageUri()</code>时会调用到<code>DraweeView.setController()</code>,即此时是直接显示的<code>mDraweeHolder.getTopLevelDrawable()</code>:</p>
<blockquote>
<p>DraweeHolder.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Drawable <span class="title">getTopLevelDrawable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mHierarchy == <span class="keyword">null</span> ? <span class="keyword">null</span> : mHierarchy.getTopLevelDrawable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以最终的显示的<code>Drawable</code>是<code>mHierarchy.getTopLevelDrawable()</code>。<code>mHierarchy</code>的实现是<code>GenericDraweeHierarchy</code>。<code>mHierarchy.getTopLevelDrawable()</code>获取的<code>Drawable</code>实际上可以理解为<code>FadeDrawable</code>:</p>
<blockquote>
<p>GenericDraweeHierarchy.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GenericDraweeHierarchy(GenericDraweeHierarchyBuilder builder) &#123;</span><br><span class="line">        mFadeDrawable = <span class="keyword">new</span> FadeDrawable(layers);</span><br><span class="line">        Drawable maybeRoundedDrawable = WrappingUtils.maybeWrapWithRoundedOverlayColor(mFadeDrawable, mRoundingParams);</span><br><span class="line">        mTopLevelDrawable = <span class="keyword">new</span> RootDrawable(maybeRoundedDrawable); <span class="comment">//RootDrawable 只是一个装饰类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FadeDrawable</code>内部维护着一个<code>Drawable</code>数组，它可以由一个<code>Drawable</code>切换到另一个<code>Drawable</code>，<code>Drawable</code>的切换过程中伴有着透明度改变的动画:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FadeDrawable</span> <span class="keyword">extends</span> <span class="title">ArrayDrawable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Drawable[] mLayers;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        ...更新Drawable的透明度</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从前往后一层一层的画出来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mLayers.length; i++) &#123;</span><br><span class="line">            drawDrawableWithAlpha(canvas, mLayers[i], mAlphas[i] * mAlpha / <span class="number">255</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/09/Fresco/16974f610f81b570~tplv-t2oaga2asx-watermark-20210930154120059.awebp" alt="img"></p>
<p>主要有顶级图层，占位符图层，目标显示图层，重新加载图层，显示失败图层， 进度条图层，控制覆盖图层</p>
<p>DraweeHierarchy由<code>DraweeController</code>直接持有的，DraweeController通过DataSource能轻易得到各个图片加载时机，因此对于不同图片显示的切换操作具体是由<code>DraweeController</code>来直接操作的。</p>
<h3 id><a href="#" class="headerlink" title></a></h3><h2 id="Controler—DraweeController"><a href="#Controler—DraweeController" class="headerlink" title="Controler—DraweeController"></a>Controler—DraweeController</h2><p>关键词：依赖注入（控制反转的思想）、责任链、生产者消费者、构建者</p>
<p>fresco中具体实现为PipelineDraweeController，集成关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipelineDraweeController</span> <span class="keyword">extends</span> <span class="title">AbstractDraweeController</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDraweeController</span>&lt;<span class="title">T</span>, <span class="title">INFO</span>&gt; <span class="keyword">implements</span> <span class="title">DraweeController</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDetach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">submitRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DraweeController</span></span></span><br></pre></td></tr></table></figure>

<p>DraweeController与DataSource直接交互，通过DataSource控制ProducterSequence以 责任链模式的思想 加载图片。</p>
<p> 从 <u>bitmap对象</u> 到 <u>未解码图片的内存缓存</u> 到 <u>图片的磁盘缓存</u> 到 <u>网络拉取</u></p>
<p><img src="/2021/04/09/Fresco/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%B9%8B%E5%89%8D%E7%9A%84%E9%80%BB%E8%BE%91-20211013112634806.png" alt="img"></p>
<h3 id="DraweeController的构造"><a href="#DraweeController的构造" class="headerlink" title="DraweeController的构造"></a>DraweeController的构造</h3><p>在<code>Fresco</code>中<code>DraweeController</code>是通过<code>DraweeControllerBuilder</code>来构造的。而<code>DraweeControllerBuilder</code>在<code>Fresco</code>中是以单例的形式存在的。<code>Fresco</code>在初始化时会调用下面的代码:</p>
<blockquote>
<p>Fresco.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initializeDrawee</span><span class="params">(Context context, <span class="meta">@Nullable</span> DraweeConfig draweeConfig)</span> </span>&#123;</span><br><span class="line">    sDraweeControllerBuilderSupplier = <span class="keyword">new</span> PipelineDraweeControllerBuilderSupplier(context, draweeConfig);</span><br><span class="line">    SimpleDraweeView.initialize(sDraweeControllerBuilderSupplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以所有的<code>DraweeController</code>都是通过同一个<code>DraweeControllerBuilder</code>来构造的。<code>Fresco</code>每次图片加载都会对应到一个<code>DraweeController</code>，一个<code>DraweeView</code>的多次图片加载可以复用同一个<code>DraweeController</code>:</p>
<blockquote>
<p>SimpleDraweeView.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageURI</span><span class="params">(Uri uri, <span class="meta">@Nullable</span> Object callerContext)</span> </span>&#123;</span><br><span class="line">    DraweeController controller =</span><br><span class="line">        mControllerBuilder</span><br><span class="line">            .setCallerContext(callerContext)</span><br><span class="line">            .setUri(uri) <span class="comment">//设置新的图片加载路径</span></span><br><span class="line">            .setOldController(getController())  <span class="comment">//复用 controller</span></span><br><span class="line">            .build(); </span><br><span class="line">    setController(controller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所以一般情况下 : **一个<code>DraweeView</code>对应一个<code>DraweeController</code>**。由于DraweeController很重，所以使用obtainController() 回收利用并ControllerBuilder提供setOldController()传入draweeView复用DraweeController</p>
<h3 id="通过DataSource发起图片加载"><a href="#通过DataSource发起图片加载" class="headerlink" title="通过DataSource发起图片加载"></a>通过DataSource发起图片加载</h3><p>在前面已经说了<code>DraweeController</code>是直接持有<code>DraweeHierachy</code>，所以它观察到<code>ProducerSequence</code>的数据变化是可以很容易更新到<code>DraweeHierachy</code>（具体代码先不展示了）。那它是如何控制<code>ProducerSequence</code>来加载图片的呢？其实<code>DraweeController</code>并不会直接和<code>ProducerSequence</code>发生关联。对于图片的加载，它直接接触的是<code>DataSource</code>，由<code>DataSource</code>进而来控制<code>ProducerSequence</code>发起图片加载和处理流程。下面就跟随源码来看一下<code>DraweeController</code>是如果通过<code>DataSource</code>来控制<code>ProducerSequence</code>发起图片加载和处理流程的。</p>
<blockquote>
<p>DraweeController发起图片加载请求的方法是(AbstractDraweeController.java):</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">submitRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T closeableImage = getCachedImage(); <span class="comment">//从mImagePipeline.getBitmapMemoryCache()中寻找内存（解码后）是否存在</span></span><br><span class="line">  	<span class="keyword">if</span>(closeableImage != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//处理获取图像结果</span></span><br><span class="line">       onNewResultInternal(mId, mDataSource, closeableImage, <span class="number">1.0f</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mDataSource = getDataSource(); </span><br><span class="line">    <span class="keyword">final</span> DataSubscriber&lt;T&gt; dataSubscriber = <span class="keyword">new</span> BaseDataSubscriber&lt;T&gt;() &#123; <span class="comment">//可以简单的把它理解为一个监听者</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNewResultImpl</span><span class="params">(DataSource&lt;T&gt; dataSource)</span> </span>&#123; <span class="comment">//图片加载回调</span></span><br><span class="line">            <span class="keyword">boolean</span> isFinished = dataSource.isFinished();</span><br><span class="line">            <span class="keyword">boolean</span> hasMultipleResults = dataSource.hasMultipleResults();</span><br><span class="line">            <span class="keyword">float</span> progress = dataSource.getProgress();</span><br><span class="line">            T image = dataSource.getResult();</span><br><span class="line">            <span class="keyword">if</span> (image != <span class="keyword">null</span>) &#123;</span><br><span class="line">              	<span class="comment">//加载成功，处理图像结果</span></span><br><span class="line">            		onNewResultInternal(</span><br><span class="line">                  id, dataSource, image, progress, isFinished, wasImmediate, hasMultipleResults); </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isFinished)&#123;</span><br><span class="line">              	<span class="comment">//处理失败</span></span><br><span class="line">              	onFailureInternal(id, dataSource, <span class="keyword">new</span> NullPointerException(), <span class="comment">/* isFinished */</span> <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">    mDataSource.subscribe(dataSubscriber, mUiThreadImmediateExecutor); <span class="comment">//mUiThreadImmediateExecutor是指 dataSubscriber 回调方法运行的线程，这里是主线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onNewResultInternal</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String id,</span></span></span><br><span class="line"><span class="function"><span class="params">    DataSource&lt;T&gt; dataSource,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@Nullable</span> T image,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">float</span> progress,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isFinished,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> wasImmediate,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> deliverTempResult)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create drawable</span></span><br><span class="line">    Drawable drawable;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      drawable = createDrawable(image);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T previousImage = mFetchedImage;</span><br><span class="line">    Drawable previousDrawable = mDrawable;</span><br><span class="line">    mFetchedImage = image;</span><br><span class="line">    mDrawable = drawable;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// set the new image</span></span><br><span class="line">      <span class="keyword">if</span> (isFinished) &#123;</span><br><span class="line">        <span class="comment">//完成加载，设置Hierarchy（View层）图层，并由controller监听器回调切换图层</span></span><br><span class="line">        mSettableDraweeHierarchy.setImage(drawable, <span class="number">1f</span>, wasImmediate);</span><br><span class="line">        getControllerListener().onFinalImageSet(id, getImageInfo(image), getAnimatable());</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deliverTempResult) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//释放图像资源</span></span><br><span class="line">      ...</span><br><span class="line">      releaseDrawable(previousDrawable);</span><br><span class="line">      ...</span><br><span class="line">      releaseImage(previousImage);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>那<code>DataSource</code>是什么呢？ <code>getDataSource()</code>最终会调用到:</p>
<blockquote>
<p>ImagePipeline.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; fetchDecodedImage(ImageRequest imageRequest,...) &#123;</span><br><span class="line">     <span class="comment">//获取加载图片的ProducerSequence</span></span><br><span class="line">      Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; producerSequence = mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> submitFetchRequest(</span><br><span class="line">          producerSequence,</span><br><span class="line">          imageRequest,</span><br><span class="line">          lowestPermittedRequestLevelOnSubmit,</span><br><span class="line">          callerContext,</span><br><span class="line">          requestListener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; DataSource&lt;CloseableReference&lt;T&gt;&gt; submitFetchRequest(...) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> CloseableProducerToDataSourceAdapter.create(producerSequence, settableProducerContext, finalRequestListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以<code>DraweeController</code>最终拿到的<code>DataSource</code>是<code>CloseableProducerToDataSourceAdapter</code>。这个类在构造的时候就会启动图片加载流程(它的构造方法会调用<code>producer.produceResults(...)</code>,这个方法就是图片加载的起点，我们后面再看)。</p>
<p><strong>DataSource小结</strong></p>
<p><code>Fresco</code>中<code>DataSource</code>的概念以及作用:<strong>在<code>Fresco</code>中<code>DraweeController</code>每发起一次图片加载就会创建一个<code>DataSource</code>,这个<code>DataSource</code>用来提供这次请求的数据(图片)。<code>DataSource</code>只是一个接口，至于具体的加载流程<code>Fresco</code>是通过<code>ProducerSequence</code>来实现的。</strong></p>
<p><strong>C层更具体的ProducerSequence怎么实现下载、解码、缓存的下面将进一步说明：</strong></p>
<h2 id="ProducerSequence"><a href="#ProducerSequence" class="headerlink" title="ProducerSequence"></a>ProducerSequence</h2><p>ImagePipeline获取图片时，会根据不同的请求（获取解码图片：fetchDecodedImage，或者获取未解码图片：fetchEncodedImage）生成不同的<code>Producer Sequence</code>，其实就是一个<code>Producer</code>链条，每个<code>Producer</code>只负责整个链条中的一环，例如：NetworkFetchProducer负责下载图片，DecodeProducer负责解码图片等。</p>
<p><code>Producer</code>的作用:<strong>一个<code>Producer</code>用来处理整个<code>Fresco</code>图片处理流程中的一步，比如从网络获取图片、内存获取图片、解码图片等等</strong>，而<code>Consumer</code>可以把它理解为监听者。</p>
<p><code>Producer</code>的处理结果可以通过<code>Consumer</code>来告诉外界，比如是失败还是成功。</p>
<p>一个<code>ProducerA</code>可以接收另一个<code>ProducerB</code>作为参数，如果<code>ProducerA</code>处理完毕后可以调用<code>ProducerB</code>来继续处理。并传入<code>Consumer</code>来观察<code>ProducerB</code>的处理结果。比如<code>Fresco</code>在加载图片时会先去内存缓存获取，如果内存缓存中没有那么就网络加载。这里涉及到两个<code>Producer</code>分别是<code>BitmapMemoryCacheProducer</code>和<code>NetworkFetchProducer</code>，假设<code>BitmapMemoryCacheProducer</code>为<code>ProducerA</code>，<code>NetworkFetchProducer</code>为<code>ProducerB</code>。</p>
<p>见附录：完整ProducerSequence；</p>
<p><img src="/2021/04/09/Fresco/169492b769e12c8d~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<p>这张图描述了<code>Fresco</code>在第一次网络图片时所经历的过程，从图中可以看出涉及到缓存的<code>Producer</code>共有4个:<code>BitmapMemroyCacheGetProducer</code>、<code>BitmapMemoryCacheProducer</code>、<code>EncodedMemoryCacheProducer</code>和<code>DiskCacheWriteProducer</code>。<code>Fresco</code>在加载图片时会按照<strong>图中绿色箭头</strong>所示依次经过这四个<code>缓存Producer</code>，一旦在某个<code>Producer</code>得到图片请求结果，就会按照<strong>蓝色箭头</strong>所示把结果依次回调回来。简单介绍一下这4个<code>Producer</code>的功能:</p>
<ol>
<li><p><code>BitmapMemroyCacheGetProducer</code>: 这个<code>Producer</code>会去内存缓存中检查这次请求有没命中缓存，如果命中则将缓存的图片作为这次请求结果。</p>
</li>
<li><p><code>BitmapMemoryCacheProducer</code>: 这个<code>Producer</code>会监听其后面的<code>Producer</code>的<code>Result</code>，并把<code>Result(CloseableImage)</code>存入缓存。</p>
</li>
<li><p><code>EncodedMemoryCacheProducer</code>: 它也是一个内存缓存，不过它缓存的是未解码的图片，即图片原始字节。</p>
</li>
<li><p><code>DiskCacheWriteProducer</code>: 顾名思义，它负责把图片缓存到磁盘，它缓存的也是未解码的图片。获取图片时如果命中了磁盘缓存那么就返回缓存的结果。</p>
</li>
</ol>
<p>这里仅以Bitmap内存缓存为例子，展开说明PorducerSequence中其中 磁盘缓存或内存缓存 CacheProducer节点的工作流程：</p>
<p><code>BitmapMemroyCacheGetProducer</code>派生自<code>BitmapMemoryCacheProducer</code>,与<code>BitmapMemoryCacheProducer</code>的不同就是<strong>只读不写</strong>而已。 大致看一下<code>BitmapMemoryCacheProducer</code>的缓存运作逻辑:</p>
<blockquote>
<p>BitmapMemoryCacheProducer.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitmapMemoryCacheProducer</span> <span class="keyword">implements</span> <span class="title">Producer</span>&lt;<span class="title">CloseableReference</span>&lt;<span class="title">CloseableImage</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemoryCache&lt;CacheKey, CloseableImage&gt; mMemoryCache; <span class="comment">//图片缓存的实现</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceResults</span><span class="params">(Consumer&lt;CloseableReference&lt;CloseableImage&gt;&gt; consumer...)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.先去缓存中获取</span></span><br><span class="line">        CloseableReference&lt;CloseableImage&gt; cachedReference = mMemoryCache.get(cacheKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.命中缓存直接返回请求结果</span></span><br><span class="line">        <span class="keyword">if</span> (cachedReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            consumer.onNewResult(cachedReference, BaseConsumer.simpleStatusForIsLast(isFinal));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//3.wrapConsumer来观察后续Producer的结果</span></span><br><span class="line">        Consumer&lt;CloseableReference&lt;CloseableImage&gt;&gt; wrappedConsumer = wrapConsumer(consumer..);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.让下一个Producer继续工作</span></span><br><span class="line">        mInputProducer.produceResults(wrappedConsumer, producerContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Consumer&lt;CloseableReference&lt;CloseableImage&gt;&gt; wrapConsumer()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatingConsumer&lt;...&gt;(consumer) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNewResultImpl</span><span class="params">(CloseableReference&lt;CloseableImage&gt; newResult...)</span></span>&#123;</span><br><span class="line">                <span class="comment">//5.缓存结果</span></span><br><span class="line">                newCachedResult = mMemoryCache.cache(cacheKey, newResult); </span><br><span class="line"></span><br><span class="line">                <span class="comment">//6.通知前面的Producer图片请求结果</span></span><br><span class="line">                getConsumer().onNewResult((newCachedResult != <span class="keyword">null</span>) ? newCachedResult : newResult, status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的主要流程图如下(<strong>后面两个缓存的流程与它基本相同，因此对于缓存整体流程只画这一次</strong>):</p>
<p><img src="/2021/04/09/Fresco/169492b769eccce9~tplv-t2oaga2asx-watermark-20210930151741056.awebp" alt="img"></p>
<p>​                                                                <em>BitmapMemoryCacheProducer工作流.png</em>    </p>
<p><strong>图中红色箭头和字体是正常网络加载图片(第一次)的步骤</strong></p>
<h3 id="内存缓存-MemoryCache"><a href="#内存缓存-MemoryCache" class="headerlink" title="内存缓存 : MemoryCache"></a>内存缓存 : MemoryCache</h3><p><code>MemoryCache</code>是一个接口，在这里它的对应实现是<code>CountingMemoryCache</code>, 先来看一下这个类的构造函数:</p>
<blockquote>
<p>CountingMemoryCache.java</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class CountingMemoryCache&lt;K, V&gt; implements MemoryCache&lt;K, V&gt;, MemoryTrimmable &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;缓存的集合其实就是一个map，不过这个map使用 Lru 算法</span><br><span class="line">    final CountingLruMap&lt;K, Entry&lt;K, V&gt;&gt; mExclusiveEntries;  </span><br><span class="line">    final CountingLruMap&lt;K, Entry&lt;K, V&gt;&gt; mCachedEntries; </span><br><span class="line"></span><br><span class="line">    public CountingMemoryCache(ValueDescriptor&lt;V&gt; valueDescriptor,CacheTrimStrategy cacheTrimStrategy,Supplier&lt;MemoryCacheParams&gt; memoryCacheParamsSupplier) &#123;</span><br><span class="line">        mValueDescriptor &#x3D; valueDescriptor;&#x2F;&#x2F; 用来估算当前缓存实体的大小</span><br><span class="line">        mExclusiveEntries &#x3D; new CountingLruMap&lt;&gt;(wrapValueDescriptor(valueDescriptor)); &#x2F;&#x2F; 主要存放没有被引用的对象，它的所有元素一定在 mCachedEntries 集合中存在</span><br><span class="line">        mCachedEntries &#x3D; new CountingLruMap&lt;&gt;(wrapValueDescriptor(valueDescriptor));  &#x2F;&#x2F; 主要缓存集合</span><br><span class="line">        mCacheTrimStrategy &#x3D; cacheTrimStrategy; &#x2F;&#x2F; trim缓存的策略 (其实就是指定了trim ratio)</span><br><span class="line">        mMemoryCacheParams &#x3D; mMemoryCacheParamsSupplier.get();  &#x2F;&#x2F;  通过 ImagePipelineConfig 来配置的缓存参数</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过构造函数可以知道<code>CountingMemoryCache</code>一共含有两个缓存集合 :</p>
<ul>
<li><code>mCachedEntries</code> : 它是用来存放所有缓存对象的集合</li>
<li><code>mExclusiveEntries</code>: 它是用来存放当前没有被引用的对象，在<code>trim</code>缓存是，主要是<code>trim</code>掉这个缓存集合的中的对象。</li>
</ul>
<p><code>CountingMemoryCache</code>的缓存逻辑主要是围绕这两个集合展开的。接下来看一下它的<code>cache</code>和<code>get</code>的方法(这两个方法是缓存的核心方法)。</p>
<h4 id="将图片保存到内存缓存-CountingMemoryCache-cache"><a href="#将图片保存到内存缓存-CountingMemoryCache-cache" class="headerlink" title="将图片保存到内存缓存 : CountingMemoryCache.cache()"></a>将图片保存到内存缓存 : CountingMemoryCache.cache()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public  CloseableReference&lt;V&gt; cache(K key, CloseableReference&lt;V&gt; valueRef, EntryStateObserver&lt;K&gt; observer) &#123;</span><br><span class="line"></span><br><span class="line">    Entry&lt;K, V&gt; oldExclusive;</span><br><span class="line">    CloseableReference&lt;V&gt; oldRefToClose &#x3D; null;</span><br><span class="line">    CloseableReference&lt;V&gt; clientRef &#x3D; null;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        oldExclusive &#x3D; mExclusiveEntries.remove(key);   &#x2F;&#x2F;如果存在的话，从没有引用的缓存集合中清除</span><br><span class="line">        Entry&lt;K, V&gt; oldEntry &#x3D; mCachedEntries.remove(key); &#x2F;&#x2F;从主缓存集合中移除</span><br><span class="line">        if (oldEntry !&#x3D; null) &#123;</span><br><span class="line">            makeOrphan(oldEntry);</span><br><span class="line">            oldRefToClose &#x3D; referenceToClose(oldEntry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (canCacheNewValue(valueRef.get())) &#123;  &#x2F;&#x2F;会判断是否到达了当前缓存的最大值</span><br><span class="line">            Entry&lt;K, V&gt; newEntry &#x3D; Entry.of(key, valueRef, observer); &#x2F;&#x2F; 构造一个缓存实体(Entry)</span><br><span class="line">            mCachedEntries.put(key, newEntry);   &#x2F;&#x2F;缓存</span><br><span class="line">            clientRef &#x3D; newClientReference(newEntry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CloseableReference.closeSafely(oldRefToClose);    &#x2F;&#x2F;可能会调用到 release 方法，</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return clientRef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码我做了比较详细的注释。简单的讲就是<strong>把这个对象放入到<code>mCachedEntries</code>集合中，如果原来就已经缓存了这个对象，那么就要把它先从<code>mCachedEntries</code>和<code>mExclusiveEntries</code>集合中移除。</strong></p>
<h5 id="Fresco的默认内存缓存大小"><a href="#Fresco的默认内存缓存大小" class="headerlink" title="Fresco的默认内存缓存大小"></a>Fresco的默认内存缓存大小</h5><p>上面<code>canCacheNewValue()</code>是用来判断当前缓存是否已经达到了最大值。那<code>Fresco</code>内存缓存的最大值是多少呢？这个值可以通过<code>ImagePipelineConfig</code>来配置，如果没有配置的话默认配置是:<code>DefaultBitmapMemoryCacheParamsSupplier</code>:</p>
<blockquote>
<p>DefaultBitmapMemoryCacheParamsSupplier.java</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultBitmapMemoryCacheParamsSupplier implements Supplier&lt;MemoryCacheParams&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    private int getMaxCacheSize() &#123;</span><br><span class="line">        final int maxMemory &#x3D; Math.min(mActivityManager.getMemoryClass() * ByteConstants.MB, Integer.MAX_VALUE);</span><br><span class="line">        if (maxMemory &lt; 32 * ByteConstants.MB) &#123;</span><br><span class="line">            return 4 * ByteConstants.MB;</span><br><span class="line">        &#125; else if (maxMemory &lt; 64 * ByteConstants.MB) &#123;</span><br><span class="line">            return 6 * ByteConstants.MB;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">                return 8 * ByteConstants.MB;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return maxMemory &#x2F; 4;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即<code>Fresco</code>的默认缓存大小是根据当前应用的运行内存来决定的，对于应用运行内存达到64MB以上的手机(现在的手机普遍已经大于这个值了)，<code>Fresco</code>的默认缓存大小是<code>maxMemory / 4</code></p>
<h4 id="从内存缓存中获取图片-CountingMemoryCache-get"><a href="#从内存缓存中获取图片-CountingMemoryCache-get" class="headerlink" title="从内存缓存中获取图片 : CountingMemoryCache.get()"></a>从内存缓存中获取图片 : CountingMemoryCache.get()</h4><p>缓存获取的逻辑也很简单:</p>
<blockquote>
<p>CountingMemoryCache.java</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public CloseableReference&lt;V&gt; get(final K key) &#123;</span><br><span class="line">Entry&lt;K, V&gt; oldExclusive;</span><br><span class="line">    CloseableReference&lt;V&gt; clientRef &#x3D; null;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        oldExclusive &#x3D; mExclusiveEntries.remove(key);</span><br><span class="line">        Entry&lt;K, V&gt; entry &#x3D; mCachedEntries.get(key);</span><br><span class="line">        if (entry !&#x3D; null) &#123;</span><br><span class="line">            clientRef &#x3D; newClientReference(entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    maybeNotifyExclusiveEntryRemoval(oldExclusive);</span><br><span class="line">    maybeUpdateCacheParams();</span><br><span class="line">    maybeEvictEntries();</span><br><span class="line">    return clientRef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即从<code>mCachedEntries集合</code>中获取，如果<code>mExclusiveEntries集合</code>中存在的话就移除。</p>
<h4 id="trim策略-CountingMemoryCache-getrimt"><a href="#trim策略-CountingMemoryCache-getrimt" class="headerlink" title="trim策略 : CountingMemoryCache.getrimt()"></a>trim策略 : CountingMemoryCache.getrimt()</h4><p>当内存缓存达到峰值或系统内存不足时就需要对当前的内存缓存做<code>trim</code>操作, <code>trim</code>时是基于<code>Lru</code>算法的，我们看一下它的具体逻辑:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void trim(MemoryTrimType trimType) &#123;</span><br><span class="line">  ArrayList&lt;Entry&lt;K, V&gt;&gt; oldEntries;</span><br><span class="line">  &#x2F;&#x2F;根据当前的应用状态来确定trim ratio。 应用状态是指: 应用处于前台、后台等等</span><br><span class="line">  final double trimRatio &#x3D; mCacheTrimStrategy.getTrimRatio(trimType);</span><br><span class="line">  ...</span><br><span class="line">  int targetCacheSize &#x3D; (int) (mCachedEntries.getSizeInBytes() * (1 - trimRatio));  &#x2F;&#x2F; trim到当前缓存的多少</span><br><span class="line">  int targetEvictionQueueSize &#x3D; Math.max(0, targetCacheSize - getInUseSizeInBytes());  &#x2F;&#x2F; 到底能trim多大</span><br><span class="line">  oldEntries &#x3D; trimExclusivelyOwnedEntries(Integer.MAX_VALUE, targetEvictionQueueSize); &#x2F;&#x2F;trim  mExclusiveEntries集合 集合中的对象</span><br><span class="line">  makeOrphans(oldEntries);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>trim操作的主要步骤是:</p>
<ol>
<li>根据当前应用的状态决定<code>trim ratio</code> (应用状态是指应用处于前台、后台等等)。</li>
<li>根据<code>trim ratio</code>来算出经过trim后缓存的大小<code>targetCacheSize</code></li>
<li>根据<code>mExclusiveEntries</code>集合的大小来决定到底能trim多少 (能trim的最大就是mExclusiveEntries.size)</li>
<li>对<code>mExclusiveEntries</code>集合做<code>trim</code>操作，即移除其中的元素。</li>
</ol>
<p>即<code>trim</code>时最大能<code>trim</code>掉的大小是<code>mExclusiveEntries</code>集合的大小。所以如果当前应用存在内存泄漏，导致<code>mExclusiveEntries</code>中的元素很少，那么<code>trim</code>操作几乎是没有效果的。</p>
<h2 id="编码内存缓存-EncodedMemoryCacheProducer"><a href="#编码内存缓存-EncodedMemoryCacheProducer" class="headerlink" title="编码内存缓存 : EncodedMemoryCacheProducer"></a>编码内存缓存 : EncodedMemoryCacheProducer</h2><p>这个缓存<code>Producer</code>的工作逻辑和<code>BitmapMemoryCacheProducer</code>相同,不同的是它缓存的对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class EncodedMemoryCacheProducer implements Producer&lt;EncodedImage&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final MemoryCache&lt;CacheKey, PooledByteBuffer&gt; mMemoryCache; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即它缓存的是<code>PooledByteBuffer</code>, 它是什么东西呢? 它牵扯到<code>Fresco编码图片</code>的内存管理，这些内容我会单开一篇文章来讲一下。这里就先不说了。<code>PooledByteBuffer</code>你可以简单的把它当成一个字节数组。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h2 id="磁盘缓存-DiskCacheWriteProducer"><a href="#磁盘缓存-DiskCacheWriteProducer" class="headerlink" title="磁盘缓存 : DiskCacheWriteProducer"></a>磁盘缓存 : DiskCacheWriteProducer</h2><p>它是<code>Fresco</code>图片磁盘缓存的逻辑管理者，整个缓存逻辑和<code>BitmapMemoryCacheProducer</code>差不多:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class DiskCacheWriteProducer implements Producer&lt;EncodedImage&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final BufferedDiskCache mDefaultBufferedDiskCache; &#x2F;</span><br><span class="line">    ...</span><br><span class="line">    private static class DiskCacheWriteConsumer extends DelegatingConsumer&lt;EncodedImage, EncodedImage&gt; &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onNewResultImpl(EncodedImage newResult, @Status int status) &#123;</span><br><span class="line">            ...</span><br><span class="line">            mDefaultBufferedDiskCache.put(cacheKey, newResult);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们主要看一下它的磁盘存储逻辑(怎么存), 对于存储逻辑是由<code>BufferedDiskCache</code>来负责的:</p>
<h3 id="BufferedDiskCache"><a href="#BufferedDiskCache" class="headerlink" title="BufferedDiskCache"></a>BufferedDiskCache</h3><p>先来看一下类的组成结构:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class BufferedDiskCache &#123;</span><br><span class="line">    private final FileCache mFileCache;  &#x2F;&#x2F; 文件存储的实现</span><br><span class="line">    private final Executor mWriteExecutor; &#x2F;&#x2F;存储文件时的线程</span><br><span class="line">    private final StagingArea mStagingArea; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>FileCache : 将<code>EncodeImage</code>保存到磁盘存储实现。</li>
<li>Executor : 指定文件保存操作所运行的线程。</li>
<li>StagingArea: 类似于git中的stage概念,它是一个map,用于保存当前正在进行磁盘缓存操作。</li>
</ul>
<h4 id="将图片保存至磁盘-BufferedDiskCache-put"><a href="#将图片保存至磁盘-BufferedDiskCache-put" class="headerlink" title="将图片保存至磁盘 : BufferedDiskCache.put()"></a>将图片保存至磁盘 : BufferedDiskCache.put()</h4><p>这个方法主要负责往磁盘缓存一张图片:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void put(final CacheKey key, EncodedImage encodedImage) &#123;</span><br><span class="line">    ..</span><br><span class="line">    mStagingArea.put(key, encodedImage); &#x2F;&#x2F;把这次缓存操作放到暂存区</span><br><span class="line">    ...</span><br><span class="line">    final EncodedImage finalEncodedImage &#x3D; EncodedImage.cloneOrNull(encodedImage);</span><br><span class="line">    mWriteExecutor.execute( &#x2F;&#x2F;开启写入线程</span><br><span class="line">        new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                writeToDiskCache(key, finalEncodedImage); &#x2F;&#x2F;写入到磁盘</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                mStagingArea.remove(key, finalEncodedImage); &#x2F;&#x2F;从操作暂存区中移除这次操作</span><br><span class="line">                EncodedImage.closeSafely(finalEncodedImage);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>writeToDiskCache()</code>主要调用<code>mFileCache.insert()</code>来把图片保存到磁盘:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mFileCache.insert(key, new WriterCallback() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void write(OutputStream os) throws IOException &#123;</span><br><span class="line">            mPooledByteStreams.copy(encodedImage.getInputStream(), os); &#x2F;&#x2F;实际上就是把encodeImage 写入到 os(OutputStream) 中</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>至于<code>mFileCache.insert()</code>的具体实现涉及的源码较多，考虑文章篇幅的原因这里我不去具体跟了。简单的总结一下其实现步骤和一些关键点:</p>
<h5 id="Step1-生成ResourceId"><a href="#Step1-生成ResourceId" class="headerlink" title="Step1 : 生成ResourceId"></a>Step1 : 生成ResourceId</h5><p>这个<code>ResourceId</code>可以简单的理解为缓存文件的文件名，它的生成算法如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SecureHashUtil.makeSHA1HashBase64(key.getUriString().getBytes(&quot;UTF-8&quot;));  &#x2F;&#x2F; key就是CacheKey</span><br></pre></td></tr></table></figure>

<p>即<code>SHA-1</code> + <code>Base64</code>。</p>
<h5 id="Step2-创建临时文件，并把图片写入到临时文件中"><a href="#Step2-创建临时文件，并把图片写入到临时文件中" class="headerlink" title="Step2 : 创建临时文件，并把图片写入到临时文件中"></a>Step2 : 创建临时文件，并把图片写入到临时文件中</h5><blockquote>
<p>创建临时文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public File createTempFile(File parent) throws IOException &#123;</span><br><span class="line">    return File.createTempFile(resourceId + &quot;.&quot;, TEMP_FILE_EXTENSION, parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>把图片写入到这个临时文件中 : DefaultDiskStorage.java</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void writeData(WriterCallback callback, Object debugInfo) throws IOException &#123;</span><br><span class="line">   FileOutputStream fileStream &#x3D; new FileOutputStream(mTemporaryFile);</span><br><span class="line">   ...</span><br><span class="line">   CountingOutputStream countingStream &#x3D; new CountingOutputStream(fileStream);</span><br><span class="line">   callback.write(countingStream);</span><br><span class="line">   countingStream.flush();</span><br></pre></td></tr></table></figure>

<p>这里的<code>callback(WriterCallback)</code>就是<code>mFileCache.insert()</code>方法传入的那个<code>callback -&gt; &#123; mPooledByteStreams.copy(encodedImage.getInputStream(), os); &#125;</code></p>
<h5 id="Step3-把临时文件重命名为resourceId"><a href="#Step3-把临时文件重命名为resourceId" class="headerlink" title="Step3 : 把临时文件重命名为resourceId"></a>Step3 : 把临时文件重命名为resourceId</h5><h5 id="Step4-设置好文件的最后修改时间"><a href="#Step4-设置好文件的最后修改时间" class="headerlink" title="Step4 : 设置好文件的最后修改时间"></a>Step4 : 设置好文件的最后修改时间</h5><h4 id="从磁盘中获取文件-BufferedDiskCache-get"><a href="#从磁盘中获取文件-BufferedDiskCache-get" class="headerlink" title="从磁盘中获取文件 : BufferedDiskCache.get()"></a>从磁盘中获取文件 : BufferedDiskCache.get()</h4><p>读就是写的逆操作，这里不做具体分析了。</p>
<h2 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h2><h3 id="Fresco-Key"><a href="#Fresco-Key" class="headerlink" title="Fresco Key"></a>Fresco Key</h3><h4 id="MemoryCacheKey"><a href="#MemoryCacheKey" class="headerlink" title="MemoryCacheKey"></a>MemoryCacheKey</h4><p>解码内存缓存时由CountingMemoryCache类真正实现，内部维护CountingLruMap (内为LinkedHashMap)，value为CountingMemoryCache$Entry (持有CloseableReference-&gt;Bitmap)。</p>
<p>key为（内存缓存CacheKey子类 BitmapMemoryCacheKey ）：<strong>对于内存的缓存，fresco根据 Uri字符串、缩放尺寸、解码参数、PostProcessor等关键参数进行hashCode 生成缓存key来缓存bitmap</strong></p>
<h4 id="EncodeImageKey"><a href="#EncodeImageKey" class="headerlink" title="EncodeImageKey"></a>EncodeImageKey</h4><p>未解码内存缓存也由CountingMemoryCache类真正实现，内部维护CountingLruMap (内为LinkedHashMap)，value为</p>
<p>CountingMemoryCache$Entry (真正持有是MemoryPooledByteBuffer-&gt;NativeMemoryChunk)</p>
<p>Key为<strong>默认实现是SimpleCacheKey：参数只有图片Uri</strong></p>
<h4 id="DiskCacheKey："><a href="#DiskCacheKey：" class="headerlink" title="DiskCacheKey："></a>DiskCacheKey：</h4><p>生成固定的缓存图片目录，直接把图片Uri哈希1后base64加密作为文件名，get时就直接”判断路径+hash1base64 “是否存在</p>
<h3 id="缓存大小"><a href="#缓存大小" class="headerlink" title="缓存大小"></a>缓存大小</h3><ol>
<li>内存缓存一般是 四分之一 ActivityManager.getMemoryClass</li>
<li> 未解码的图片缓存一般是 4MB </li>
<li> 磁盘缓存一般是 40MB</li>
</ol>
<h3 id="生命周期获取"><a href="#生命周期获取" class="headerlink" title="生命周期获取"></a>生命周期获取</h3><p>通过DraweeView的onAttachedToWindow()和onDetachedFromWindow()时attachController()和detachController()，controller持有hierarchy，所以也会释放掉hierarchy。</p>
<h2 id="DecodeProducer-Gif-Decode"><a href="#DecodeProducer-Gif-Decode" class="headerlink" title="DecodeProducer - Gif Decode"></a>DecodeProducer - Gif Decode</h2><p>*解码会根据为解码的图片格式，选择不同的解码器(PNG/JPEG/GIF/WEBP)*，此处仅以Gif图decode为分析对象（网络拉取gif、解码、缓存）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ImagePipeline.java</span></span><br><span class="line"><span class="keyword">public</span> DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; fetchDecodedImage(</span><br><span class="line">    ImageRequest imageRequest,</span><br><span class="line">    Object callerContext,</span><br><span class="line">    ImageRequest.RequestLevel lowestPermittedRequestLevelOnSubmit,</span><br><span class="line">    <span class="meta">@Nullable</span> RequestListener requestListener,</span><br><span class="line">    <span class="meta">@Nullable</span> String uiComponentId) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//生产者序列工厂 获取 下载、缓存、解码图片的生产者序列</span></span><br><span class="line">    Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; producerSequence =</span><br><span class="line">        mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);</span><br><span class="line">    <span class="comment">//封装到DataSorce中处理</span></span><br><span class="line">    <span class="keyword">return</span> submitFetchRequest(</span><br><span class="line">        producerSequence,</span><br><span class="line">        imageRequest,</span><br><span class="line">        lowestPermittedRequestLevelOnSubmit,</span><br><span class="line">        callerContext,</span><br><span class="line">        requestListener,</span><br><span class="line">        uiComponentId);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">    <span class="keyword">return</span> DataSources.immediateFailedDataSource(exception);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mProducerSequenceFactory.getDecodedImageProducerSequence 调用的是getBasicDecodedImageSequence</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ProducerSequenceFactory.class</span></span><br><span class="line"><span class="comment">//ProducerSequenceFactory.getBasicDecodedImageSequence 方法中会根据imageRequest的uri的SCHEME（http/https、file等）选择合适的生产者序列工厂。此处以经典的https为例，返回的是：网络拉取序列单例</span></span><br><span class="line">mNetworkFetchSequence =</span><br><span class="line">          newBitmapCacheGetToDecodeSequence(getCommonNetworkFetchToEncodedMemorySequence());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//getCommonNetworkFetchToEncodedMemorySequence负责：</span></span><br><span class="line">		multiplex -&gt; encoded cache -&gt; disk cache -&gt; (webp transcode) -&gt; network fetch.</span><br><span class="line">  </span><br><span class="line"><span class="comment">//newBitmapCacheGetToDecodeSequence追加producer后：</span></span><br><span class="line">  	bitmap cache get -&gt; background thread hand-off -&gt; multiplex -&gt; bitmap cache -&gt; decode</span><br><span class="line">    -&gt; multiplex -&gt; encoded cache -&gt; disk cache -&gt; (webp transcode) -&gt; network fetch.</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>每一层生产者负责各自的责任，这里具体分析<strong>负责decode的DecodeProducer</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ProducerSequenceFactory.BitmapCacheGetToDecodeSequence()</span></span><br><span class="line">DecodeProducer decodeProducer = mProducerFactory.newDecodeProducer(inputProducer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ProducerFactory.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DecodeProducer <span class="title">newDecodeProducer</span><span class="params">(Producer&lt;EncodedImage&gt; inputProducer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecodeProducer(</span><br><span class="line">        mByteArrayPool,</span><br><span class="line">        mExecutorSupplier.forDecode(),</span><br><span class="line">        mImageDecoder, <span class="comment">//！！就是这里传入的解码器</span></span><br><span class="line">        mProgressiveJpegConfig,</span><br><span class="line">        mDownsampleEnabled,</span><br><span class="line">        mResizeAndRotateEnabledForNetwork,</span><br><span class="line">        mDecodeCancellationEnabled,</span><br><span class="line">        inputProducer,</span><br><span class="line">        mMaxBitmapSize,</span><br><span class="line">        mCloseableReferenceFactory);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>下面分析mImageDecoder创建来源:</p>
<h4 id="imageDecoder的创建"><a href="#imageDecoder的创建" class="headerlink" title="imageDecoder的创建"></a>imageDecoder的创建</h4><p>简述：就是构造一个单例的匿名内部ImageDecoder类，其中方法decodeGif()具体通过AnimatedImageFactoryImpl的同名方法实现。</p>
<p>首先是ProducerFactory的构建时就调用<code>getImageDecoder</code>创建ImageDecode单例并入参。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">ImagePipelineFactory.class</span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">private</span> ProducerFactory <span class="title">getProducerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mProducerFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">      mProducerFactory =</span><br><span class="line">          mConfig</span><br><span class="line">              .getExperiments()</span><br><span class="line">              .getProducerFactoryMethod()</span><br><span class="line">              .createProducerFactory(</span><br><span class="line">                  mConfig.getContext(),</span><br><span class="line">                  mConfig.getPoolFactory().getSmallByteArrayPool(),</span><br><span class="line">                  getImageDecoder(),</span><br><span class="line">                  <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mProducerFactory;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> ImageDecoder <span class="title">getImageDecoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mImageDecoder == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mConfig.getImageDecoder() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mImageDecoder = mConfig.getImageDecoder();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">/*getAnimatedFactory()利用AnimatedFactoryProvider以反射方式实例化AnimatedFactoryV2Impl并返回*/</span></span><br><span class="line">        <span class="keyword">final</span> AnimatedFactory animatedFactory = getAnimatedFactory();</span><br><span class="line"></span><br><span class="line">        ImageDecoder gifDecoder = <span class="keyword">null</span>;</span><br><span class="line">        ImageDecoder webPDecoder = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (animatedFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">          gifDecoder = animatedFactory.getGifDecoder(mConfig.getBitmapConfig());</span><br><span class="line">          webPDecoder = animatedFactory.getWebPDecoder(mConfig.getBitmapConfig());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> mImageDecoder;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">AnimatedFactoryV2Impl implements AnimatedFactory</span><br><span class="line"></span><br><span class="line"><span class="comment">//AnimatedFactoryV2Impl.class</span></span><br><span class="line"><span class="comment">//AnimatedFactoryV2Impl.getGifDeocder()中直接返回：</span></span><br><span class="line"><span class="comment">//由AnimatedFactoryV2Impl.getAnimatedImageFactory().decodeGif()实现解码的匿名内部类ImageDecoder实例;其中getAnimatedIamgeFractory()返回AnimatedImageFactoryImpl单例。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ImageDecoder <span class="title">getGifDecoder</span><span class="params">(<span class="keyword">final</span> Bitmap.Config bitmapConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ImageDecoder() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> CloseableImage <span class="title">decode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          EncodedImage encodedImage,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">int</span> length,</span></span></span><br><span class="line"><span class="function"><span class="params">          QualityInfo qualityInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">          ImageDecodeOptions options)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAnimatedImageFactory().decodeGif(encodedImage, options, bitmapConfig);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> AnimatedImageFactory <span class="title">getAnimatedImageFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAnimatedImageFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">      mAnimatedImageFactory = buildAnimatedImageFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mAnimatedImageFactory;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> AnimatedImageFactory <span class="title">buildAnimatedImageFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AnimatedDrawableBackendProvider animatedDrawableBackendProvider =</span><br><span class="line">        <span class="keyword">new</span> AnimatedDrawableBackendProvider() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> AnimatedDrawableBackend <span class="title">get</span><span class="params">(AnimatedImageResult imageResult, Rect bounds)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AnimatedDrawableBackendImpl(</span><br><span class="line">                getAnimatedDrawableUtil(),</span><br><span class="line">                imageResult,</span><br><span class="line">                bounds,</span><br><span class="line">                mDownscaleFrameToDrawableDimensions);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AnimatedImageFactoryImpl(animatedDrawableBackendProvider, mPlatformBitmapFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="encodeImage的decode过程"><a href="#encodeImage的decode过程" class="headerlink" title="encodeImage的decode过程"></a>encodeImage的decode过程</h4><p>简述：先将未解码图像中解析出gif的元数据，<u>封装 gif元数据（帧数、间隔、循环次数等）</u> 与 <u>未解码图像字节数组为</u>  AnimatedImage（GifImage）。</p>
<p>通过getCloseableImage（）根据option配置将上述AnimatedImage（GifImage）传入进一步解析，</p>
<p>即将 AnimatedImage（GifImage）中的未解码字节数组 进一步解析， 将AnimatedImage（GifImage）、预览图(maybe null)、预览帧(maybe null)、所有帧列表（如果打开了options.decodeAllFrames,maybe null），封装成AnimatedImageResult。</p>
<p>最后 GifImage在AnimatedDrawable2.draw 渲染时再进一步decode出需要的帧（GifFrame）</p>
<p>至于提到的 未解码字节数组 解析成帧的过程，是通过GifImage类实例sGifAnimatedImageDecoder，通过Native解码，主要是借助<a href="https://link.juejin.cn/?target=https://launchpad.net/ubuntu/+archive/primary/+files/giflib_5.1.4.orig.tar.bz2">giflib</a>库在Native层进行解码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大致就是个中间层调用AnimatedImageFactoryImpl解析encodeImage成CloseableImage</span></span><br><span class="line">AnimatedImageFactoryImpl implements AnimatedImageFactory&#123;</span><br><span class="line"> <span class="keyword">static</span> &#123;</span><br><span class="line">    sGifAnimatedImageDecoder = loadIfPresent(<span class="string">&quot;com.facebook.animated.gif.GifImage&quot;</span>);</span><br><span class="line">    sWebpAnimatedImageDecoder = loadIfPresent(<span class="string">&quot;com.facebook.animated.webp.WebPImage&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将encodeImage（未解码的图像，包括未解码字节与元数据的native字节数组）解析成CloseableImage（解析元数据后的图像信息）</span></span><br><span class="line"><span class="comment">//GifImage就代表一个GIF，这里只会解析出GIF的元数据，不会真正解码GIF帧</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CloseableImage <span class="title">decodeGif</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> EncodedImage encodedImage,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> ImageDecodeOptions options,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> Bitmap.Config bitmapConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sGifAnimatedImageDecoder == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line">          <span class="string">&quot;To encode animated gif please add the dependency &quot;</span> + <span class="string">&quot;to the animated-gif module&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> CloseableReference&lt;PooledByteBuffer&gt; bytesRef = encodedImage.getByteBufferRef();</span><br><span class="line">    Preconditions.checkNotNull(bytesRef);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> PooledByteBuffer input = bytesRef.get();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/*AnimateImage：Gif的表示，具体实现为GifImage，</span></span><br><span class="line"><span class="comment">      该类的实例将在内存中保存未解码数据的副本和已解码的元数据（即解析出了图像的帧数、间隔、循环次数等元数据）。</span></span><br><span class="line"><span class="comment">      ps：帧通过GifFrame按需解码。*/</span></span><br><span class="line">      AnimatedImage gifImage;</span><br><span class="line">      <span class="keyword">if</span> (input.getByteBuffer() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/*sGifAnimatedImageDecoder其实也就是是GifImage*/</span></span><br><span class="line">        gifImage = sGifAnimatedImageDecoder.decode(input.getByteBuffer());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        gifImage = sGifAnimatedImageDecoder.decode(input.getNativePtr(), input.size());</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/*上面解析出来的AnimateImage信息，根据option配置，决定是否解析成静态图片，是否解析全部帧位图列表，是否设置预览帧等进一步封装成CloseableImage*/</span></span><br><span class="line">      <span class="keyword">return</span> getCloseableImage(options, gifImage, bitmapConfig);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      CloseableReference.closeSafely(bytesRef);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="Gif解码后帧的缓存（问题出在哪）"><a href="#Gif解码后帧的缓存（问题出在哪）" class="headerlink" title="Gif解码后帧的缓存（问题出在哪）"></a>Gif解码后帧的缓存（问题出在哪）</h4><p>还记得上面submitRequest后需要走加载流程后的图像加载成功结果<code>onNewResultInternal</code>吗，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AnimatedImageFactoryImpl.class</span><br><span class="line"><span class="function"><span class="keyword">private</span> CloseableImage <span class="title">getCloseableImage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ImageDecodeOptions options, AnimatedImage image, Bitmap.Config bitmapConfig)</span> </span>&#123;</span><br><span class="line">   AnimatedImageResult animatedImageResult =</span><br><span class="line">          AnimatedImageResult.newBuilder(image)</span><br><span class="line">              .setPreviewBitmap(previewBitmap)</span><br><span class="line">              .setFrameForPreview(frameForPreview)</span><br><span class="line">              .setDecodedFrames(decodedFrames)</span><br><span class="line">              .build();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> CloseableAnimatedImage(animatedImageResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法会将AnimatedImage（GifImage）进一步封装成AnimatedResult（构建者模式构建），然后返回一个new CloseableAnimatedImage(animatedImageResult)</p>
<p>此时CloseableAnimatedImage中就有了新建的animatedImageResult（未解码的图像与gif元数据），最后这个closeableAnimatedImage会被传递到<code>AbstractDraweeController.class</code>中的</p>
<p><code>onNewResultInternal(String id,       DataSource&lt;T&gt; dataSource,       @Nullable T image,       float progress,       boolean isFinished,       boolean wasImmediate,       boolean deliverTempResult)</code>    ，</p>
<p>执行<code> drawable = createDrawable(image);</code></p>
<p>此方法具体实现在<code>PipelineDraweeController（extends AbstractDraweeController）</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PipelineDraweeController</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Drawable <span class="title">createDrawable</span><span class="params">(CloseableReference&lt;CloseableImage&gt; image)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    drawable = mDefaultDrawableFactory.createDrawable(closeableImage);</span><br><span class="line">    <span class="keyword">if</span> (drawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> drawable;</span><br><span class="line">    &#125;</span><br><span class="line">   	...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mDefaultDrawableFactory</code>是<code>ExperimentalBitmapAnimationDrawableFactory（ implements DrawableFactory）</code>的实例，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ExperimentalBitmapAnimationDrawableFactory.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AnimatedDrawable2 <span class="title">createDrawable</span><span class="params">(CloseableImage image)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> AnimatedDrawable2(</span><br><span class="line">    	<span class="comment">//((CloseableAnimatedImage) image).getImageResult())也就是上面AnimatedImageFactoryImpl.getCloseableImage返回的AnimatedResult对象。</span></span><br><span class="line">      createAnimationBackend(((CloseableAnimatedImage) image).getImageResult()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> AnimationBackend <span class="title">createAnimationBackend</span><span class="params">(AnimatedImageResult animatedImageResult)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    BitmapFrameCache bitmapFrameCache = createBitmapFrameCache(animatedImageResult);</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> AnimatedFrameCache <span class="title">createAnimatedFrameCache</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> AnimatedImageResult animatedImageResult)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AnimatedFrameCache(</span><br><span class="line">        <span class="keyword">new</span> AnimationFrameCacheKey(animatedImageResult.hashCode()), mBackingCache);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimationFrameCacheKey</span> <span class="keyword">implements</span> <span class="title">CacheKey</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URI_PREFIX = <span class="string">&quot;anim://&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String mAnimationUriString;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mDeepEquals; <span class="comment">//源码中为false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//imageId = animatedImageResult.hashCode()</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AnimationFrameCacheKey</span><span class="params">(<span class="keyword">int</span> imageId)</span> </span>&#123;</span><br><span class="line">    mAnimationUriString = URI_PREFIX + imageId;</span><br><span class="line">    <span class="comment">//e.g： “anim://306123060&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//重写equals与hashCode方法以求 得到正确的比对结果</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="meta">@Nullable</span> Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mDeepEquals) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.equals(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AnimationFrameCacheKey that = (AnimationFrameCacheKey) o;</span><br><span class="line">    <span class="keyword">return</span> mAnimationUriString.equals(that.mAnimationUriString);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mDeepEquals) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mAnimationUriString.hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimatedFrameCache</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CloseableReference&lt;CloseableImage&gt; <span class="title">cache</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> frameIndex, CloseableReference&lt;CloseableImage&gt; imageRef)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBackingCache.cache(keyFor(frameIndex), imageRef, mEntryStateObserver);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> FrameKey <span class="title">keyFor</span><span class="params">(<span class="keyword">int</span> frameIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FrameKey(mImageCacheKey, frameIndex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//每一帧的缓存Key。equals时比较类型、</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameKey</span> <span class="keyword">implements</span> <span class="title">CacheKey</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里CacheKey 是 AnimationFrameCacheKey</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CacheKey mImageCacheKey;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mFrameIndex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FrameKey</span><span class="params">(CacheKey imageCacheKey, <span class="keyword">int</span> frameIndex)</span> </span>&#123;</span><br><span class="line">      mImageCacheKey = imageCacheKey;</span><br><span class="line">      mFrameIndex = frameIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (o == <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (o <span class="keyword">instanceof</span> FrameKey) &#123;</span><br><span class="line">        FrameKey that = (FrameKey) o;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.mFrameIndex == that.mFrameIndex</span><br><span class="line">            &amp;&amp; <span class="keyword">this</span>.mImageCacheKey.equals(that.mImageCacheKey);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onFrameRendered</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> frameNumber,</span></span></span><br><span class="line"><span class="function"><span class="params">      CloseableReference&lt;Bitmap&gt; bitmapReference,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@BitmapAnimationBackend</span>.FrameType <span class="keyword">int</span> frameType)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(bitmapReference);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close up prepared references.</span></span><br><span class="line">    removePreparedReference(frameNumber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the new image reference and cache it.</span></span><br><span class="line">    CloseableReference&lt;CloseableImage&gt; closableReference = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      closableReference = createImageReference(bitmapReference);</span><br><span class="line">      <span class="keyword">if</span> (closableReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">        CloseableReference.closeSafely(mLastRenderedItem);</span><br><span class="line">        mLastRenderedItem = mAnimatedFrameCache.cache(frameNumber, closableReference);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      CloseableReference.closeSafely(closableReference);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>mBackingCache内存缓存池 缓存gif每一帧时，key为FrameKey，FrameKey由 整个Gif图形的缓存key mImageCacheKey  + 帧索引mFrameIndex） 组成。</p>
<p>而 mImageCacheKey 是AnimationFrameCacheKey的实例，其中 核心变量为mAnimationUriString，是由</p>
<p>“anim://“ + animatedImageResult.hashCode组成的字符串，并保存布尔值mDeepEquals是否进行内容判断。</p>
<p>（animatedImageResult中保存了AnimatedImage（GifImage）、预览图(maybe null)、预览帧(maybe null)、所有帧列表（如果打开了options.decodeAllFrames,maybe null），是由 未解码gif图形缓存encodeImage 初步解析元数据后 的封装）</p>
<p>如果mDeepEquals是true的话，判断缓存是否存在</p>
<p>​                 是依据FrameKey.mImageCacheKey.mAnimationUriString 内容是否相同 与 FrameKey.mFrameIndex是否相等。</p>
<p>如果mDeepEquals是false的话，判断缓存是否存在 </p>
<p>​                是依据FrameKey.mImageCacheKey.mAnimationUriString 对象是否相同 与 FrameKey.mFrameIndex是否相等</p>
<p>由于原代码中由于mDeepEquals=false，且mAnimationUriString每次都是new出来的，所以必然不会相等，也就是帧内存缓存永远无法命中。</p>
<p>那么第一步就是mDeepEquals置为true，</p>
<p>但是由于mAnimationUriString = “anim://“ + animatedImageResult.hashCode</p>
<p>又：animatedImageResult是每次解析encodeImage都会重新构建的对象，也就是：</p>
<p>从 未解码图像缓存 中，同张图片 每次解析 都会得到不同的animatedImageResult，mAnimationUriString又是每一次解析都是不同的。</p>
<p>所以帧内存缓存又无法命中。</p>
<p>所以第二步需要 一个encodeImage对应的唯一 值替代 animatedImageResult.hashCode 。</p>
<p>考虑可以选择两个：</p>
<p>一个是 encodeImage的hash值， 未解码图片内存缓存是正确的，每次应用完整周期 都会有一个唯一的encodeImage 对应图像，decodeGif时encodeImage中存储未解码图像字节数组<code>CloseableReference&lt;PooledByteBuffer&gt; mPooledByteBufferRef;</code>的<code>getValueHash</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CloseableReference.class</span><br><span class="line">Method used <span class="keyword">for</span> tracking Closeables pointed by CloseableReference. Use only <span class="keyword">for</span> debugging and logging.</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValueHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isValid() ? System.identityHashCode(mSharedReference.get()) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//identityHashCode ≈ hashCode()</span></span><br></pre></td></tr></table></figure>



<p>一个是 根据url生成的cacheKey，设想是直接用图像url生成的磁盘缓存key，但是传递链太长了</p>
<p>我暂时选择的是getValueHash</p>
<p>像dokit跟fresco都在key的生成和使用中出过一些bug，以下是我的pullRequest</p>
<p>dokit对fresco框架下的大图检测功能导致图片闪烁（源于自定义的postProcessor每次都重新都新建了 内存缓存管理类CacheKey）</p>
<p><a target="_blank" rel="noopener" href="https://github.com/didi/DoraemonKit/pull/714/commits/4dbc58b84cfe1286c666d0cab5031092df52d81e">https://github.com/didi/DoraemonKit/pull/714/commits/4dbc58b84cfe1286c666d0cab5031092df52d81e</a></p>
<p>fresco官方中gif图缓存失效，导致重复加载同一张gif图时内存持续增长</p>
<p>（源于一个EndcodeImage在进一步解析成文件字节数组包裹的对象AnimatedResult时，每次都是新建的AnimatedResult对象，又用这个对象的hashcode+frameIndex作为解析成帧内存缓存时的key信息，所以就导致了帧内存缓存失效）</p>
<p><a target="_blank" rel="noopener" href="https://github.com/facebook/fresco/issues/2605">Gif cache doesn’t seem to be working. · Issue #2605 · facebook/fresco (github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/facebook/fresco/pull/2612/commits">change imageId in AnimatedImageResult from the class hash to decodeHa… by WhileCrow · Pull Request #2612 · facebook/fresco (github.com)</a></p>
<h2 id="附录：完整ProducerSequence"><a href="#附录：完整ProducerSequence" class="headerlink" title="附录：完整ProducerSequence"></a>附录：完整ProducerSequence</h2><p>整个<code>Producer Sequence</code>，如下所示：</p>
<ol>
<li>NetworkFetchProducer : 负责从网络下载图片数据，内部持有NetworkFetcher，负责使用不同的Http框架去实现下载逻辑，例如：HttpUrlConnectionNetworkFetcher、OkHttpNetworkFetcher、VolleyNetworkFetcher等。</li>
<li>WebpTranscodeProducer : 因为不是所有Android平台都支持<code>WebP</code>，具体可以参考<code>WebpTranscodeProducer.shouldTranscode</code>方法，所以对于不支持WebP的平台，需要转换成jpg/png。其中无损或者带透明度的WebP（DefaultImageFormats.WEBP_LOSSLESS和DefaultImageFormats.WEBP_EXTENDED_WITH_ALPHA），需要转换成PNG，具体方法是先把WebP解码成RGBA，然后再把RGBA编码成PNG；简单或者扩展的WebP（DefaultImageFormats.WEBP_SIMPLE和DefaultImageFormats.WEBP_EXTENDED），需要转换成JPEG。具体方法是先把WebP解码成RGB，然后再把RGB编码成JPEG。</li>
<li>PartialDiskCacheProducer : 解下来的三个是磁盘缓存EncodedImage相关</li>
<li>DiskCacheWriteProducer</li>
<li>DiskCacheReadProducer</li>
<li>EncodedMemoryCacheProducer : 未解码数据的内存缓存</li>
<li>EncodedCacheKeyMultiplexProducer</li>
<li>AddImageTransformMetaDataProducer</li>
<li>ResizeAndRotateProducer : 负责采样和图片旋转</li>
<li>DecodeProducer : 上述的Producer都是基于EncodedImage，DecodeProducer会把EncodedImage解码成CloseableReference</li>
<li>BitmapMemoryCacheProducer : 接下来的两个是内存Bitmap缓存相关</li>
<li>BitmapMemoryCacheKeyMultiplexProducer</li>
<li>ThreadHandoffProducer : 负责切换线程</li>
<li>BitmapMemoryCacheGetProducer</li>
<li>PostprocessorProducer</li>
<li>PostprocessedBitmapMemoryCacheProducer</li>
<li>BitmapPrepareProducer</li>
</ol>
<p>从下往上，依次持有引用；从上往下，依次返回数据</p>
<h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="Fresco网络大图检测"><a href="#Fresco网络大图检测" class="headerlink" title="Fresco网络大图检测"></a>Fresco网络大图检测</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插桩</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">思路：draweeView在xml或手动setUri最终都需要为draweeView构建DraweeController，由此得到了统一的draweeView传入链接的入口</span></span><br><span class="line"><span class="comment">时机：构建完将该DraweeController设置为controller时</span></span><br><span class="line"><span class="comment">目的：获得draweeView的宽高（注册其布局回调完成）、draweeView所在页面及id、图片链接 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createDraweeViewInsnList</span><span class="params">()</span></span>: InsnList &#123;</span><br><span class="line">        <span class="keyword">return</span> with(InsnList()) &#123;</span><br><span class="line">            add(VarInsnNode(ALOAD, <span class="number">0</span>))   <span class="comment">//由于DraweeView.setController方法内引用了全局变量，故方法字节码中会将DraweeView对象最为参数传入方法</span></span><br><span class="line">            add(VarInsnNode(ALOAD, <span class="number">1</span>))</span><br><span class="line">            add(MethodInsnNode(INVOKESTATIC, <span class="string">&quot;com/didichuxing/doraemonkit/aop/bigimg/fresco/MyFrescoHook&quot;</span>, <span class="string">&quot;frescoRealHook&quot;</span>, <span class="string">&quot;(Landroid/view/View;Lcom/facebook/drawee/interfaces/DraweeController;)V&quot;</span>, <span class="literal">false</span>))</span><br><span class="line">            <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插桩</span></span><br><span class="line"><span class="comment">/* 思路：设置自定义postProcessor，postProcessor会回调图片加载完成时机</span></span><br><span class="line"><span class="comment">时机：在图片下载解析完成时</span></span><br><span class="line"><span class="comment">目的：获得内存图片大小与图片链接 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createFrescoInsnList</span><span class="params">()</span></span>: InsnList &#123;</span><br><span class="line">        <span class="keyword">return</span> with(InsnList()) &#123;</span><br><span class="line">            add(VarInsnNode(ALOAD, <span class="number">1</span>))</span><br><span class="line">            add(VarInsnNode(ALOAD, <span class="number">1</span>))</span><br><span class="line">            add(MethodInsnNode(INVOKEVIRTUAL, <span class="string">&quot;com/facebook/imagepipeline/request/ImageRequestBuilder&quot;</span>, <span class="string">&quot;getSourceUri&quot;</span>, <span class="string">&quot;()Landroid/net/Uri;&quot;</span>, <span class="literal">false</span>))</span><br><span class="line">            add(VarInsnNode(ALOAD, <span class="number">1</span>))</span><br><span class="line">            add(MethodInsnNode(INVOKEVIRTUAL, <span class="string">&quot;com/facebook/imagepipeline/request/ImageRequestBuilder&quot;</span>, <span class="string">&quot;getPostprocessor&quot;</span>, <span class="string">&quot;()Lcom/facebook/imagepipeline/request/Postprocessor;&quot;</span>, <span class="literal">false</span>))</span><br><span class="line">            add(MethodInsnNode(INVOKESTATIC, <span class="string">&quot;com/didichuxing/doraemonkit/aop/bigimg/fresco/FrescoHook&quot;</span>, <span class="string">&quot;proxy&quot;</span>, <span class="string">&quot;(Landroid/net/Uri;Lcom/facebook/imagepipeline/request/Postprocessor;)Lcom/facebook/imagepipeline/request/Postprocessor;&quot;</span>, <span class="literal">false</span>))</span><br><span class="line">            add(MethodInsnNode(INVOKEVIRTUAL, <span class="string">&quot;com/facebook/imagepipeline/request/ImageRequestBuilder&quot;</span>, <span class="string">&quot;setPostprocessor&quot;</span>, <span class="string">&quot;(Lcom/facebook/imagepipeline/request/Postprocessor;)Lcom/facebook/imagepipeline/request/ImageRequestBuilder;&quot;</span>, <span class="literal">false</span>))</span><br><span class="line">            <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//之后就是以图片链接为桥梁，将两个不同时机获取的信息整合，比对内存尺寸与view尺寸</span></span><br></pre></td></tr></table></figure>



<p>参考</p>
<p><a target="_blank" rel="noopener" href="http://susion.work/2019/03/02/android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/fresco/Fresco%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E8%B5%8F%E6%9E%90/">Fresco架构设计赏析 | susion</a></p>
<p><a target="_blank" rel="noopener" href="http://susion.work/2019/03/13/android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/fresco/Fresco%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/">Fresco缓存架构分析 | susion</a>    </p>
<p><a target="_blank" rel="noopener" href="http://susion.work/2019/03/18/android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/fresco/%E6%B5%85%E8%B0%88Fresco%E7%BC%96%E7%A0%81%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98/">Fresco缓存架构分析 | susion</a>    </p>
<p><a target="_blank" rel="noopener" href="http://susion.work/2019/03/18/android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/fresco/Fresco%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/">Fresco图片显示原理浅析 | susion</a></p>
<p><a target="_blank" rel="noopener" href="http://susion.work/2019/05/07/android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/fresco/Fresco%E4%BD%BF%E7%94%A8%E7%9A%84%E6%89%A9%E5%B1%95/">Fresco使用的扩展 | susion</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903775195365383#heading-10">GIF面面观 - 掘金 (juejin.cn)</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>fresco</p><p><a href="http://example.com/2021/04/09/Fresco/">http://example.com/2021/04/09/Fresco/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>white crow</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2021-04-09</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-04-24</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/CoreProcess/">CoreProcess</a><a class="link-muted mr-2" rel="tag" href="/tags/Core/">Core</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/04/10/JsBridage/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">JsBridage</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/04/08/Retrofit/"><span class="level-item">retrofit</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Fresco（2-5-0）"><span class="level-left"><span class="level-item">1</span><span class="level-item">Fresco（2.5.0）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#View—DraweeView"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">View—DraweeView</span></span></a></li><li><a class="level is-mobile" href="#Model—DraweeHierarchy"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">Model—DraweeHierarchy</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Fresco-图片渲染-——-六层drawable"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">Fresco 图片渲染 —— 六层drawable</span></span></a></li><li><a class="level is-mobile" href="#"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item"> </span></span></a></li></ul></li><li><a class="level is-mobile" href="#Controler—DraweeController"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">Controler—DraweeController</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#DraweeController的构造"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">DraweeController的构造</span></span></a></li><li><a class="level is-mobile" href="#通过DataSource发起图片加载"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">通过DataSource发起图片加载</span></span></a></li></ul></li><li><a class="level is-mobile" href="#ProducerSequence"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">ProducerSequence</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#内存缓存-MemoryCache"><span class="level-left"><span class="level-item">1.4.1</span><span class="level-item">内存缓存 : MemoryCache</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#将图片保存到内存缓存-CountingMemoryCache-cache"><span class="level-left"><span class="level-item">1.4.1.1</span><span class="level-item">将图片保存到内存缓存 : CountingMemoryCache.cache()</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Fresco的默认内存缓存大小"><span class="level-left"><span class="level-item">1.4.1.1.1</span><span class="level-item">Fresco的默认内存缓存大小</span></span></a></li></ul></li><li><a class="level is-mobile" href="#从内存缓存中获取图片-CountingMemoryCache-get"><span class="level-left"><span class="level-item">1.4.1.2</span><span class="level-item">从内存缓存中获取图片 : CountingMemoryCache.get()</span></span></a></li><li><a class="level is-mobile" href="#trim策略-CountingMemoryCache-getrimt"><span class="level-left"><span class="level-item">1.4.1.3</span><span class="level-item">trim策略 : CountingMemoryCache.getrimt()</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#编码内存缓存-EncodedMemoryCacheProducer"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">编码内存缓存 : EncodedMemoryCacheProducer</span></span></a></li><li><a class="level is-mobile" href="#-1"><span class="level-left"><span class="level-item">1.6</span><span class="level-item"> </span></span></a></li><li><a class="level is-mobile" href="#磁盘缓存-DiskCacheWriteProducer"><span class="level-left"><span class="level-item">1.7</span><span class="level-item">磁盘缓存 : DiskCacheWriteProducer</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#BufferedDiskCache"><span class="level-left"><span class="level-item">1.7.1</span><span class="level-item">BufferedDiskCache</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#将图片保存至磁盘-BufferedDiskCache-put"><span class="level-left"><span class="level-item">1.7.1.1</span><span class="level-item">将图片保存至磁盘 : BufferedDiskCache.put()</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Step1-生成ResourceId"><span class="level-left"><span class="level-item">1.7.1.1.1</span><span class="level-item">Step1 : 生成ResourceId</span></span></a></li><li><a class="level is-mobile" href="#Step2-创建临时文件，并把图片写入到临时文件中"><span class="level-left"><span class="level-item">1.7.1.1.2</span><span class="level-item">Step2 : 创建临时文件，并把图片写入到临时文件中</span></span></a></li><li><a class="level is-mobile" href="#Step3-把临时文件重命名为resourceId"><span class="level-left"><span class="level-item">1.7.1.1.3</span><span class="level-item">Step3 : 把临时文件重命名为resourceId</span></span></a></li><li><a class="level is-mobile" href="#Step4-设置好文件的最后修改时间"><span class="level-left"><span class="level-item">1.7.1.1.4</span><span class="level-item">Step4 : 设置好文件的最后修改时间</span></span></a></li></ul></li><li><a class="level is-mobile" href="#从磁盘中获取文件-BufferedDiskCache-get"><span class="level-left"><span class="level-item">1.7.1.2</span><span class="level-item">从磁盘中获取文件 : BufferedDiskCache.get()</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Attention"><span class="level-left"><span class="level-item">1.8</span><span class="level-item">Attention</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Fresco-Key"><span class="level-left"><span class="level-item">1.8.1</span><span class="level-item">Fresco Key</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#MemoryCacheKey"><span class="level-left"><span class="level-item">1.8.1.1</span><span class="level-item">MemoryCacheKey</span></span></a></li><li><a class="level is-mobile" href="#EncodeImageKey"><span class="level-left"><span class="level-item">1.8.1.2</span><span class="level-item">EncodeImageKey</span></span></a></li><li><a class="level is-mobile" href="#DiskCacheKey："><span class="level-left"><span class="level-item">1.8.1.3</span><span class="level-item">DiskCacheKey：</span></span></a></li></ul></li><li><a class="level is-mobile" href="#缓存大小"><span class="level-left"><span class="level-item">1.8.2</span><span class="level-item">缓存大小</span></span></a></li><li><a class="level is-mobile" href="#生命周期获取"><span class="level-left"><span class="level-item">1.8.3</span><span class="level-item">生命周期获取</span></span></a></li></ul></li><li><a class="level is-mobile" href="#DecodeProducer-Gif-Decode"><span class="level-left"><span class="level-item">1.9</span><span class="level-item">DecodeProducer - Gif Decode</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#imageDecoder的创建"><span class="level-left"><span class="level-item">1.9.1.1</span><span class="level-item">imageDecoder的创建</span></span></a></li><li><a class="level is-mobile" href="#encodeImage的decode过程"><span class="level-left"><span class="level-item">1.9.1.2</span><span class="level-item">encodeImage的decode过程</span></span></a></li><li><a class="level is-mobile" href="#Gif解码后帧的缓存（问题出在哪）"><span class="level-left"><span class="level-item">1.9.1.3</span><span class="level-item">Gif解码后帧的缓存（问题出在哪）</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#附录：完整ProducerSequence"><span class="level-left"><span class="level-item">1.10</span><span class="level-item">附录：完整ProducerSequence</span></span></a></li><li><a class="level is-mobile" href="#Other"><span class="level-left"><span class="level-item">1.11</span><span class="level-item">Other</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Fresco网络大图检测"><span class="level-left"><span class="level-item">1.11.1</span><span class="level-item">Fresco网络大图检测</span></span></a></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatarPng.png" alt="White Crow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">White Crow</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">78</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">4</p></a></div></div></nav></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a><p class="is-size-7"><span>&copy; 2024 white crow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://github.com/WhileCrow"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>