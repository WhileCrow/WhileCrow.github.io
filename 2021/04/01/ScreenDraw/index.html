<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>ScreenDraw - Crow&#039;s Sky</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Crow&#039;s Sky"><meta name="msapplication-TileImage" content="/img/avatarCircle.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Crow&#039;s Sky"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="当手指点击了桌面的App图标时发生了什么 - ProcessOn Android 屏幕刷新机制主要参考 https:&amp;#x2F;&amp;#x2F;juejin.cn&amp;#x2F;post&amp;#x2F;6863756420380196877#heading-12 省流版： 双缓存：为了解决画面撕裂；画面撕裂来自于只有一个buffer时，正在display的那一帧数据被后一帧的数据覆盖了 Vsync：系统在收到VSync pulse（Vsync脉冲"><meta property="og:type" content="blog"><meta property="og:title" content="ScreenDraw"><meta property="og:url" content="http://example.com/2021/04/01/ScreenDraw/"><meta property="og:site_name" content="Crow&#039;s Sky"><meta property="og:description" content="当手指点击了桌面的App图标时发生了什么 - ProcessOn Android 屏幕刷新机制主要参考 https:&amp;#x2F;&amp;#x2F;juejin.cn&amp;#x2F;post&amp;#x2F;6863756420380196877#heading-12 省流版： 双缓存：为了解决画面撕裂；画面撕裂来自于只有一个buffer时，正在display的那一帧数据被后一帧的数据覆盖了 Vsync：系统在收到VSync pulse（Vsync脉冲"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/2021/04/01/ScreenDraw/%E4%BB%8EonCreate%E5%88%B0%E9%A1%B5%E9%9D%A2%E7%BB%98%E5%88%B6-2660260.jpg"><meta property="og:image" content="http://example.com/2021/04/01/ScreenDraw/b09c132ce9d040fc9520ea01712f66a9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"><meta property="og:image" content="http://example.com/2021/04/01/ScreenDraw/20200819205135422.png"><meta property="og:image" content="http://example.com/2021/04/01/ScreenDraw/20200819212951194.png"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69954651150d4452b97c2533fc70fd1a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"><meta property="og:image" content="http://example.com/2021/04/01/ScreenDraw/image-20210410163432028.png"><meta property="og:image" content="http://example.com/2021/04/01/ScreenDraw/15722752299458.jpg"><meta property="og:image" content="http://example.com/2021/04/01/ScreenDraw/89eiavs3dv.png"><meta property="og:image" content="http://example.com/2021/04/01/ScreenDraw/ScreenDraw//image-20241210161542940.png"><meta property="og:image" content="http://example.com/2021/04/01/ScreenDraw/36126-d3eda64685be407d.png"><meta property="article:published_time" content="2021-04-01T07:44:13.000Z"><meta property="article:modified_time" content="2024-12-10T08:58:53.304Z"><meta property="article:author" content="White Crow"><meta property="article:tag" content="CoreProcess"><meta property="article:tag" content="Core"><meta property="article:tag" content="Graphic"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2021/04/01/ScreenDraw/%E4%BB%8EonCreate%E5%88%B0%E9%A1%B5%E9%9D%A2%E7%BB%98%E5%88%B6-2660260.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/04/01/ScreenDraw/"},"headline":"ScreenDraw","image":["http://example.com/2021/04/01/ScreenDraw/%E4%BB%8EonCreate%E5%88%B0%E9%A1%B5%E9%9D%A2%E7%BB%98%E5%88%B6-2660260.jpg","http://example.com/2021/04/01/ScreenDraw/20200819205135422.png","http://example.com/2021/04/01/ScreenDraw/20200819212951194.png","http://example.com/2021/04/01/ScreenDraw/image-20210410163432028.png","http://example.com/2021/04/01/ScreenDraw/15722752299458.jpg","http://example.com/2021/04/01/ScreenDraw/89eiavs3dv.png","http://example.com/2021/04/01/ScreenDraw/ScreenDraw//image-20241210161542940.png","http://example.com/2021/04/01/ScreenDraw/36126-d3eda64685be407d.png"],"datePublished":"2021-04-01T07:44:13.000Z","dateModified":"2024-12-10T08:58:53.304Z","author":{"@type":"Person","name":"white crow"},"publisher":{"@type":"Organization","name":"Crow's Sky","logo":{"@type":"ImageObject","url":"http://example.com/img/avatarCircle.png"}},"description":"当手指点击了桌面的App图标时发生了什么 - ProcessOn Android 屏幕刷新机制主要参考 https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;6863756420380196877#heading-12 省流版： 双缓存：为了解决画面撕裂；画面撕裂来自于只有一个buffer时，正在display的那一帧数据被后一帧的数据覆盖了 Vsync：系统在收到VSync pulse（Vsync脉冲"}</script><link rel="canonical" href="http://example.com/2021/04/01/ScreenDraw/"><link rel="icon" href="/img/avatarCircle.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/WhileCrow"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-10-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-04-01T07:44:13.000Z" title="4/1/2021, 3:44:13 PM">2021-04-01</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-12-10T08:58:53.304Z" title="12/10/2024, 4:58:53 PM">2024-12-10</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a><span> / </span><a class="link-muted" href="/categories/Android/Framework/">Framework</a></span><span class="level-item">26 minutes read (About 3920 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">ScreenDraw</h1><div class="content"><p><img src="/2021/04/01/ScreenDraw/%E4%BB%8EonCreate%E5%88%B0%E9%A1%B5%E9%9D%A2%E7%BB%98%E5%88%B6-2660260.jpg" alt="从onCreate到页面绘制"></p>
<p><a target="_blank" rel="noopener" href="https://www.processon.com/diagraming/61e7d27b7d9c0806a8b8fd93">当手指点击了桌面的App图标时发生了什么 - ProcessOn</a></p>
<h1 id="Android-屏幕刷新机制"><a href="#Android-屏幕刷新机制" class="headerlink" title="Android 屏幕刷新机制"></a>Android 屏幕刷新机制</h1><p>主要参考 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6863756420380196877#heading-12">https://juejin.cn/post/6863756420380196877#heading-12</a></p>
<p>省流版：</p>
<p><strong>双缓存：</strong>为了解决画面撕裂；画面撕裂来自于只有一个buffer时，正在display的那一帧数据被后一帧的数据覆盖了</p>
<p><strong>Vsync：</strong>系统在收到VSync pulse（Vsync脉冲）后，将马上开始下一帧的渲染，（CPU开始计算数据）。</p>
<p><strong>三缓冲</strong>：当<u>显示器正在写入FrameBuffer</u>同时<u>GPU也正在写入BackBuffer</u>时，下一次渲染开始了，此时CPU可以使用新增的GraphicBuffer进行计算。减少了Jank。（更多缓冲需要耗费更大的内存）</p>
<p><strong>ChoreoGrapher机制：</strong>规定了数据计算开始（measure、layout、draw）的时机（vsync信号），使计算到渲染图像数据能有一个完整的16.6ms：更新ui（request()/invalidate()）后编舞者注册vsync信号回调，在下一个vsync信号到时候立刻进行view的测量布局绘制</p>
<span id="more"></span>



<h2 id="一、缓冲和Vsync"><a href="#一、缓冲和Vsync" class="headerlink" title="一、缓冲和Vsync"></a>一、缓冲和Vsync</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6863756420380196877">https://juejin.cn/post/6863756420380196877</a></p>
<h3 id="1、单缓冲，tearing"><a href="#1、单缓冲，tearing" class="headerlink" title="1、单缓冲，tearing"></a>1、单缓冲，tearing</h3><p><img src="/2021/04/01/ScreenDraw/b09c132ce9d040fc9520ea01712f66a9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图像撕裂.png"></p>
<p>由于Gpu跟显示器使用同一个缓冲，导致可能屏幕扫描刷新时，可能读取到的不是同一帧里的图像数据，造成画面撕裂</p>
<h3 id="2、↓-双缓冲-↓"><a href="#2、↓-双缓冲-↓" class="headerlink" title="2、↓  双缓冲 ↓"></a>2、↓  双缓冲 ↓</h3><p>双缓冲是为了解决“由于Gpu跟显示器使用同一个缓冲，导致可能屏幕扫描刷新时，可能读取到的不是同一帧里的图像数据，造成画面撕裂”，让绘制和显示器拥有各自的buffer：</p>
<p>GPU 的图像数据写入到 Back Buffer，而显示器使用 Frame Buffer，当屏幕刷新时，Frame Buffer 并不会发生变化，当Back buffer准备就绪后，它们才进行<strong>地址交换</strong>。（缓存区交换被称为<code>BufferSwap</code>，<strong>帧传递</strong>。）</p>
<p>上面说到的Back Buffer 跟 Frame Buffer地址交换，时间点选择在了 Back buffer完整写入之后，在之后屏幕扫描完一个屏幕（从左到右，从上到下逐行显示每一个像素点，整个过程以60Hz屏为例是16.6ms）后，设备从右下回到左上的这个时间区间（即VBI VerticalBlackingInterval垂直同步间隙），而垂直同步脉冲（vertical sync pulse）就是在VBI时期发出的，脉冲发出时间时立即进行<strong>帧传递</strong>。</p>
<p>总结下就是：<strong>垂直同步脉冲是在屏幕扫描到右下最后一个像素后，重置回到左上的这个时间空隙发出的，所以每16.6ms（60HZ屏）发出一个脉冲信号。收到脉冲信号后，如果GPU的缓冲已经准备好了，就会立即进行帧传递。</strong></p>
<p>但是，<strong>双缓存只是规定了图像数据数据写入BackBuffer完成后，FrameBuffer与BackBuffer交换的时机，而数据开始计算时间的不确定，则导致了下一帧中，CPU/GPU未能在帧开始的时候就进行计算，进而导致帧结束时CPU/GPU工作未完成（明明CPU/GPU工作时长小于16.6ms），却还是造成掉帧（jank）。</strong></p>
<p><img src="/2021/04/01/ScreenDraw/20200819205135422.png"></p>
<h3 id="3、↓-三缓冲-Vsync-↓"><a href="#3、↓-三缓冲-Vsync-↓" class="headerlink" title="3、↓ 三缓冲 + Vsync ↓"></a>3、↓ 三缓冲 + Vsync ↓</h3><p>Android 4.x版本的黄油工程 project butter引入三缓冲与Vsync，提升了性能，促使了Android的普及</p>
<h4 id="3-1、-VSync-机制"><a href="#3-1、-VSync-机制" class="headerlink" title="3.1、 VSync 机制"></a>3.1、 VSync 机制</h4><p><strong>Android实现即下述第二节choreographer机制</strong></p>
<p>系统在收到VSync pulse（Vsync脉冲）后，将马上开始下一帧的渲染。即一旦收到VSync通知（16ms触发一次），CPU和GPU 才立刻开始计算然后把数据写入buffer。VSync同步使得CPU/GPU充分利用了16.6ms时间，减少jank</p>
<p><img src="/2021/04/01/ScreenDraw/20200819212951194.png"></p>
<h4 id="3-2、-三缓冲"><a href="#3-2、-三缓冲" class="headerlink" title="3.2、 三缓冲"></a>3.2、 三缓冲</h4><p> <strong>CPU、GPU、显示器都能尽快拿到 buffer，减少不必要的等待</strong>。如果显示器和 GPU 现在都使用着一个 buffer，如果下一次渲染开始了，因为还有一个 buffer 可以用于 CPU 数据的写入，所以可以马上开始下一帧数据的渲染。</p>
<p>三缓冲就是在双缓冲机制基础上增加了一个 Graphic Buffer 缓冲区，这样可以最大限度的利用空闲时间，带来的坏处是多使用的一个 Graphic Buffer 所占用的内存。三缓冲有效利用了等待vysnc的时间，减少了jank，但是带来了延迟。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69954651150d4452b97c2533fc70fd1a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="vsync4.png"></p>
<h2 id="二、Choreographer机制-或称-“drawing-with-vysnc”"><a href="#二、Choreographer机制-或称-“drawing-with-vysnc”" class="headerlink" title="二、Choreographer机制 或称 “drawing with vysnc”"></a>二、Choreographer机制 或称 “drawing with vysnc”</h2><p><img src="/2021/04/01/ScreenDraw/image-20210410163432028.png" alt="image-20210410163432028"></p>
<p><img src="/2021/04/01/ScreenDraw/15722752299458.jpg" alt="img"></p>
<p>-&gt; requestLayout() / invalidate()  <strong>所有UI的变化都是走到ViewRootImpl的scheduleTraversals()方法。</strong></p>
<p>-&gt; scheduleTraversals()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        <span class="comment">// 保证同时间多次更改只会刷新一次，例如TextView连续两次setText()也只会走一次绘制流程</span></span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 添加同步屏障，保证 Vsync 到来立即执行绘制</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mTraversalRunnable 是Vsync信号回调后执行的Runnable 实例</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>mChoreographer.postCallback()  // 注册监听Vsync信号（只有注册了监听的Vsync才会回调执行）回调处理内容为<strong>mTraversalRunnable</strong>，事件类型为<strong>CALLBACK_TRAVERSAL</strong>（CALLBACK_INPUT输入事件、CALLBACK_ANIMATION动画、CALLBACK_INSETS_ANIMATION插入更新动画、CALLBACK_TRAVERSAL绘制、CALLBACK_COMMIT提交，五种类型顺序执行）</p>
<p>postCallbackDelayedInternal</p>
<ul>
<li>if (dueTime &lt;= now) ： 直接执行scheduleFrameLocked</li>
<li>else   ：  msg.setAsynchronous(true); 发送延迟到点后的异步消息执行scheduleFrameLocked</li>
</ul>
<p>-&gt; scheduleFrameLocked()</p>
<ul>
<li>根据 版本未开启VSYN（4.1以下）直接走doFrame</li>
<li>确认并切换到Choreographer的handler（异步消息）执行 scheduleVsyncLocked()</li>
</ul>
<p>-&gt; scheduleVsncLocked()</p>
<p>-&gt; scheduleVsync()</p>
<p>-&gt; nativeScheduleVsync(mReceiverPtr);</p>
<ul>
<li>注册VSYNC信号回调，只有注册监听的那一个Vsync信号才会接收回调最后在onVsync() </li>
</ul>
<p><strong>这里不应该为软件申请了Vsync信号，Vsync信号是由屏幕/显示设备发出的，无论choreographer是否监听都会在固定的时间间隔发出（60fps-&gt;16.6ms），View更新后由choreographer注册监听后才会对下一个Vsync信号回调回来后处理，走doCallbacks ，也就是最初由choreographer注册的回调mChoreographer.postCallback() -&gt; doTraversal() -&gt; 移除同步屏障并真正执行View的measure、layout、draw流程</strong></p>
<p><strong>所以每16ms都会发出Vsync信号，每16ms屏幕都在刷新，但不是每16ms都会走measure、layout、draw</strong></p>
<p>native层注册监听Vsync回调，DisplayEventReceiver::requestNextVsync()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_view_DisplayEventReceiver.cpp</span><br><span class="line">static void nativeScheduleVsync(JNIEnv* env, jclass clazz, jlong receiverPtr) &#123;</span><br><span class="line">    sp&lt;NativeDisplayEventReceiver&gt; receiver &#x3D; reinterpret_cast&lt;NativeDisplayEventReceiver*&gt;(receiverPtr);</span><br><span class="line">    status_t status &#x3D; receiver-&gt;scheduleVsync();</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; frameworks&#x2F;base&#x2F;libs&#x2F;androidfw&#x2F;DisplayEventDispatcher.cpp</span><br><span class="line">status_t DisplayEventDispatcher::scheduleVsync() &#123;</span><br><span class="line">    if (!mWaitingForVsync) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">        &#x2F;&#x2F; mReceiver 是 DisplayEventReceiver 实例</span><br><span class="line">        status_t status &#x3D; mReceiver.requestNextVsync();</span><br><span class="line">        mWaitingForVsync &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; frameworks&#x2F;native&#x2F;libs&#x2F;gui&#x2F;DisplayEventReceiver.cpp</span><br><span class="line">status_t DisplayEventReceiver::requestNextVsync() &#123;</span><br><span class="line">    if (mEventConnection !&#x3D; NULL) &#123;</span><br><span class="line">        &#x2F;&#x2F; 请求接收下一次Vsync信号的回调</span><br><span class="line">        mEventConnection-&gt;requestNextVsync();</span><br><span class="line">        return NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO_INIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>native Vsync信号回调回来了，由FrameDisplayEventReceiver的onVsync方法接收：</p>
<p>-&gt; onVsync()</p>
<p>-&gt;  doFrame()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> startNanos;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// no work to do</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    	<span class="comment">// 计算掉帧情况  frameTimeNanos是onVsync()的参数，即vsync信号开始时间，以frameTimeNanos为start_time，</span></span><br><span class="line">      <span class="comment">//以doFrame方法执行开始时间为end_time， start_time - end_time为帧延迟，以此 时间差/标准帧时间  计算掉帧情况</span></span><br><span class="line">      <span class="comment">//标准帧时间 = 1000000000 / 屏幕帧率  单位纳秒 （1纳秒=0.000 000 001秒 ）</span></span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">// 按类型顺序 执行任务</span></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;Choreographer#doFrame&quot;</span>);</span><br><span class="line">        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">    </span><br><span class="line">        mFrameInfo.markInputHandlingStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);     <span class="comment">//输入事件，即熟悉的事件分发体系</span></span><br><span class="line">    </span><br><span class="line">        mFrameInfo.markAnimationsStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);       <span class="comment">//动画</span></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos); <span class="comment">//动画 </span></span><br><span class="line">    </span><br><span class="line">        mFrameInfo.markPerformTraversalsStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);    <span class="comment">//测绘</span></span><br><span class="line">    </span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos); <span class="comment">//提交，处理绘制后的帧更新</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        AnimationUtils.unlockAnimationClock();</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doFrame()<br>-&gt; 按callbacktype依次执行将doCallbacks()，即执行doCallbacks(0、1、2、3、4,? frameTimeNanos)</p>
<p>doCallbacks(int callbackType, long frameTimeNanos)<br>-&gt; 根据传入的callbackType从mCallbackQuesu中取出对应的队列，执行队列中到达执行时间的CallbackRecord</p>
<p>即依次 将 输入队列、 动画队列、绘制队列、提交队列 中所有的到达执行时间的 元素（CallbackRecord）<br>执行其中的action（viewRootImpl 中mChoreographer.mpostCallback时传递的mTraversalsRunnable）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doCallbacks</span><span class="params">(<span class="keyword">int</span> callbackType, <span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">      CallbackRecord callbacks;</span><br><span class="line">      <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">      <span class="comment">// 根据指定的类型CallbackkQueue中查找到达执行时间的CallbackRecord</span></span><br><span class="line">      callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now / TimeUtils.NANOS_PER_MS);</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 迭代执行队列所有任务</span></span><br><span class="line">          <span class="keyword">for</span> (CallbackRecord c = callbacks; c != <span class="keyword">null</span>; c = c.next) &#123;</span><br><span class="line">              <span class="comment">// 回调CallbackRecord的run，其内部回调Callback的run</span></span><br><span class="line">              c.run(frameTimeNanos);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                 <span class="comment">//...</span></span><br><span class="line">                 <span class="comment">//递归回收CallbackRecord</span></span><br><span class="line">                 <span class="comment">//...</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>
<p>callbacktype分为5种（实际上是<strong>四种</strong>，新版本Android合并后只剩四种事件：<strong>输入、动画、遍历traversal、提交</strong>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入事件，首先执行 public static final int CALLBACK_INPUT = 0; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动画合并成一种</span></span><br><span class="line"><span class="comment">//动画，第二执行 public static final int CALLBACK_ANIMATION = 1;</span></span><br><span class="line"><span class="comment">//插入更新的动画，第三执行 public static final int CALLBACK_INSETS_ANIMATION = 2; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制，第四执行 public static final int CALLBACK_TRAVERSAL = 3; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提交，最后执行， public static final int CALLBACK_COMMIT = 4;</span></span><br></pre></td></tr></table></figure>
<p>优先级的高低和处理顺序有关，每当收到 VSYNC 信号时，Choreographer 将首先处理 INPUT 类型的任务，然后是 ANIMATION 类型，最后才是 TRAVERSAL 类型。</p>
<p>-&gt;  doCallbacks()</p>
<p>-&gt;  mTraversalRunnable</p>
<p>-&gt;  doTraversal()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 移除同步屏障</span></span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        <span class="comment">// 真正执行View的measure，layout，draw流程</span></span><br><span class="line">        performTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="附录-Choreographer部分源码（Android4-1新增）"><a href="#附录-Choreographer部分源码（Android4-1新增）" class="headerlink" title="附录 Choreographer部分源码（Android4.1新增）"></a>附录 Choreographer部分源码（Android4.1新增）</h3><p>Choreographer 是线程单例的（ThreadLocal实现），而且必须要和一个 Looper 绑定，因为其内部有一个 Handler 需要和 Looper 绑定，一般是 App 主线程的 Looper 绑定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Choreographer.class  </span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//postCallback(int callbackType, Object action, Object token) 会一步步走到postCallbackDelayedInternal(delayMills = 0)</span></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType, Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">	    	<span class="comment">// 当前时间</span></span><br><span class="line">	        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">	        <span class="comment">// 加上延迟时间</span></span><br><span class="line">	        <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">	        <span class="comment">//取对应类型的CallbackQueue添加任务</span></span><br><span class="line">	        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line">	</span><br><span class="line">	        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">	        	<span class="comment">//立即执行</span></span><br><span class="line">	            scheduleFrameLocked(now);</span><br><span class="line">	        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	        	<span class="comment">//延迟运行，最终也会走到scheduleFrameLocked()</span></span><br><span class="line">	            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">	            msg.arg1 = callbackType;</span><br><span class="line">	            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">	            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleFrameLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">	        mFrameScheduled = <span class="keyword">true</span>;</span><br><span class="line">	        <span class="comment">//开启了VSYNC</span></span><br><span class="line">	        <span class="keyword">if</span> (USE_VSYNC) &#123;</span><br><span class="line">	            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">	                Log.d(TAG, <span class="string">&quot;Scheduling next frame on vsync.&quot;</span>);</span><br><span class="line">	            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//当前执行的线程，是否是mLooper所在线程</span></span><br><span class="line">            <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">            	<span class="comment">//申请 VSYNC 信号</span></span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">// 若不在，就用mHandler发送消息到原线程，最后还是调用scheduleVsyncLocked方法</span></span><br><span class="line">                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">                msg.setAsynchronous(<span class="keyword">true</span>);<span class="comment">//异步</span></span><br><span class="line">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">// 如果未开启VSYNC则直接doFrame方法（4.1后默认开启）</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> nextFrameTime = Math.max(</span><br><span class="line">                    mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;Scheduling next frame in &quot;</span> + (nextFrameTime - now) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);<span class="comment">//异步</span></span><br><span class="line">            mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="三、invalidate-requestLayout流程"><a href="#三、invalidate-requestLayout流程" class="headerlink" title="三、invalidate/requestLayout流程"></a>三、invalidate/requestLayout流程</h2><h3 id="invalidate-postInvalidat-requestLayout简要区别"><a href="#invalidate-postInvalidat-requestLayout简要区别" class="headerlink" title="invalidate/postInvalidat/requestLayout简要区别:"></a>invalidate/postInvalidat/requestLayout简要区别:</h3><ol>
<li>invalidate只会调onDraw方法且必须在UI线程中调用</li>
<li>postInvalidate只会调onDraw方法，可在非UI线程中回调</li>
<li>requestLayout会调onMeasure、onLayout和onDraw(特定条件下)方法</li>
</ol>
<h3 id="invalidate"><a href="#invalidate" class="headerlink" title="invalidate"></a>invalidate</h3><p>调用 View.invalidate() 方法后会逐级往上调用父 View 的相关方法，最终在 Choreographer 的控制下调用 <strong>ViewRootImpl.performTraversals</strong>() 方法。<strong>只有满足 可见性、尺寸发生变化时 等条件才会执行 measure 和 layout 流程，否则只执行 draw 流程</strong>，draw 流程的执行过程与是否开启硬件加速有关：</p>
<p>关闭硬件加速则<strong>从 DecorView 开始往下的所有子 View 都会被重新绘制</strong>。<br>开启硬件加速则<strong>只有调用 invalidate 方法的 View 才会重新绘制。</strong></p>
<h3 id="requestLayout"><a href="#requestLayout" class="headerlink" title="requestLayout"></a>requestLayout</h3><p><strong>调用 View.requestLayout 方法后，会递归到顶地逐级调用父View的requestLayout，标记“需要layout（mLayoutRequested）”，之后在下一帧到来时根据标记对这些View自顶向下地进行measure，layout。</strong></p>
<p><strong>//ps:也就是调用requestLayout的view到DecorView的这段树会被重新测量布局（整棵树，从顶到叶子结点）</strong></p>
<p>特定情况下也会调用onDraw，但一般需要手动调用invalidate保证当前View重绘</p>
<p>如图：</p>
<p><img src="/2021/04/01/ScreenDraw/89eiavs3dv.png" alt="img"></p>
<p><strong>「假设调用H.requestLayout()，会触发哪些View的requestLayout方法？」</strong></p>
<p><strong>「答：会依次触发H.requestLayout() -&gt; C.requestLayout() -&gt; A.requestLayout() -&gt; …省略一些View -&gt; ViewRootImpl.requestLayout()」</strong></p>
<p><strong>「之后再调用 H.onMeasure &amp;&amp; I.onMeasure -&gt; C.onMeasure -&gt; A.onMeasure， H.onLayout……」</strong></p>
<p>小结：因此，当只需要进行重绘时可以使用 invalidate 方法，如果需要重新测量和布局则可以使用 requestLayout 方法，而 requestLayout 方法不一定会重绘，因此如果要进行重绘可以再手动调用 invalidate 方法。</p>
<p><img src="ScreenDraw//image-20241210161542940.png" alt="image-20241210161542940"></p>
<h3 id="子线程更新UI"><a href="#子线程更新UI" class="headerlink" title="子线程更新UI"></a>子线程更新UI</h3><p>1、为啥会崩：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">-&gt; 视图更新操作invalidata</span><br><span class="line">-&gt; View.invalidate </span><br><span class="line">-&gt; View.invalidateInternal </span><br><span class="line">-&gt; ViewGroup.invalidateChild <span class="comment">//正常情况View上一层级为ViewGroup，如果上一层直接时ViewRootImpl则没有这层</span></span><br><span class="line">-&gt; ViewParent.invalidateChildInParent <span class="comment">//这里会不断do while去取上一个结点的mParent，从ViewGroup一直到ViewRootImpl为止</span></span><br><span class="line">-&gt; ViewRootImpl.invalidateChildInParent <span class="comment">//DecorView的mParent是ViewRootImpl</span></span><br><span class="line">-&gt; ViewRootImpl.checkThread <span class="comment">//在这里执行checkThread，如果非ViewRootImpl创建线程则抛出异常</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">ViewRootImpl.class</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">final</span> Thread mThread;</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">    mcontext = context;</span><br><span class="line">    mWindowSession = WindowMangerGlobal.getWindowSession();</span><br><span class="line">    ...</span><br><span class="line">	mThread = Thread.currentThread();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">	...</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Override</span> <span class="comment">//override from ViewParent interface</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewParent <span class="title">invalidateChildInParent</span><span class="params">(<span class="keyword">int</span>[] location, Rect dirty)</span> </span>&#123;</span><br><span class="line">    checkThread();</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_DRAW) Log.v(mTag, <span class="string">&quot;Invalidate child: &quot;</span> + dirty);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dirty == <span class="keyword">null</span>) &#123;</span><br><span class="line">        invalidate();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dirty.isEmpty() &amp;&amp; !mIsAnimating) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mCurScrollY != <span class="number">0</span> || mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mTempRect.set(dirty);</span><br><span class="line">        dirty = mTempRect;</span><br><span class="line">        <span class="keyword">if</span> (mCurScrollY != <span class="number">0</span>) &#123;</span><br><span class="line">            dirty.offset(<span class="number">0</span>, -mCurScrollY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTranslator.translateRectInAppWindowToScreen(dirty);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo.mScalingRequired) &#123;</span><br><span class="line">            dirty.inset(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    invalidateRectOnScreen(dirty);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-&gt; 视图更新操作requestLayout</span><br><span class="line">-&gt; mParent.reqeustLayout  <span class="comment">// 不断向父控件(mparent即ViewParent接口，ViewGroup与ViewRootImpl都实现了该接口,可做为view的parent)请求布局，最后调用到ViewRootImpl的requestLayout</span></span><br><span class="line">-&gt; ViewRootImpl.requestLayout</span><br><span class="line"></span><br><span class="line">ViewRootImpl.class</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">            checkThread();</span><br><span class="line">            mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(</span><br><span class="line">                <span class="string">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、子线程更新UI怎么不崩：</p>
<ul>
<li> 子线程在ViewRootImpl初始化之前（handleResumeActivity之后初始化）</li>
<li> <strong>ViewRootImpl</strong>创建线程 只需要与 <strong>View的更新线程</strong> 是同一个就行（初始化在子线程，更新在主线程一样会崩）</li>
</ul>
<h3 id="View-post与getHandler-post"><a href="#View-post与getHandler-post" class="headerlink" title="View.post与getHandler.post"></a>View.post与getHandler.post</h3><p>view.post在内部类AttachInfo未实例化之前是会将action通过getRunQueue().post(action)缓存起来，延后到handleResumeActivity中初始化ViewRootImp时调用setView时，会从顶向下调用View/ViewGroup的dispatchAttachToWindow方法，在此方法内缓存的action会被执行</p>
<p>Activity的ViewRootImpl在onResume方法中创建的，具体见下</p>
<h2 id="四、同步消息屏障"><a href="#四、同步消息屏障" class="headerlink" title="四、同步消息屏障"></a>四、同步消息屏障</h2><p>在invalidate/requestLayout执行时，最后都会走向ViewRootImpl的scheduleTraversals()方法中，这个方法中会调用<code>mHandler.getLooper().getQueue().postSyncBarrier();</code>，本质上是往主线程Looper中post一个target==null的消息，作为同步消息屏障，过滤掉所有同步的消息，只执行异步消息。</p>
<p>同时Choreographer注册Vsync回调，下一个Vsync消息发出后回调回来移除同步消息屏障并执行 performTraversals(也就是measure、layout、draw)</p>
<h2 id="五、ChoreoGrapher什么时候初始化"><a href="#五、ChoreoGrapher什么时候初始化" class="headerlink" title="五、ChoreoGrapher什么时候初始化"></a>五、ChoreoGrapher什么时候初始化</h2><p>Activity启动后，执行完ActivitityThread.performResumeActivity()，再执行WindowManagerImpl.addView()，在其内部会执行ViewRootImpl的初始化。Choreographer的初始化就是在ViewRootImpl的构造方法中执行的。</p>
<p>ViewRootImpl的关键全局变量除了Choreographer（掌管绘制相关）外，还有attachInfo（）</p>
<p><img src="/2021/04/01/ScreenDraw/36126-d3eda64685be407d.png" alt="img"></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>ScreenDraw</p><p><a href="http://example.com/2021/04/01/ScreenDraw/">http://example.com/2021/04/01/ScreenDraw/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>white crow</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2021-04-01</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-12-10</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/CoreProcess/">CoreProcess</a><a class="link-muted mr-2" rel="tag" href="/tags/Core/">Core</a><a class="link-muted mr-2" rel="tag" href="/tags/Graphic/">Graphic</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/04/01/AndroidBuild/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Android Build</span></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Android-屏幕刷新机制"><span class="level-left"><span class="level-item">1</span><span class="level-item">Android 屏幕刷新机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#一、缓冲和Vsync"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">一、缓冲和Vsync</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、单缓冲，tearing"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">1、单缓冲，tearing</span></span></a></li><li><a class="level is-mobile" href="#2、↓-双缓冲-↓"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">2、↓  双缓冲 ↓</span></span></a></li><li><a class="level is-mobile" href="#3、↓-三缓冲-Vsync-↓"><span class="level-left"><span class="level-item">1.1.3</span><span class="level-item">3、↓ 三缓冲 + Vsync ↓</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1、-VSync-机制"><span class="level-left"><span class="level-item">1.1.3.1</span><span class="level-item">3.1、 VSync 机制</span></span></a></li><li><a class="level is-mobile" href="#3-2、-三缓冲"><span class="level-left"><span class="level-item">1.1.3.2</span><span class="level-item">3.2、 三缓冲</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#二、Choreographer机制-或称-“drawing-with-vysnc”"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">二、Choreographer机制 或称 “drawing with vysnc”</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#附录-Choreographer部分源码（Android4-1新增）"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">附录 Choreographer部分源码（Android4.1新增）</span></span></a></li></ul></li><li><a class="level is-mobile" href="#三、invalidate-requestLayout流程"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">三、invalidate/requestLayout流程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#invalidate-postInvalidat-requestLayout简要区别"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">invalidate/postInvalidat/requestLayout简要区别:</span></span></a></li><li><a class="level is-mobile" href="#invalidate"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">invalidate</span></span></a></li><li><a class="level is-mobile" href="#requestLayout"><span class="level-left"><span class="level-item">1.3.3</span><span class="level-item">requestLayout</span></span></a></li><li><a class="level is-mobile" href="#子线程更新UI"><span class="level-left"><span class="level-item">1.3.4</span><span class="level-item">子线程更新UI</span></span></a></li><li><a class="level is-mobile" href="#View-post与getHandler-post"><span class="level-left"><span class="level-item">1.3.5</span><span class="level-item">View.post与getHandler.post</span></span></a></li></ul></li><li><a class="level is-mobile" href="#四、同步消息屏障"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">四、同步消息屏障</span></span></a></li><li><a class="level is-mobile" href="#五、ChoreoGrapher什么时候初始化"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">五、ChoreoGrapher什么时候初始化</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatarPng.png" alt="White Crow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">White Crow</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">81</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">4</p></a></div></div></nav></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a><p class="is-size-7"><span>&copy; 2025 white crow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://github.com/WhileCrow"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>