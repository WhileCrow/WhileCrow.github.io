<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>HashMap - Crow&#039;s Sky</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Crow&#039;s Sky"><meta name="msapplication-TileImage" content="/img/avatarCircle.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Crow&#039;s Sky"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="常见Map类简述：HashMap是非线程安全的，如需要线程安全的哈希隐射类，应使用实现了分段锁（1.8）的ConcurrentHashMap，而不建议使用遗留类HashTable（HashTable实现线程安全是依靠用synchronized关键字修饰put&amp;#x2F;get方法，效率较低）。 如果需要保存记录插入的顺序，可使用LinkHashMap()，其内部实现了一个双向链表，即每个节点本身记录了前后节"><meta property="og:type" content="blog"><meta property="og:title" content="HashMap"><meta property="og:url" content="http://example.com/2021/11/01/HashMap/"><meta property="og:site_name" content="Crow&#039;s Sky"><meta property="og:description" content="常见Map类简述：HashMap是非线程安全的，如需要线程安全的哈希隐射类，应使用实现了分段锁（1.8）的ConcurrentHashMap，而不建议使用遗留类HashTable（HashTable实现线程安全是依靠用synchronized关键字修饰put&amp;#x2F;get方法，效率较低）。 如果需要保存记录插入的顺序，可使用LinkHashMap()，其内部实现了一个双向链表，即每个节点本身记录了前后节"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://user-images.githubusercontent.com/26061465/139463032-e5d86456-1b43-4483-826e-3dc873e9a18f.png"><meta property="og:image" content="http://example.com/2021/11/01/HashMap/45205ec2.png"><meta property="og:image" content="https://user-images.githubusercontent.com/26061465/139464694-a2d01f2e-2a3e-420f-892e-a128eeb5e4e0.png"><meta property="og:image" content="http://example.com/2021/11/01/HashMap/3cc9813a.png"><meta property="og:image" content="http://example.com/2021/11/01/HashMap/v2-da2df9ad67181daa328bb09515c1e1c8_1440w.png"><meta property="og:image" content="http://example.com/2021/11/01/HashMap/v2-ac1017eb1b83ce5505bfc032ffbcc29a_1440w.jpg"><meta property="article:published_time" content="2021-11-01T12:20:27.000Z"><meta property="article:modified_time" content="2024-05-10T06:53:55.353Z"><meta property="article:author" content="White Crow"><meta property="article:tag" content="Core"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://user-images.githubusercontent.com/26061465/139463032-e5d86456-1b43-4483-826e-3dc873e9a18f.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/11/01/HashMap/"},"headline":"HashMap","image":["https://user-images.githubusercontent.com/26061465/139463032-e5d86456-1b43-4483-826e-3dc873e9a18f.png","http://example.com/2021/11/01/HashMap/45205ec2.png","https://user-images.githubusercontent.com/26061465/139464694-a2d01f2e-2a3e-420f-892e-a128eeb5e4e0.png","http://example.com/2021/11/01/HashMap/3cc9813a.png","http://example.com/2021/11/01/HashMap/v2-da2df9ad67181daa328bb09515c1e1c8_1440w.png","http://example.com/2021/11/01/HashMap/v2-ac1017eb1b83ce5505bfc032ffbcc29a_1440w.jpg"],"datePublished":"2021-11-01T12:20:27.000Z","dateModified":"2024-05-10T06:53:55.353Z","author":{"@type":"Person","name":"white crow"},"publisher":{"@type":"Organization","name":"Crow's Sky","logo":{"@type":"ImageObject","url":"http://example.com/img/avatarCircle.png"}},"description":"常见Map类简述：HashMap是非线程安全的，如需要线程安全的哈希隐射类，应使用实现了分段锁（1.8）的ConcurrentHashMap，而不建议使用遗留类HashTable（HashTable实现线程安全是依靠用synchronized关键字修饰put&#x2F;get方法，效率较低）。 如果需要保存记录插入的顺序，可使用LinkHashMap()，其内部实现了一个双向链表，即每个节点本身记录了前后节"}</script><link rel="canonical" href="http://example.com/2021/11/01/HashMap/"><link rel="icon" href="/img/avatarCircle.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/WhileCrow"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-10-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-11-01T12:20:27.000Z" title="11/1/2021, 8:20:27 PM">2021-11-01</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-05-10T06:53:55.353Z" title="5/10/2024, 2:53:55 PM">2024-05-10</time></span><span class="level-item"><a class="link-muted" href="/categories/Common/">Common</a><span> / </span><a class="link-muted" href="/categories/Common/JavaBasic/">JavaBasic</a></span><span class="level-item">29 minutes read (About 4375 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">HashMap</h1><div class="content"><h2 id="常见Map类"><a href="#常见Map类" class="headerlink" title="常见Map类"></a>常见Map类</h2><p>简述：HashMap是非线程安全的，如需要线程安全的哈希隐射类，应使用实现了分段锁（1.8）的ConcurrentHashMap，而不建议使用遗留类HashTable（HashTable实现线程安全是依靠用synchronized关键字修饰put/get方法，效率较低）。</p>
<p>如果需要保存记录插入的顺序，可使用LinkHashMap()，其内部实现了一个双向链表，即每个节点本身记录了前后节点的引用。(btw:MessageQueue是单链表)</p>
<span id="more"></span>

<h3 id="1-HashMap："><a href="#1-HashMap：" class="headerlink" title="(1) HashMap："></a>(1) HashMap：</h3><p>它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以使用<strong>ConcurrentHashMap（synchronizedMap与HashTable都因为其实现的线程安全依靠全表锁导致性能较差，故不建议）</strong>。</p>
<h3 id="2-不推荐的线程安全Map："><a href="#2-不推荐的线程安全Map：" class="headerlink" title="(2) 不推荐的线程安全Map："></a>(2) 不推荐的线程安全Map：</h3><h4 id="2-1-HashTable"><a href="#2-1-HashTable" class="headerlink" title="(2.1)HashTable"></a>(2.1)HashTable</h4><p>​    Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，<strong>HashTable的get/put方法都被synchronized关键字修饰，说明它们是方法级别阻塞的，它们占用共享资源锁，所以导致同时只能一个线程操作get或者put，而且get/put操作不能同时执行，所以这种同步的集合效率非常低，一般不建议使用这个集合。</strong></p>
<h4 id="2-2-SynchronizedMap"><a href="#2-2-SynchronizedMap" class="headerlink" title="(2.2)SynchronizedMap"></a>(2.2)SynchronizedMap</h4><p>​    <strong>Collections.synchronizedMap</strong>类似，如果传入的是 HashMap 对象，其实也是对 HashMap 做的方法做了一层包装，里面使用对象锁来保证多线程场景下操作安全，<strong>本质也是对 HashMap 进行全表锁！</strong>，性能低下</p>
<h3 id="3-ConcurrentHashMap"><a href="#3-ConcurrentHashMap" class="headerlink" title="(3) ConcurrentHashMap:"></a>(3) ConcurrentHashMap:</h3><p>这个也是最推荐使用的线程安全的Map，也是实现方式最复杂的一个集合，每个版本的实现方式也不一样，在jdk8之前是使用分段加锁的一个方式，分成16个segment，每次只加锁其中一个segment，而在jdk8加入了红黑树和CAS算法后，又改用synchronized锁住哈希数组的头结点作为线程安全来实现。</p>
<h3 id="4-LinkedHashMap："><a href="#4-LinkedHashMap：" class="headerlink" title="(4) LinkedHashMap："></a>(4) LinkedHashMap：</h3><p>LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p>
<h3 id="5-TreeMap："><a href="#5-TreeMap：" class="headerlink" title="(5) TreeMap："></a>(5) TreeMap：</h3><p>TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p>
<p>对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。</p>
<!-- more -->

<h2 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h2><p>通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。</p>
<p><img src="https://user-images.githubusercontent.com/26061465/139463032-e5d86456-1b43-4483-826e-3dc873e9a18f.png" alt="image"></p>
<h3 id="1-存储结构："><a href="#1-存储结构：" class="headerlink" title="(1) 存储结构："></a>(1) 存储结构：</h3><p>从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。我们来看Node[JDK1.8]是何物。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;    &#x2F;&#x2F;用来定位数组索引位置</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   &#x2F;&#x2F;链表的下一个node</span><br><span class="line"></span><br><span class="line">        Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        public final K getKey()&#123; ... &#125;</span><br><span class="line">        public final V getValue() &#123; ... &#125;</span><br><span class="line">        public final String toString() &#123; ... &#125;</span><br><span class="line">        public final int hashCode() &#123; ... &#125;</span><br><span class="line">        public final V setValue(V newValue) &#123; ... &#125;</span><br><span class="line">        public final boolean equals(Object o) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。</p>
<h3 id="2-哈希冲突："><a href="#2-哈希冲突：" class="headerlink" title="(2) 哈希冲突："></a>(2) 哈希冲突：</h3><p>HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题<br>  Java中HashMap采用了**链地址法(拉链法)**。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。（1.8之后又加入了红黑树）</p>
<h3 id="3-位置确定："><a href="#3-位置确定：" class="headerlink" title="(3)位置确定："></a>(3)位置确定：</h3><p><strong>hashCode高低16位相异或后跟n-1相与</strong></p>
<p>简述：<strong>取Key的32位hashCode值进行低16位与高16位异或运算，并将运算结果取模(n-1)。</strong></p>
<p><strong>这里插一句：由于index是取模(n-1)的，所以JDK1.8后 n -&gt; 2n 扩容时无需重新hash，只需要把多出来的一个bit作为是否移动到新开辟空间的标记即可</strong></p>
<p>分两步：</p>
<h4 id="第一步：hashCode高低16位异或"><a href="#第一步：hashCode高低16位异或" class="headerlink" title="第一步：hashCode高低16位异或"></a>第一步：<strong>hashCode高低16位异或</strong></h4><p>hash = (hashCode &gt;&gt;&gt; 16) ^ hashcode)。 这一步得出<strong>低16位与高16位的异或</strong>结果，也就是为了高低16位都能参与到后一步的取模运算。</p>
<h4 id="第二步：与n-1相与"><a href="#第二步：与n-1相与" class="headerlink" title="第二步：与n-1相与"></a>第二步：<strong>与n-1相与</strong></h4><p><strong>hash &amp; (n - 1)</strong></p>
<p><img src="/2021/11/01/HashMap/45205ec2.png" alt="img"></p>
<h3 id="4-扩容"><a href="#4-扩容" class="headerlink" title="(4) 扩容"></a>(4) 扩容</h3><p>  扩容时机：<br>  put插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。每次扩容的容量都是之前容量的2倍。最大(2^30)。</p>
<p>  初始值：</p>
<ul>
<li><p>capacity 即容量，默认16。 </p>
</li>
<li><p>loadFactor 加载因子，默认是0.75 threshold 阈值。</p>
</li>
<li><p>threshhold阈值=容量*加载因子。默认12。当元素数量超过阈值时便会触发扩容。</p>
</li>
<li><p>如果某个桶内的元素超过<strong>8</strong>个，则会将链表转化成红黑树，加快数据查询效率。</p>
</li>
<li><p>如果remove的过程中，桶内的元素低于<strong>6</strong>个，红黑树又会转化成链表</p>
</li>
</ul>
<p>  扩容机制：</p>
<h4 id="简述："><a href="#简述：" class="headerlink" title="简述："></a>简述：</h4><p>  <strong>JDK1.7：创建一个新的两倍大小的数组，将原数组用头插法的方式将所有节点rehash后插入新数组，故链表顺序会相反。</strong></p>
<p>  <strong>JDK1.8：创建一个新的两倍大小的数组，每一个元素通过hash转换坐标的方法计算后，最高位是0则坐标不变，最高位是1则坐标变为“原长度+原坐标”。迁移元素时是正序的，不会出现链表转置的发生。</strong>，</p>
<h4 id="详解："><a href="#详解：" class="headerlink" title="详解："></a>详解：</h4><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p>
<p>我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void resize(int newCapacity) &#123;   &#x2F;&#x2F;传入新的容量</span><br><span class="line">    Entry[] oldTable &#x3D; table;    &#x2F;&#x2F;引用扩容前的Entry数组</span><br><span class="line">    int oldCapacity &#x3D; oldTable.length;         </span><br><span class="line">    if (oldCapacity &#x3D;&#x3D; MAXIMUM_CAPACITY) &#123;  &#x2F;&#x2F;扩容前的数组大小如果已经达到最大(2^30)了</span><br><span class="line">        threshold &#x3D; Integer.MAX_VALUE; &#x2F;&#x2F;修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Entry[] newTable &#x3D; new Entry[newCapacity];  &#x2F;&#x2F;初始化一个新的Entry数组</span><br><span class="line">    transfer(newTable);                         &#x2F;&#x2F;！！将数据转移到新的Entry数组里</span><br><span class="line">    table &#x3D; newTable;                           &#x2F;&#x2F;HashMap的table属性引用新的Entry数组</span><br><span class="line">    threshold &#x3D; (int)(newCapacity * loadFactor);&#x2F;&#x2F;修改阈值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable) &#123;</span><br><span class="line">    Entry[] src &#x3D; table;                   &#x2F;&#x2F;src引用了旧的Entry数组</span><br><span class="line">    int newCapacity &#x3D; newTable.length;</span><br><span class="line">    for (int j &#x3D; 0; j &lt; src.length; j++) &#123; &#x2F;&#x2F;遍历旧的Entry数组</span><br><span class="line">        Entry&lt;K,V&gt; e &#x3D; src[j];             &#x2F;&#x2F;取得旧Entry数组的每个元素</span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            src[j] &#x3D; null;&#x2F;&#x2F;释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span><br><span class="line">            do &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class="line">                int i &#x3D; indexFor(e.hash, newCapacity); &#x2F;&#x2F;！！重新计算每个元素在数组中的位置</span><br><span class="line">                e.next &#x3D; newTable[i]; &#x2F;&#x2F;标记[1]</span><br><span class="line">                newTable[i] &#x3D; e;      &#x2F;&#x2F;将元素放在数组上</span><br><span class="line">                e &#x3D; next;             &#x2F;&#x2F;访问下一个Entry链上的元素</span><br><span class="line">            &#125; while (e !&#x3D; null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p>
<p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。<br><img src="https://user-images.githubusercontent.com/26061465/139464694-a2d01f2e-2a3e-420f-892e-a128eeb5e4e0.png" alt="image"></p>
<hr>
<p>JDK1.8扩容做了优化，不再需要重新全部rehash，而是根据hash值新增的那个bit是1还是0就好了，省下了hash时间， 同时还可以借由新增的1bit是随机的，而均匀地把之前冲突的节点重新打散了<br>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了</p>
<p>我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p>
<p><img src="/2021/11/01/HashMap/3cc9813a.png" alt="img"></p>
<p>（注意看，蓝色的为新增1bit为0的情况，保持原index不动，绿色的为新增1bit为1，会移动到16(oldCap) + 15(srcIndex)的位置上）</p>
<p>JDK1.8省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了</p>
<p><strong>JDK8的元素迁移</strong></p>
<p>JDK8则因为巧妙的设计，性能有了大大的提升：由于数组的容量是以2的幂次方扩容的，那么一个Entity在扩容时，新的位置要么在<strong>原位置</strong>，要么在<strong>原长度+原位置</strong>的位置。原因如下图：</p>
<p><img src="/2021/11/01/HashMap/v2-da2df9ad67181daa328bb09515c1e1c8_1440w.png" alt="img"></p>
<p>数组长度变为原来的2倍，表现在二进制上就是<strong>多了一个高位参与数组下标确定</strong>。此时，一个元素通过hash转换坐标的方法计算后，恰好出现一个现象：最高位是0则坐标不变，最高位是1则坐标变为“10000+原坐标”，即“原长度+原坐标”。如下图（扩容16 -&gt; 32）：</p>
<p><img src="/2021/11/01/HashMap/v2-ac1017eb1b83ce5505bfc032ffbcc29a_1440w.jpg" alt="img"></p>
<p>因此，在扩容时，不需要重新计算元素的hash了，只需要判断最高位是1还是0就好了。</p>
<h3 id="5-Get"><a href="#5-Get" class="headerlink" title="(5)Get"></a>(5)Get</h3><p>通过hashCode高低16位相异或后跟n-1相与，得出的数组位置index，如该位置是目标则直接返回，如该位置是链表节点则链表方式索引，如果是红黑树则以红黑树的方式索引。</p>
<h3 id="6-Put"><a href="#6-Put" class="headerlink" title="(6)Put"></a>(6)Put</h3><p>也是先通过hashCode与当前数组长度n-1计算出index，然后判断该位置是否为空，为空则直接插入元素；如果该位置只有一个元素则转化为链表并插入；如果该位置为链表节点则以尾插法的方式插入新增节点；如果该位置为红黑树，则以红黑树的方式插入新增节点。</p>
<p>插入后，超过阈值则扩容。</p>
<h2 id="ConcurrentHashMap原理"><a href="#ConcurrentHashMap原理" class="headerlink" title="ConcurrentHashMap原理"></a>ConcurrentHashMap原理</h2><p>简述：concurrentHashMap在JDK1.7之前是分段锁，也就是在存储方面是一个 Segment 数组，一个 Segment 就是一个子哈希表，Segment 里维护了一个 HashEntry 数组，相当于是把整个哈希表分割成了ssize个segment数组，增删时通过对对应的segment加锁，达到只锁一段不影响其他segment的效果；同时也为每个节点Node的val和next都使用了volatile关键字保证可见性。</p>
<p>JDK1.8之后保留了Node节点的val和next字段的volatile关键字，不再使用Segment分段锁，而是<strong>以table数组对应index的结点</strong>作为synchronized的锁。</p>
<p>ConcurrentHashMap保证线程安全主要有三个地方。</p>
<blockquote>
<ul>
<li>一、使用volatile保证当Node中的值变化时对于其他线程是可见的</li>
<li>二、当对应index结点为null时（未有哈希冲突），使用CAS操作来保证数据能正确的写入</li>
<li>三、其他情况（即链表/红黑树）使用<strong>table数组的头结点（链表或树的头结点）</strong>作为synchronized的锁来保证写操作的安全</li>
</ul>
</blockquote>
<h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><p><strong>大体思路</strong>：</p>
<ul>
<li>如果<code>table</code>数组还没有初始化，则使用<code>CAS</code>进行初始化</li>
<li>如果<code>table</code>数组中<code>i</code>位置处元素为空，则使用<code>CAS</code>将<code>table[i]</code>的值设置为value</li>
<li>如果其他线程正在对<code>table</code>数组进行扩容，则当前线程去协助其进行扩容</li>
<li>其他情况，则使用<code>synchronized</code>锁住**<code>table[i]</code><strong>这个元素（</strong>链表表头或红黑树根节点**），并将元素追加插入到链表或红黑树中；插入后，检查是否需要将该桶的数据结构由链表转化为红黑树。</li>
<li>成功设置<code>&lt;key, value&gt;</code>后，检查是否需要进行扩容</li>
</ul>
<blockquote>
<p>要想对链表或红黑树进行put操作，必须拿到表头或根节点，所以，锁住了表头或根节点，就相当于锁住了整个链表或者整棵树。这个设计与分段锁的思想一致，只是其他读取操作需要用cas来保证。</p>
</blockquote>
<h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><p><code>get</code>简单很多，由于get在Node.val值被volatile修饰的情况下不需要考虑加锁，所以只需要正常检索即可。也就是通过hashCode高低16位相异或后跟n-1相与，得出的数组位置index，如该位置是目标则直接返回，如该位置是链表节点则链表方式索引，如果是红黑树则以红黑树的方式索引。</p>
<ul>
<li>扩容中，且当前index位置未完成扩容的，由于扩容过程是形成hn和ln复制链而非剪切的，故原位置仍可正常访问。</li>
<li>扩容中，且当前index已完成扩容的，由于迁移过程中每移动完一个hash桶原地会留下新地址的头结点，以该头节点进行索引即可。</li>
</ul>
<h3 id="Size"><a href="#Size" class="headerlink" title="Size"></a>Size</h3><p>至于<code>size()</code>方法在JDK1.8版本中，对于size的计算，在扩容和addCount()方法就已经有处理了，JDK1.7是在调用size()方法才去计算</p>
<h3 id="Transfer扩容"><a href="#Transfer扩容" class="headerlink" title="Transfer扩容"></a>Transfer扩容</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ZOKEKAI/article/details/90051567">(ConcurrentHashMap1.8 - 扩容详解_ZOKEKAI的博客-CSDN博客_concurrenthashmap 扩容</a></p>
<p>多线程协同扩容；index的计算依然与JDK1.8一样，是依靠新增的1bit为0则留在原index，为1则迁移到index + 原数组长度。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>HashMap</p><p><a href="http://example.com/2021/11/01/HashMap/">http://example.com/2021/11/01/HashMap/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>white crow</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2021-11-01</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-05-10</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Core/">Core</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/11/02/Coroutines-Principle/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Coroutines_Principle</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/10/28/Mmkv/"><span class="level-item">mmkv</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#常见Map类"><span class="level-left"><span class="level-item">1</span><span class="level-item">常见Map类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-HashMap："><span class="level-left"><span class="level-item">1.1</span><span class="level-item">(1) HashMap：</span></span></a></li><li><a class="level is-mobile" href="#2-不推荐的线程安全Map："><span class="level-left"><span class="level-item">1.2</span><span class="level-item">(2) 不推荐的线程安全Map：</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-HashTable"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">(2.1)HashTable</span></span></a></li><li><a class="level is-mobile" href="#2-2-SynchronizedMap"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">(2.2)SynchronizedMap</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-ConcurrentHashMap"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">(3) ConcurrentHashMap:</span></span></a></li><li><a class="level is-mobile" href="#4-LinkedHashMap："><span class="level-left"><span class="level-item">1.4</span><span class="level-item">(4) LinkedHashMap：</span></span></a></li><li><a class="level is-mobile" href="#5-TreeMap："><span class="level-left"><span class="level-item">1.5</span><span class="level-item">(5) TreeMap：</span></span></a></li></ul></li><li><a class="level is-mobile" href="#HashMap原理"><span class="level-left"><span class="level-item">2</span><span class="level-item">HashMap原理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-存储结构："><span class="level-left"><span class="level-item">2.1</span><span class="level-item">(1) 存储结构：</span></span></a></li><li><a class="level is-mobile" href="#2-哈希冲突："><span class="level-left"><span class="level-item">2.2</span><span class="level-item">(2) 哈希冲突：</span></span></a></li><li><a class="level is-mobile" href="#3-位置确定："><span class="level-left"><span class="level-item">2.3</span><span class="level-item">(3)位置确定：</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#第一步：hashCode高低16位异或"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">第一步：hashCode高低16位异或</span></span></a></li><li><a class="level is-mobile" href="#第二步：与n-1相与"><span class="level-left"><span class="level-item">2.3.2</span><span class="level-item">第二步：与n-1相与</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-扩容"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">(4) 扩容</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#简述："><span class="level-left"><span class="level-item">2.4.1</span><span class="level-item">简述：</span></span></a></li><li><a class="level is-mobile" href="#详解："><span class="level-left"><span class="level-item">2.4.2</span><span class="level-item">详解：</span></span></a></li></ul></li><li><a class="level is-mobile" href="#5-Get"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">(5)Get</span></span></a></li><li><a class="level is-mobile" href="#6-Put"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">(6)Put</span></span></a></li></ul></li><li><a class="level is-mobile" href="#ConcurrentHashMap原理"><span class="level-left"><span class="level-item">3</span><span class="level-item">ConcurrentHashMap原理</span></span></a></li><li><a class="level is-mobile" href="#put"><span class="level-left"><span class="level-item">4</span><span class="level-item">put</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Get"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">Get</span></span></a></li><li><a class="level is-mobile" href="#Size"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">Size</span></span></a></li><li><a class="level is-mobile" href="#Transfer扩容"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">Transfer扩容</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatarPng.png" alt="White Crow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">White Crow</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">81</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">4</p></a></div></div></nav></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a><p class="is-size-7"><span>&copy; 2025 white crow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://github.com/WhileCrow"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>