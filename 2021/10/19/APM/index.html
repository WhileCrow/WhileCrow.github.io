<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>APM - Crow&#039;s Sky</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Crow&#039;s Sky"><meta name="msapplication-TileImage" content="/img/avatarCircle.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Crow&#039;s Sky"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="主线程卡顿监控方案一、Looper Printer监控每次 dispatchMessage 的执行耗时：DoKit &amp;amp; BlockCanary &amp;amp; Matrix滴滴的哆啦A梦的卡顿检测其实就是blockCanary，和Matrix 的EvilMethodTracer和AnrTracer （当然后来Matrix还增加了native的Signal信号监听）使用的 方案也就是Looper"><meta property="og:type" content="blog"><meta property="og:title" content="APM"><meta property="og:url" content="http://example.com/2021/10/19/APM/"><meta property="og:site_name" content="Crow&#039;s Sky"><meta property="og:description" content="主线程卡顿监控方案一、Looper Printer监控每次 dispatchMessage 的执行耗时：DoKit &amp;amp; BlockCanary &amp;amp; Matrix滴滴的哆啦A梦的卡顿检测其实就是blockCanary，和Matrix 的EvilMethodTracer和AnrTracer （当然后来Matrix还增加了native的Signal信号监听）使用的 方案也就是Looper"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/2021/10/19/APM/640"><meta property="article:published_time" content="2021-10-19T08:34:22.000Z"><meta property="article:modified_time" content="2024-03-25T07:35:02.863Z"><meta property="article:author" content="White Crow"><meta property="article:tag" content="Core"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2021/10/19/APM/640"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/10/19/APM/"},"headline":"APM","image":[],"datePublished":"2021-10-19T08:34:22.000Z","dateModified":"2024-03-25T07:35:02.863Z","author":{"@type":"Person","name":"white crow"},"publisher":{"@type":"Organization","name":"Crow's Sky","logo":{"@type":"ImageObject","url":"http://example.com/img/avatarCircle.png"}},"description":"主线程卡顿监控方案一、Looper Printer监控每次 dispatchMessage 的执行耗时：DoKit &amp; BlockCanary &amp; Matrix滴滴的哆啦A梦的卡顿检测其实就是blockCanary，和Matrix 的EvilMethodTracer和AnrTracer （当然后来Matrix还增加了native的Signal信号监听）使用的 方案也就是Looper"}</script><link rel="canonical" href="http://example.com/2021/10/19/APM/"><link rel="icon" href="/img/avatarCircle.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/WhileCrow"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-10-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-10-19T08:34:22.000Z" title="10/19/2021, 4:34:22 PM">2021-10-19</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:02.863Z" title="3/25/2024, 3:35:02 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">19 minutes read (About 2808 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">APM</h1><div class="content"><h1 id="主线程卡顿监控"><a href="#主线程卡顿监控" class="headerlink" title="主线程卡顿监控"></a>主线程卡顿监控</h1><h2 id="方案一、Looper-Printer监控每次-dispatchMessage-的执行耗时："><a href="#方案一、Looper-Printer监控每次-dispatchMessage-的执行耗时：" class="headerlink" title="方案一、Looper Printer监控每次 dispatchMessage 的执行耗时："></a>方案一、Looper Printer监控每次 dispatchMessage 的执行耗时：</h2><h3 id="DoKit-amp-BlockCanary-amp-Matrix"><a href="#DoKit-amp-BlockCanary-amp-Matrix" class="headerlink" title="DoKit &amp; BlockCanary &amp; Matrix"></a>DoKit &amp; BlockCanary &amp; Matrix</h3><p><strong>滴滴的哆啦A梦的卡顿检测其实就是blockCanary，和Matrix 的EvilMethodTracer和AnrTracer （当然后来Matrix还增加了native的Signal信号监听）使用的 方案也就是Looper设置Printer监听卡顿</strong></p>
<p>都是根据handler原理，通过给Looper.loop() 中设置printer(无论是通过反射替换Looper的<em>mLogging</em>还是通过<em>setMessageLogging</em>设置printer)，监控超过 设定阈值(matrix700ms) 的主线程消息（超过5s报为ANR），printer 中判断start和end，来获取主线程dispatch该message的开始和结束时间，并判定该时间超过阈值为主线程卡慢发生，并 打印当时堆栈 + 方法耗时(matrix/dokit)</p>
<span id="more"></span>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Looper.loop() &#123;  </span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">     Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">     <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">// 执行dispatchMessage前，执行Printer的println方法</span></span><br><span class="line">     <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">     <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">       logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                       msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">  	...</span><br><span class="line">      </span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       msg.target.dispatchMessage(msg);</span><br><span class="line">       dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      	...</span><br><span class="line">     &#125;</span><br><span class="line">       </span><br><span class="line">     ...</span><br><span class="line">       </span><br><span class="line">     <span class="comment">// 执行dispatchMessage后，执行Printer的println方法</span></span><br><span class="line">     <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">       logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">     &#125;</span><br><span class="line">    	...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Matrix：无论是通过反射替换Looper的<em>mLogging</em>还是通过<em>setMessageLogging</em>设置printer，我们只需要替换主线程Looper的printer对象，通过计算执行dispatchMessage方法之后和之前打印字符串的时间的差值，就可以拿到到<em>dispatchMessage</em>方法执行的时间。而大部分的主线程的操作最终都会执行到这个<em>dispatchMessage</em>方法中。</p>
</blockquote>
<h4 id="printer监控方案存在问题及解决方案："><a href="#printer监控方案存在问题及解决方案：" class="headerlink" title="printer监控方案存在问题及解决方案："></a>printer监控方案存在问题及解决方案：</h4><p>简述：一是主线程空闲时message.next()会阻塞并且Touch事件也是执行在next中的natviePollOnce里面的，二是IdleHandler空闲handler的queueIdle回调</p>
<h5 id="Q："><a href="#Q：" class="headerlink" title="Q："></a>Q：</h5><p>如果排除主线程空闲的情况，究竟会是什么原因会卡在<em>MessageQueue</em>的<em>next</em>方法中呢？下图是<em>next</em>方法简化过后的源码，*<strong>frameworks/base/core/java/android/os/MessageQueue.java:*</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">        Binder.flushPendingCommands();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run the idle handlers.</span></span><br><span class="line">    <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">        mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            keep = idler.queueIdle();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                mIdleHandlers.remove(idler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 如果本次循环拿到的Message为空，或者！这个Message是一个延时的消息而且还没到指定的触发时间，那么，就认定当前的队列为空闲状态，</span></span><br><span class="line"><span class="comment">2. 接着就会遍历mPendingIdleHandlers数组(这个数组里面的元素每次都会到mIdleHandlers中去拿)来调用每一个IdleHandler实例的queueIdle方法，</span></span><br><span class="line"><span class="comment">3. 果这个方法返回false的话，那么这个实例就会从mIdleHandlers中移除，也就是当下次队列空闲的时候，不会继续回调它的queueIdle方法了。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>因为有些情况的卡顿，这种方案从原理上就无法监控到。看到上面的<em>queue.next()<em>，这里给了注释：<strong>might block</strong>，直接跟你说这里是可能会卡住的，这时候再计算</em>dispatchMessage</em>方法的耗时显然就没有意义了。有的同学可能会想，那我改成计算相邻两次<em>dispatchMessage</em>执行之前打印字符串的时间差值不就好了？这样就可以把<em>next</em>方法的耗时也计算在内。</p>
<p>1、<strong>主线程空闲也就是queue.next()阻塞的时候，同时也是应用的Touch事件</strong>。不幸的是，主线程空闲时，也会阻塞在<em>MessageQueue</em>的<em>next</em>方法中，我们很难区分究竟是发生了卡顿还是主线程空闲，除了主线程空闲时就是阻塞在<em>nativePollOnce</em>之外，非常重要的是，<strong>应用的Touch事件也是在这里被处理的</strong>。这就意味着，<strong>View的TouchEvent中的卡顿这种方案是无法监控的</strong>。（微信中有大量的自定义View，这些View中充满了各种各样很多的onTouch回调，卡在这里面的情况非常普遍，这种情况的卡顿监控不到是很难接受的）</p>
<p>2、<strong>IdleHandler的queueIdle()回调方法</strong>。这个方法会在主线程空闲的时候被调用。然而实际上，很多开发同学都先入为主的认为这个时候反正主线程空闲，做一些耗时操作也没所谓。<strong>其实主线程MessageQueue的<em>queueIdle</em>默认当然也是执行在主线程中</strong>，所以这里的耗时操作其实是很容易引起卡顿和ANR的。（例如微信之前就使用<em>IdleHandler</em>在进入微信的主界面后，做一些读写文件的IO操作，就造成了一些卡顿和ANR问题）</p>
<p>3、<strong>SyncBarrier泄露。</strong>还有一类相对少见的问题是<strong>SyncBarrier（同步屏障）的泄漏同样无法被监控到</strong></p>
<h5 id="A："><a href="#A：" class="headerlink" title="A："></a>A：</h5><h5 id="A-1-监控IdleHandler卡顿"><a href="#A-1-监控IdleHandler卡顿" class="headerlink" title="A.1. 监控IdleHandler卡顿"></a><strong>A.1. 监控IdleHandler卡顿</strong></h5><p>首先从简单的下手，对于<em>IdleHandler</em>的<em>queueIdle</em>回调方法的监控。我们惊喜的发现<em>MessageQueue</em>中的<em>mIdleHandlers</em>是可以被反射的，这个变量保存了所有将要执行的IdleHandler，我们只需要把ArrayList类型的<em>mIdleHandlers</em>，通过反射，替换为MyArrayList，在我们自定义的<em>MyArrayList</em>中重写<em>add</em>方法，再将我们自定义的MyIdleHandler添加到<em>MyArrayList</em>中，就完成了“偷天换日”。从此之后<em>MessageQueue</em>每次执行queueIdle回调方法，都会执行到我们的<em>MyIdleHandler</em>中的的<em>queueIdle</em>方法，就可以在这里监控<em>queueIdle</em>的执行时间了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">detectIdleHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MessageQueue mainQueue = Looper.getMainLooper().getQueue();</span><br><span class="line">        Field field = MessageQueue.class.getDeclaredField(<span class="string">&quot;mIdleHandlers&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        MyArrayList&lt;MessageQueue.IdleHandler&gt; myIdleHandlerArrayList = <span class="keyword">new</span> MyArrayList&lt;&gt;();</span><br><span class="line">        field.set(mainQueue, myIdleHandlerArrayList);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">    Map&lt;MessageQueue.IdleHandler, MyIdleHandler&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> MessageQueue.IdleHandler) &#123;</span><br><span class="line">            MyIdleHandler myIdleHandler = <span class="keyword">new</span> MyIdleHandler((MessageQueue.IdleHandler) o);</span><br><span class="line">            map.put((MessageQueue.IdleHandler) o, myIdleHandler);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.add(myIdleHandler);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="meta">@Nullable</span> Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> MyIdleHandler) &#123;</span><br><span class="line">            MessageQueue.IdleHandler idleHandler = ((MyIdleHandler) o).idleHandler;</span><br><span class="line">            map.remove(idleHandler);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.remove(o);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            MyIdleHandler myIdleHandler = map.remove(o);</span><br><span class="line">            <span class="keyword">if</span> (myIdleHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.remove(myIdleHandler);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.remove(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="A-2-监控TouchEvent卡顿"><a href="#A-2-监控TouchEvent卡顿" class="headerlink" title="A.2. 监控TouchEvent卡顿"></a><strong>A.2. 监控TouchEvent卡顿</strong></h5><p>那么TouchEvent我们有什么办法监控吗？首先想到的可能是反射View的<em>mListenerInfo</em>，然后进一步替换其中的<em>mTouchListenr</em>，但是这需要我们枚举所有需要被监控的View，全部反射替换一遍，这完全是憨憨行为。那有没有更加根本，全局性的方法呢？</p>
<p>熟悉input系统的同学应该知道，Touch事件最终是通过server端的<em>InputDispatcher</em>线程传递给Client端的UI线程的，并且使用的是一对Socket进行通讯的。我们可以通过PLT Hook，去Hook这对Socket的send和recv方法来监控Touch事件啊！我们先捋一下一次Touch事件的处理过程：</p>
<p><img src="/2021/10/19/APM/640" alt="图片"></p>
<p>我们通过PLT Hook，成功hook到libinput.so中的<em>recvfrom</em>和<em>sendto</em>方法，使用我们自己的方法进行替换。当调用到了<em>recvfrom</em>时，说明我们的应用接收到了Touch事件，当调用到了<em>sendto</em>时，说明这个Touch事件已经被成功消费掉了，当两者的时间相差过大时即说明产生了一次Touch事件的卡顿。这种方案经过验证是可行的！</p>
<h5 id="A-3-监控SyncBarrier泄漏"><a href="#A-3-监控SyncBarrier泄漏" class="headerlink" title="A.3. 监控SyncBarrier泄漏"></a><strong>A.3. 监控SyncBarrier泄漏</strong></h5><p>最后，SyncBarrier泄漏的问题，有什么好办法能监控到吗？目前我们的方案是不断轮询主线程<em>Looper</em>的<em>MessageQueue</em>的<em>mMessage</em>(也就是主线程当前正在处理的Message)。而SyncBarrier本身也是一种特殊的Message，其特殊在它的target是null。如果我们通过反射<em>mMessage</em>，发现当前的Message的target为null，并且通过这个Message的when发现其已经存在很久了，这个时候我们合理怀疑产生了SyncBarrier的泄漏（但还不能完全确定，因为如果当时因为其他原因导致主线程卡死，也可能会导致这种现象），然后再发送一个同步消息和一个异步消息，如果异步消息被处理了，但是同步消息一直无法被处理，这时候就说明产生了<em>SyncBarrier</em>的泄漏。如果激进一些，这个时候<strong>我们甚至可以反射调用*MessageQueue*的*removeSyncBarrier*方法，手动把这个SyncBarrier移除掉，从而从错误状态中恢复</strong>。</p>
<p>坏消息是，这种方案只能监控到问题的产生，也可以直接解决问题，但是无法溯源问题究竟是哪个View导致的。其实我们也尝试过，通过插桩或者Java hook的方法，监控<em>invalidate</em>方法是否在非主线程中进行，但是考虑到风险以及对性能影响都比较大，没有在线上使用。所幸，通过监控发现，这个问题对我们来说，发生的概率并不高。如果发现某个场景下该问题确实较为严重，可以考虑使用插桩或者Java hook在测试环境下debug该问题。</p>
<h2 id="方案二、依赖-Choreographer-模块，监控相邻两次-Vsync-事件通知的时间差"><a href="#方案二、依赖-Choreographer-模块，监控相邻两次-Vsync-事件通知的时间差" class="headerlink" title="方案二、依赖 Choreographer 模块，监控相邻两次 Vsync 事件通知的时间差"></a>方案二、依赖 Choreographer 模块，监控相邻两次 Vsync 事件通知的时间差</h2><p>利用系统 Choreographer 模块，向该模块注册一个 FrameCallback 监听对象，同时通过另外一条线程循环记录主线程堆栈信息，并在每次 Vsync 事件 doFrame 通知回来时，循环注册该监听对象，间接统计两次 Vsync 事件的时间间隔，当超出阈值时，取出记录的堆栈进行分析上报。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Choreographer.getInstance().postFrameCallback(<span class="keyword">new</span> Choreographer.FrameCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(frameTimeNanos - mLastFrameNanos &gt; <span class="number">100</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        mLastFrameNanos = frameTimeNanos;</span><br><span class="line">        Choreographer.getInstance().postFrameCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="卡顿发生时堆栈的收集"><a href="#卡顿发生时堆栈的收集" class="headerlink" title="卡顿发生时堆栈的收集"></a>卡顿发生时堆栈的收集</h2><p><strong>BlocakCanary：</strong>在执行前利用另外一条线程，通过 Thread#getStackTrace 接口，以轮询的方式获取主线程执行堆栈信息并记录起来，同时统计每次 dispatchMessage 方法执行耗时，当超出阈值时，将该次获取的堆栈进行分析上报，从而来捕捉卡顿信息，否则丢弃此次记录的堆栈信息。</p>
<p><strong>Matrix：</strong>根据编译期插桩记录函数耗时，在卡顿发生时获取之前一段时间的函数进行归堆，性能更佳，</p>
<p>不仅在编译期时对特殊无需插桩函数排除（方法字节码中是否只包含PUT/READ FIELD等简单指令、默认或匿名构造函数）、插桩函数用ID映射</p>
<p>还在运行期时用long[]数组记录函数id和函数函数，极大程度的减少占用内存、另一个线程每5ms更新时间减少调用System.nanoTime的耗时 </p>
<p><strong>Dokit：</strong>也是插桩，但优化不细。</p>
<h1 id="函数耗时统计："><a href="#函数耗时统计：" class="headerlink" title="函数耗时统计："></a>函数耗时统计：</h1><p>DoKit：上面说的插桩</p>
<p>Matrix：上面说的插桩</p>
<p>一些细节上的区别：</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>APM</p><p><a href="http://example.com/2021/10/19/APM/">http://example.com/2021/10/19/APM/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>white crow</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2021-10-19</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-03-25</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Core/">Core</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/10/26/ClassLoading/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">ClassLoading</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/10/19/%E5%8D%A1%E9%A1%BF%E7%9B%91%E6%8E%A7/"><span class="level-item">卡顿监控</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#主线程卡顿监控"><span class="level-left"><span class="level-item">1</span><span class="level-item">主线程卡顿监控</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#方案一、Looper-Printer监控每次-dispatchMessage-的执行耗时："><span class="level-left"><span class="level-item">1.1</span><span class="level-item">方案一、Looper Printer监控每次 dispatchMessage 的执行耗时：</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#DoKit-amp-BlockCanary-amp-Matrix"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">DoKit &amp; BlockCanary &amp; Matrix</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#printer监控方案存在问题及解决方案："><span class="level-left"><span class="level-item">1.1.1.1</span><span class="level-item">printer监控方案存在问题及解决方案：</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Q："><span class="level-left"><span class="level-item">1.1.1.1.1</span><span class="level-item">Q：</span></span></a></li><li><a class="level is-mobile" href="#A："><span class="level-left"><span class="level-item">1.1.1.1.2</span><span class="level-item">A：</span></span></a></li><li><a class="level is-mobile" href="#A-1-监控IdleHandler卡顿"><span class="level-left"><span class="level-item">1.1.1.1.3</span><span class="level-item">A.1. 监控IdleHandler卡顿</span></span></a></li><li><a class="level is-mobile" href="#A-2-监控TouchEvent卡顿"><span class="level-left"><span class="level-item">1.1.1.1.4</span><span class="level-item">A.2. 监控TouchEvent卡顿</span></span></a></li><li><a class="level is-mobile" href="#A-3-监控SyncBarrier泄漏"><span class="level-left"><span class="level-item">1.1.1.1.5</span><span class="level-item">A.3. 监控SyncBarrier泄漏</span></span></a></li></ul></li></ul></li></ul></li><li><a class="level is-mobile" href="#方案二、依赖-Choreographer-模块，监控相邻两次-Vsync-事件通知的时间差"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">方案二、依赖 Choreographer 模块，监控相邻两次 Vsync 事件通知的时间差</span></span></a></li><li><a class="level is-mobile" href="#卡顿发生时堆栈的收集"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">卡顿发生时堆栈的收集</span></span></a></li></ul></li><li><a class="level is-mobile" href="#函数耗时统计："><span class="level-left"><span class="level-item">2</span><span class="level-item">函数耗时统计：</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatarPng.png" alt="White Crow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">White Crow</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">79</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">4</p></a></div></div></nav></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a><p class="is-size-7"><span>&copy; 2024 white crow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://github.com/WhileCrow"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>