<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>JvmMemoryStructure - Crow&#039;s Sky</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Crow&#039;s Sky"><meta name="msapplication-TileImage" content="/img/avatarCircle.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Crow&#039;s Sky"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="程序计数器不会OOM和StackOverflow 有栈的结构（栈 java stack、navtive stack）可能发生 StackOverflowError（栈过深） 和 OOM   StackOverFlowError ︰若Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java 虚拟机栈的最大深度的时候，就抛出StackOverFlowError错误。OutO"><meta property="og:type" content="blog"><meta property="og:title" content="JvmMemoryStructure"><meta property="og:url" content="http://example.com/2024/04/19/JMM/"><meta property="og:site_name" content="Crow&#039;s Sky"><meta property="og:description" content="程序计数器不会OOM和StackOverflow 有栈的结构（栈 java stack、navtive stack）可能发生 StackOverflowError（栈过深） 和 OOM   StackOverFlowError ︰若Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java 虚拟机栈的最大深度的时候，就抛出StackOverFlowError错误。OutO"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/2024/04/19/JMM/image-20240425141403378.png"><meta property="og:image" content="http://example.com/2024/04/19/JMM/1031642665576_.pic_hd.jpg"><meta property="og:image" content="http://example.com/2024/04/19/JMM/971642665527_.pic_hd.jpg"><meta property="og:image" content="http://example.com/2024/04/19/JMM/image-20210430141704116.png"><meta property="og:image" content="http://example.com/2024/04/19/JMM/image-20220127105438727.png"><meta property="og:image" content="http://example.com/2024/04/19/JMM/1L%7D07%7BAK5E41$Q8TWIQ%7BS$T.jpg"><meta property="og:image" content="http://example.com/2024/04/19/JMM/stack_heap_info.png"><meta property="og:image" content="http://example.com/2024/04/19/JMM/young_gc.png"><meta property="og:image" content="http://example.com/2024/04/19/JMM/640-20230808171027900.png"><meta property="og:image" content="http://example.com/2024/04/19/JMM/640-20230808171027894.png"><meta property="og:image" content="http://example.com/2024/04/19/JMM/640-20230808171027987.png"><meta property="og:image" content="http://example.com/2024/04/19/JMM/323655031-d35dc0ec-73c7-4084-a348-34197b7447ad.png"><meta property="og:image" content="http://example.com/2024/04/19/JMM/image-20230808162509989.png"><meta property="article:published_time" content="2024-04-19T02:53:39.122Z"><meta property="article:modified_time" content="2024-04-25T06:46:23.755Z"><meta property="article:author" content="White Crow"><meta property="article:tag" content="Core"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2024/04/19/JMM/image-20240425141403378.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2024/04/19/JMM/"},"headline":"JvmMemoryStructure","image":["http://example.com/2024/04/19/JMM/image-20240425141403378.png","http://example.com/2024/04/19/JMM/1031642665576_.pic_hd.jpg","http://example.com/2024/04/19/JMM/971642665527_.pic_hd.jpg","http://example.com/2024/04/19/JMM/image-20210430141704116.png","http://example.com/2024/04/19/JMM/image-20220127105438727.png","http://example.com/2024/04/19/JMM/1L%7D07%7BAK5E41$Q8TWIQ%7BS$T.jpg","http://example.com/2024/04/19/JMM/stack_heap_info.png","http://example.com/2024/04/19/JMM/young_gc.png","http://example.com/2024/04/19/JMM/640-20230808171027900.png","http://example.com/2024/04/19/JMM/640-20230808171027894.png","http://example.com/2024/04/19/JMM/640-20230808171027987.png","http://example.com/2024/04/19/JMM/323655031-d35dc0ec-73c7-4084-a348-34197b7447ad.png","http://example.com/2024/04/19/JMM/image-20230808162509989.png"],"datePublished":"2024-04-19T02:53:39.122Z","dateModified":"2024-04-25T06:46:23.755Z","author":{"@type":"Person","name":"white crow"},"publisher":{"@type":"Organization","name":"Crow's Sky","logo":{"@type":"ImageObject","url":"http://example.com/img/avatarCircle.png"}},"description":"程序计数器不会OOM和StackOverflow 有栈的结构（栈 java stack、navtive stack）可能发生 StackOverflowError（栈过深） 和 OOM   StackOverFlowError ︰若Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java 虚拟机栈的最大深度的时候，就抛出StackOverFlowError错误。OutO"}</script><link rel="canonical" href="http://example.com/2024/04/19/JMM/"><link rel="icon" href="/img/avatarCircle.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/WhileCrow"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-10-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-04-19T02:53:39.122Z" title="4/19/2024, 10:53:39 AM">2024-04-19</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-04-25T06:46:23.755Z" title="4/25/2024, 2:46:23 PM">2024-04-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Common/">Common</a><span> / </span><a class="link-muted" href="/categories/Common/Jvm/">Jvm</a></span><span class="level-item">37 minutes read (About 5553 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">JvmMemoryStructure</h1><div class="content"><p><img src="/2024/04/19/JMM/image-20240425141403378.png" alt="image-20240425141403378"></p>
<p>程序计数器不会OOM和StackOverflow</p>
<p>有栈的结构（栈 java stack、navtive stack）可能发生 StackOverflowError（栈过深） 和 OOM </p>
<blockquote>
<p><strong>StackOverFlowError</strong> ︰若Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java 虚拟机栈的最大深度的时候，就抛出StackOverFlowError错误。<br><strong>OutOfMemoryError</strong> :如果虚拟机栈可以动态扩展（当前大部分的 Java 虚拟机都可动态扩展，只不过 Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出 OutOfMemoryError 异常。</p>
</blockquote>
<p>没栈的结构（堆heap、方法区Method Area）只可能发生 OOM</p>
<span id="more"></span>

<p>java栈帧结构 JavaStackFrame：</p>
<p><img src="/2024/04/19/JMM/1031642665576_.pic_hd.jpg" alt="1031642665576_.pic_hd"></p>
<p><img src="/2024/04/19/JMM/971642665527_.pic_hd.jpg" alt="971642665527_.pic_hd"></p>
<p><img src="/2024/04/19/JMM/image-20210430141704116.png" alt="image-20210430141704116"></p>
<p>Java内存比较流行的说法便是堆和栈，这其实是非常粗略的一种划分，这种划分的”堆”对应内存模型的Java堆，”栈”是指虚拟机栈。</p>
<p><a target="_blank" rel="noopener" href="https://www.processon.com/mindmap/61f204646376890390c953b8">JMM (processon.com)</a></p>
<p><img src="/2024/04/19/JMM/image-20220127105438727.png" alt="image-20220127105438727"></p>
<p>简单聚焦于堆、方法区与栈。</p>
<p><img src="/2024/04/19/JMM/1L%7D07%7BAK5E41$Q8TWIQ%7BS$T.jpg" alt="img"></p>
<p><img src="/2024/04/19/JMM/stack_heap_info.png" alt="stack_heap_info"></p>
<h1 id="Java-Heap-java堆"><a href="#Java-Heap-java堆" class="headerlink" title="Java Heap java堆"></a>Java Heap java堆</h1><p>是JVM所管理的内存中最大的一块。唯一目的就是存放实例对象，几乎所有的对象实例都在这里分配。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。</p>
<p>堆内存是JVM中最大的一块由年轻代和老年代组成（1:2），而年轻代内存又被分成三部分，Eden空间、From Survivor空间、To Survivor空间,默认情况下年轻代按照8:1:1的比例来分配；</p>
<p><img src="/2024/04/19/JMM/young_gc.png" alt="young_gc"></p>
<p>简述：</p>
<p>1：一开始，Eden,from,to 都是空的，新对象产生被分配到Eden区；</p>
<p>2：Eden满了，开始第一次GC，mark-copy算法，将存活对象复制至from，之后清空Eden，此时Eden，to为空；from保存age1对象；</p>
<p>3：2步骤重复，也就是Eden填满-&gt;GC-&gt;转移存活至from，但注意下GC时如果from中age超过阈值的对象会被送往old；</p>
<p>4：直到from也满了，下一次GC会</p>
<p>HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1,为啥默认会是这个比例，接下来我们会聊到。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。</p>
<p>因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p>
<p>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p>
<h1 id="Method-Area-方法区-非堆"><a href="#Method-Area-方法区-非堆" class="headerlink" title="Method Area 方法区/非堆"></a>Method Area 方法区/非堆</h1><p><strong>存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码</strong></p>
<blockquote>
<p> <strong>per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors</strong></p>
</blockquote>
<p><strong>运行时常量池是类文件中constant_pool表的每个类或每个接口的运行时表示</strong></p>
<blockquote>
<p><strong>A <em>run-time constant pool</em> is a per-class or per-interface run-time representation of the <code>constant_pool</code> table in a <code>class</code> file</strong></p>
</blockquote>
<p><strong>每个运行时常量池都是从JVM的方法区分配的。类或接口的运行时常量池是在JVM创建类或接口时构造的。</strong></p>
<blockquote>
<p><strong>Each run-time constant pool is allocated from the Java Virtual Machine’s method area (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">§2.5.4</a>). The run-time constant pool for a class or interface is constructed when the class or interface is created (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3">§5.3</a>) by the Java Virtual Machine.</strong></p>
</blockquote>
<p>虽然叫方法区，但跟方法是没什么关西的。<br>方法区存储<strong>类信息、常量(final static)、静态变量</strong>等数据，是线程共享的区域，为与Java堆区分，方法区还有一个别名Non-Heap(非堆)；</p>
<h2 id="常量池介绍"><a href="#常量池介绍" class="headerlink" title="常量池介绍"></a>常量池介绍</h2><p>常量池可以看成是一个表，但是有三点需要特别注意。</p>
<ol>
<li>表头给出的常量池大小比实际大1。假设表头给出的值是n，那么常量池的实际大小是n–1。</li>
<li>有效的常量池索引是1~n–1。0是无效索引，表示不指向任何常量。</li>
<li><code>CONSTANT_Long_info</code>和<code>CONSTANT_Double_info</code>各占两个位置。</li>
</ol>
<p>表中的每一项的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u1 info[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，每一项都包含一个 tag，一个 info 数组。info 数组里面的的具体内容与 tag 的值有关。</p>
<p>tag 的值分为以下几种：</p>
<p><img src="/2024/04/19/JMM/640-20230808171027900.png" alt="图片"></p>
<p>tag取值很多，就举一个例子，其他的都是类似的。如果 tag 的值为 7，那么 info 数组表示的意义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Class_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 name_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>name_index</code> 是一个 <code>u2</code> 类型，就相当于<code>info</code>的长度为2。</p>
<p><code>name_index</code> 的含义根据名称也能猜的出来，是类名，只不过储存的是常量池的索引，索引指向的位置是类名。该位置的常量类型一定是一个 <code>CONSTANT_Utf8_info</code> 类型。</p>
<p>说起来可能有点不太好懂，我们看一个具体的例子：</p>
<p><img src="/2024/04/19/JMM/640-20230808171027894.png" alt="图片"></p>
<p>图中是一个 <code>CONSTANT_Class_info</code> ，它的 <code>name_index</code> 是 34，我们看看常量池的第34项是什么：</p>
<p><img src="/2024/04/19/JMM/640-20230808171027987.png" alt="图片"></p>
<p>可以看到34处，它确实是一个 <code>CONSTANT_Utf8_info</code> 类型，其具体的值就是类的名字。</p>
<p>其他的tag类型也是类似的，具体可以看官方文档，就不详细介绍了，我们现在开始使用代码解析常量池。</p>
<p><strong>上为所有线程共享</strong> ↑<br><strong>下为线程私有</strong>  ↓</p>
<p>栈又分为jvm栈和本地方法栈主要用于方法的执行。</p>
<h1 id="VMStack-java方法栈"><a href="#VMStack-java方法栈" class="headerlink" title="VMStack  java方法栈"></a>VMStack  java方法栈</h1><p>它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于<strong>存储局部变量表</strong>、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 </p>
<blockquote>
<p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、<strong>对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置</strong>）和returnAddress类型（指向了一条字节码指令的地址）。</p>
</blockquote>
<h1 id="本地方法栈-native方法栈"><a href="#本地方法栈-native方法栈" class="headerlink" title="本地方法栈 native方法栈"></a>本地方法栈 native方法栈</h1><p>虚拟机栈为虚拟机执行java方法，而本地方法栈为虚拟机使用到的Native方法服务。</p>
<h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><p>一块较小的内存，当前线程所执行的字节码的行号指示器。字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
<p>！！记录的是当前线程执行的字节码行号，debug时会被重新映射到对应的代码行数。Debug断点指向的代码行数可能包含多行字节码。</p>
<p><img src="/2024/04/19/JMM/323655031-d35dc0ec-73c7-4084-a348-34197b7447ad.png" alt="img"></p>
<p>推荐阅读：<a target="_blank" rel="noopener" href="http://gityuan.com/2015/10/17/java-memory/">http://gityuan.com/2015/10/17/java-memory/</a></p>
<h1 id="DOC"><a href="#DOC" class="headerlink" title="DOC"></a>DOC</h1><h2 id="2-5-Run-Time-Data-Areas"><a href="#2-5-Run-Time-Data-Areas" class="headerlink" title="2.5. Run-Time Data Areas"></a>2.5. Run-Time Data Areas</h2><p>The Java Virtual Machine defines various run-time data areas that are used during execution of a program. Some of these data areas are created on Java Virtual Machine start-up and are destroyed only when the Java Virtual Machine exits. Other data areas are per thread. Per-thread data areas are created when a thread is created and destroyed when the thread exits.</p>
<h3 id="2-5-1-The-pc-Register"><a href="#2-5-1-The-pc-Register" class="headerlink" title="2.5.1. The pc Register"></a>2.5.1. The <code>pc</code> Register</h3><p>The Java Virtual Machine can support many threads of execution at once (JLS §17). Each Java Virtual Machine thread has its own <code>pc</code> (program counter) register. At any point, each Java Virtual Machine thread is executing the code of a single method, namely the current method (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6">§2.6</a>) for that thread. If that method is not <code>native</code>, the <code>pc</code> register contains the address of the Java Virtual Machine instruction currently being executed. If the method currently being executed by the thread is <code>native</code>, the value of the Java Virtual Machine’s <code>pc</code> register is undefined. The Java Virtual Machine’s <code>pc</code> register is wide enough to hold a <code>returnAddress</code> or a native pointer on the specific platform.</p>
<h3 id="2-5-2-Java-Virtual-Machine-Stacks"><a href="#2-5-2-Java-Virtual-Machine-Stacks" class="headerlink" title="2.5.2. Java Virtual Machine Stacks"></a>2.5.2. Java Virtual Machine Stacks</h3><p>Each Java Virtual Machine thread has a private <em>Java Virtual Machine stack</em>, created at the same time as the thread. A Java Virtual Machine stack stores frames (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6">§2.6</a>). A Java Virtual Machine stack is analogous to the stack of a conventional language such as C: it holds local variables and partial results, and plays a part in method invocation and return. Because the Java Virtual Machine stack is never manipulated directly except to push and pop frames, frames may be heap allocated. The memory for a Java Virtual Machine stack does not need to be contiguous.</p>
<p>In the First Edition of <em>The Java® Virtual Machine Specification</em>, the Java Virtual Machine stack was known as the <em>Java stack</em>.</p>
<p>This specification permits Java Virtual Machine stacks either to be of a fixed size or to dynamically expand and contract as required by the computation. If the Java Virtual Machine stacks are of a fixed size, the size of each Java Virtual Machine stack may be chosen independently when that stack is created.</p>
<p>A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of Java Virtual Machine stacks, as well as, in the case of dynamically expanding or contracting Java Virtual Machine stacks, control over the maximum and minimum sizes.</p>
<p>The following exceptional conditions are associated with Java Virtual Machine stacks:</p>
<ul>
<li>If the computation in a thread requires a larger Java Virtual Machine stack than is permitted, the Java Virtual Machine throws a <code>StackOverflowError</code>.</li>
<li>If Java Virtual Machine stacks can be dynamically expanded, and expansion is attempted but insufficient memory can be made available to effect the expansion, or if insufficient memory can be made available to create the initial Java Virtual Machine stack for a new thread, the Java Virtual Machine throws an <code>OutOfMemoryError</code>.</li>
</ul>
<h3 id="2-5-3-Heap"><a href="#2-5-3-Heap" class="headerlink" title="2.5.3. Heap"></a>2.5.3. Heap</h3><p>The Java Virtual Machine has a <em>heap</em> that is shared among all Java Virtual Machine threads. The heap is the run-time data area from which memory for all class instances and arrays is allocated.</p>
<p>The heap is created on virtual machine start-up. Heap storage for objects is reclaimed by an automatic storage management system (known as a <em>garbage collector</em>); objects are never explicitly deallocated. The Java Virtual Machine assumes no particular type of automatic storage management system, and the storage management technique may be chosen according to the implementor’s system requirements. The heap may be of a fixed size or may be expanded as required by the computation and may be contracted if a larger heap becomes unnecessary. The memory for the heap does not need to be contiguous.</p>
<p>A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of the heap, as well as, if the heap can be dynamically expanded or contracted, control over the maximum and minimum heap size.</p>
<p>The following exceptional condition is associated with the heap:</p>
<ul>
<li>If a computation requires more heap than can be made available by the automatic storage management system, the Java Virtual Machine throws an <code>OutOfMemoryError</code>.</li>
</ul>
<h3 id="2-5-4-Method-Area"><a href="#2-5-4-Method-Area" class="headerlink" title="2.5.4. Method Area"></a>2.5.4. Method Area</h3><p>The Java Virtual Machine has a <em>method area</em> that is shared among all Java Virtual Machine threads. The method area is analogous to the storage area for compiled code of a conventional language or analogous to the “text” segment in an operating system process. It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors, including the special methods (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9">§2.9</a>) used in class and instance initialization and interface initialization.</p>
<p>The method area is created on virtual machine start-up. Although the method area is logically part of the heap, simple implementations may choose not to either garbage collect or compact it. This specification does not mandate the location of the method area or the policies used to manage compiled code. The method area may be of a fixed size or may be expanded as required by the computation and may be contracted if a larger method area becomes unnecessary. The memory for the method area does not need to be contiguous.</p>
<p>A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of the method area, as well as, in the case of a varying-size method area, control over the maximum and minimum method area size.</p>
<p>The following exceptional condition is associated with the method area:</p>
<ul>
<li>If memory in the method area cannot be made available to satisfy an allocation request, the Java Virtual Machine throws an <code>OutOfMemoryError</code>.</li>
</ul>
<h3 id="2-5-5-Run-Time-Constant-Pool"><a href="#2-5-5-Run-Time-Constant-Pool" class="headerlink" title="2.5.5. Run-Time Constant Pool"></a>2.5.5. Run-Time Constant Pool</h3><p>A <em>run-time constant pool</em> is a per-class or per-interface run-time representation of the <code>constant_pool</code> table in a <code>class</code> file (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4">§4.4</a>). It contains several kinds of constants, ranging from numeric literals known at compile-time to method and field references that must be resolved at run-time. The run-time constant pool serves a function similar to that of a symbol table for a conventional programming language, although it contains a wider range of data than a typical symbol table.</p>
<p>Each run-time constant pool is allocated from the Java Virtual Machine’s method area (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">§2.5.4</a>). The run-time constant pool for a class or interface is constructed when the class or interface is created (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3">§5.3</a>) by the Java Virtual Machine.</p>
<p>The following exceptional condition is associated with the construction of the run-time constant pool for a class or interface:</p>
<ul>
<li>When creating a class or interface, if the construction of the run-time constant pool requires more memory than can be made available in the method area of the Java Virtual Machine, the Java Virtual Machine throws an <code>OutOfMemoryError</code>.</li>
</ul>
<p>See <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html">§5 (<em>Loading, Linking, and Initializing</em>)</a> for information about the construction of the run-time constant pool.</p>
<h3 id="2-5-6-Native-Method-Stacks"><a href="#2-5-6-Native-Method-Stacks" class="headerlink" title="2.5.6. Native Method Stacks"></a>2.5.6. Native Method Stacks</h3><p>An implementation of the Java Virtual Machine may use conventional stacks, colloquially called “C stacks,” to support <code>native</code> methods (methods written in a language other than the Java programming language). Native method stacks may also be used by the implementation of an interpreter for the Java Virtual Machine’s instruction set in a language such as C. Java Virtual Machine implementations that cannot load <code>native</code> methods and that do not themselves rely on conventional stacks need not supply native method stacks. If supplied, native method stacks are typically allocated per thread when each thread is created.</p>
<p>This specification permits native method stacks either to be of a fixed size or to dynamically expand and contract as required by the computation. If the native method stacks are of a fixed size, the size of each native method stack may be chosen independently when that stack is created.</p>
<p>A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of the native method stacks, as well as, in the case of varying-size native method stacks, control over the maximum and minimum method stack sizes.</p>
<p>The following exceptional conditions are associated with native method stacks:</p>
<ul>
<li>If the computation in a thread requires a larger native method stack than is permitted, the Java Virtual Machine throws a <code>StackOverflowError</code>.</li>
<li>If native method stacks can be dynamically expanded and native method stack expansion is attempted but insufficient memory can be made available, or if insufficient memory can be made available to create the initial native method stack for a new thread, the Java Virtual Machine throws an <code>OutOfMemoryError</code>.</li>
</ul>
<h2 id="2-6-Frames"><a href="#2-6-Frames" class="headerlink" title="2.6. Frames"></a>2.6. Frames</h2><p>A <em>frame</em> is used to store data and partial results, as well as to perform dynamic linking, return values for methods, and dispatch exceptions.</p>
<p>A new frame is created each time a method is invoked. A frame is destroyed when its method invocation completes, whether that completion is normal or abrupt (it throws an uncaught exception). Frames are allocated from the Java Virtual Machine stack (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.2">§2.5.2</a>) of the thread creating the frame. Each frame has its own array of local variables (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6.1">§2.6.1</a>), its own operand stack (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6.2">§2.6.2</a>), and a reference to the run-time constant pool (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.5">§2.5.5</a>) of the class of the current method.</p>
<p>A frame may be extended with additional implementation-specific information, such as debugging information.</p>
<p>The sizes of the local variable array and the operand stack are determined at compile-time and are supplied along with the code for the method associated with the frame (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.3">§4.7.3</a>). Thus the size of the frame data structure depends only on the implementation of the Java Virtual Machine, and the memory for these structures can be allocated simultaneously on method invocation.</p>
<p>Only one frame, the frame for the executing method, is active at any point in a given thread of control. This frame is referred to as the <em>current frame</em>, and its method is known as the <em>current method</em>. The class in which the current method is defined is the <em>current class</em>. Operations on local variables and the operand stack are typically with reference to the current frame.</p>
<p>A frame ceases to be current if its method invokes another method or if its method completes. When a method is invoked, a new frame is created and becomes current when control transfers to the new method. On method return, the current frame passes back the result of its method invocation, if any, to the previous frame. The current frame is then discarded as the previous frame becomes the current one.</p>
<p>Note that a frame created by a thread is local to that thread and cannot be referenced by any other thread.</p>
<p><img src="/2024/04/19/JMM/image-20230808162509989.png" alt="image-20230808162509989"></p>
<h3 id="2-6-1-Local-Variables"><a href="#2-6-1-Local-Variables" class="headerlink" title="2.6.1. Local Variables"></a>2.6.1. Local Variables</h3><p>Each frame (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6">§2.6</a>) contains an array of variables known as its <em>local variables</em>. The length of the local variable array of a frame is determined at compile-time and supplied in the binary representation of a class or interface along with the code for the method associated with the frame (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.3">§4.7.3</a>).</p>
<p>A single local variable can hold a value of type <code>boolean</code>, <code>byte</code>, <code>char</code>, <code>short</code>, <code>int</code>, <code>float</code>, <code>reference</code>, or <code>returnAddress</code>. A pair of local variables can hold a value of type <code>long</code> or <code>double</code>.</p>
<p>Local variables are addressed by indexing. The index of the first local variable is zero. An integer is considered to be an index into the local variable array if and only if that integer is between zero and one less than the size of the local variable array.</p>
<p>A value of type <code>long</code> or type <code>double</code> occupies two consecutive local variables. Such a value may only be addressed using the lesser index. For example, a value of type <code>double</code> stored in the local variable array at index <em>n</em> actually occupies the local variables with indices <em>n</em> and <em>n</em>+1; however, the local variable at index <em>n</em>+1 cannot be loaded from. It can be stored into. However, doing so invalidates the contents of local variable <em>n</em>.</p>
<p>The Java Virtual Machine does not require <em>n</em> to be even. In intuitive terms, values of types <code>long</code> and <code>double</code> need not be 64-bit aligned in the local variables array. Implementors are free to decide the appropriate way to represent such values using the two local variables reserved for the value.</p>
<p>The Java Virtual Machine uses local variables to pass parameters on method invocation. On class method invocation, any parameters are passed in consecutive local variables starting from local variable <em>0</em>. On instance method invocation, local variable <em>0</em> is always used to pass a reference to the object on which the instance method is being invoked (<code>this</code> in the Java programming language). Any parameters are subsequently passed in consecutive local variables starting from local variable <em>1</em>.</p>
<h3 id="2-6-2-Operand-Stacks"><a href="#2-6-2-Operand-Stacks" class="headerlink" title="2.6.2. Operand Stacks"></a>2.6.2. Operand Stacks</h3><p>Each frame (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6">§2.6</a>) contains a last-in-first-out (LIFO) stack known as its <em>operand stack</em>. The maximum depth of the operand stack of a frame is determined at compile-time and is supplied along with the code for the method associated with the frame (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.3">§4.7.3</a>).</p>
<p>Where it is clear by context, we will sometimes refer to the operand stack of the current frame as simply the operand stack.</p>
<p>The operand stack is empty when the frame that contains it is created. The Java Virtual Machine supplies instructions to load constants or values from local variables or fields onto the operand stack. Other Java Virtual Machine instructions take operands from the operand stack, operate on them, and push the result back onto the operand stack. The operand stack is also used to prepare parameters to be passed to methods and to receive method results.</p>
<p>For example, the <em>iadd</em> instruction (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.iadd">§<em>iadd</em></a>) adds two <code>int</code> values together. It requires that the <code>int</code> values to be added be the top two values of the operand stack, pushed there by previous instructions. Both of the <code>int</code> values are popped from the operand stack. They are added, and their sum is pushed back onto the operand stack. Subcomputations may be nested on the operand stack, resulting in values that can be used by the encompassing computation.</p>
<p>Each entry on the operand stack can hold a value of any Java Virtual Machine type, including a value of type <code>long</code> or type <code>double</code>.</p>
<p>Values from the operand stack must be operated upon in ways appropriate to their types. It is not possible, for example, to push two <code>int</code> values and subsequently treat them as a <code>long</code> or to push two <code>float</code> values and subsequently add them with an <em>iadd</em> instruction. A small number of Java Virtual Machine instructions (the <em>dup</em> instructions (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.dup">§<em>dup</em></a>) and <em>swap</em> (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.swap">§<em>swap</em></a>)) operate on run-time data areas as raw values without regard to their specific types; these instructions are defined in such a way that they cannot be used to modify or break up individual values. These restrictions on operand stack manipulation are enforced through <code>class</code> file verification (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.10">§4.10</a>).</p>
<p>At any point in time, an operand stack has an associated depth, where a value of type <code>long</code> or <code>double</code> contributes two units to the depth and a value of any other type contributes one unit.</p>
<h3 id="2-6-3-Dynamic-Linking"><a href="#2-6-3-Dynamic-Linking" class="headerlink" title="2.6.3. Dynamic Linking"></a>2.6.3. Dynamic Linking</h3><p>Each frame (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6">§2.6</a>) contains a reference to the run-time constant pool (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.5">§2.5.5</a>) for the type of the current method to support <em>dynamic linking</em> of the method code. The <code>class</code> file code for a method refers to methods to be invoked and variables to be accessed via symbolic references. Dynamic linking translates these symbolic method references into concrete method references, loading classes as necessary to resolve as-yet-undefined symbols, and translates variable accesses into appropriate offsets in storage structures associated with the run-time location of these variables.</p>
<p>This late binding of the methods and variables makes changes in other classes that a method uses less likely to break this code.</p>
<h3 id="2-6-4-Normal-Method-Invocation-Completion"><a href="#2-6-4-Normal-Method-Invocation-Completion" class="headerlink" title="2.6.4. Normal Method Invocation Completion"></a>2.6.4. Normal Method Invocation Completion</h3><p>A method invocation <em>completes normally</em> if that invocation does not cause an exception (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.10">§2.10</a>) to be thrown, either directly from the Java Virtual Machine or as a result of executing an explicit <code>throw</code> statement. If the invocation of the current method completes normally, then a value may be returned to the invoking method. This occurs when the invoked method executes one of the return instructions (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.8">§2.11.8</a>), the choice of which must be appropriate for the type of the value being returned (if any).</p>
<p>The current frame (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6">§2.6</a>) is used in this case to restore the state of the invoker, including its local variables and operand stack, with the program counter of the invoker appropriately incremented to skip past the method invocation instruction. Execution then continues normally in the invoking method’s frame with the returned value (if any) pushed onto the operand stack of that frame.</p>
<h3 id="2-6-5-Abrupt-Method-Invocation-Completion"><a href="#2-6-5-Abrupt-Method-Invocation-Completion" class="headerlink" title="2.6.5. Abrupt Method Invocation Completion"></a>2.6.5. Abrupt Method Invocation Completion</h3><p>A method invocation <em>completes abruptly</em> if execution of a Java Virtual Machine instruction within the method causes the Java Virtual Machine to throw an exception (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.10">§2.10</a>), and that exception is not handled within the method. Execution of an <em>athrow</em> instruction (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.athrow">§<em>athrow</em></a>) also causes an exception to be explicitly thrown and, if the exception is not caught by the current method, results in abrupt method invocation completion. A method invocation that completes abruptly never returns a value to its invoker.</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>JvmMemoryStructure</p><p><a href="http://example.com/2024/04/19/JMM/">http://example.com/2024/04/19/JMM/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>white crow</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2024-04-19</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-04-25</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Core/">Core</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/04/19/TempEdit/"><i class="level-item fas fa-chevron-left"></i><span class="level-item"> </span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/03/25/GraphicsOverriew/"><span class="level-item">Graphics</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Java-Heap-java堆"><span class="level-left"><span class="level-item">1</span><span class="level-item">Java Heap java堆</span></span></a></li><li><a class="level is-mobile" href="#Method-Area-方法区-非堆"><span class="level-left"><span class="level-item">2</span><span class="level-item">Method Area 方法区/非堆</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#常量池介绍"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">常量池介绍</span></span></a></li></ul></li><li><a class="level is-mobile" href="#VMStack-java方法栈"><span class="level-left"><span class="level-item">3</span><span class="level-item">VMStack  java方法栈</span></span></a></li><li><a class="level is-mobile" href="#本地方法栈-native方法栈"><span class="level-left"><span class="level-item">4</span><span class="level-item">本地方法栈 native方法栈</span></span></a></li><li><a class="level is-mobile" href="#程序计数器"><span class="level-left"><span class="level-item">5</span><span class="level-item">程序计数器</span></span></a></li><li><a class="level is-mobile" href="#DOC"><span class="level-left"><span class="level-item">6</span><span class="level-item">DOC</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-5-Run-Time-Data-Areas"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">2.5. Run-Time Data Areas</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-5-1-The-pc-Register"><span class="level-left"><span class="level-item">6.1.1</span><span class="level-item">2.5.1. The pc Register</span></span></a></li><li><a class="level is-mobile" href="#2-5-2-Java-Virtual-Machine-Stacks"><span class="level-left"><span class="level-item">6.1.2</span><span class="level-item">2.5.2. Java Virtual Machine Stacks</span></span></a></li><li><a class="level is-mobile" href="#2-5-3-Heap"><span class="level-left"><span class="level-item">6.1.3</span><span class="level-item">2.5.3. Heap</span></span></a></li><li><a class="level is-mobile" href="#2-5-4-Method-Area"><span class="level-left"><span class="level-item">6.1.4</span><span class="level-item">2.5.4. Method Area</span></span></a></li><li><a class="level is-mobile" href="#2-5-5-Run-Time-Constant-Pool"><span class="level-left"><span class="level-item">6.1.5</span><span class="level-item">2.5.5. Run-Time Constant Pool</span></span></a></li><li><a class="level is-mobile" href="#2-5-6-Native-Method-Stacks"><span class="level-left"><span class="level-item">6.1.6</span><span class="level-item">2.5.6. Native Method Stacks</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-6-Frames"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">2.6. Frames</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-6-1-Local-Variables"><span class="level-left"><span class="level-item">6.2.1</span><span class="level-item">2.6.1. Local Variables</span></span></a></li><li><a class="level is-mobile" href="#2-6-2-Operand-Stacks"><span class="level-left"><span class="level-item">6.2.2</span><span class="level-item">2.6.2. Operand Stacks</span></span></a></li><li><a class="level is-mobile" href="#2-6-3-Dynamic-Linking"><span class="level-left"><span class="level-item">6.2.3</span><span class="level-item">2.6.3. Dynamic Linking</span></span></a></li><li><a class="level is-mobile" href="#2-6-4-Normal-Method-Invocation-Completion"><span class="level-left"><span class="level-item">6.2.4</span><span class="level-item">2.6.4. Normal Method Invocation Completion</span></span></a></li><li><a class="level is-mobile" href="#2-6-5-Abrupt-Method-Invocation-Completion"><span class="level-left"><span class="level-item">6.2.5</span><span class="level-item">2.6.5. Abrupt Method Invocation Completion</span></span></a></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatarPng.png" alt="White Crow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">White Crow</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">79</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">4</p></a></div></div></nav></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a><p class="is-size-7"><span>&copy; 2024 white crow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://github.com/WhileCrow"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>