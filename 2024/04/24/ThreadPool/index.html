<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>ThreadPool - Crow&#039;s Sky</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Crow&#039;s Sky"><meta name="msapplication-TileImage" content="/img/avatarCircle.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Crow&#039;s Sky"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="https:&amp;#x2F;&amp;#x2F;tech.meituan.com&amp;#x2F;2020&amp;#x2F;04&amp;#x2F;02&amp;#x2F;java-pooling-pratice-in-meituan.html 12345678910111213141516171819202122232425262728293031323334&amp;#x2F;** * Creates a new &amp;amp;#123;@code ThreadPoolExecutor&amp;amp;#125; with the gi"><meta property="og:type" content="blog"><meta property="og:title" content="ThreadPool"><meta property="og:url" content="http://example.com/2024/04/24/ThreadPool/"><meta property="og:site_name" content="Crow&#039;s Sky"><meta property="og:description" content="https:&amp;#x2F;&amp;#x2F;tech.meituan.com&amp;#x2F;2020&amp;#x2F;04&amp;#x2F;02&amp;#x2F;java-pooling-pratice-in-meituan.html 12345678910111213141516171819202122232425262728293031323334&amp;#x2F;** * Creates a new &amp;amp;#123;@code ThreadPoolExecutor&amp;amp;#125; with the gi"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/2024/04/24/ThreadPool/31bad766983e212431077ca8da92762050214.png"><meta property="og:image" content="http://example.com/2024/04/24/ThreadPool/java-thread-x-executors-1.png"><meta property="og:image" content="https://github.com/WhileCrow/BlackCrow/assets/26061465/f2b23a0e-ba3b-4be8-be4c-001699925978"><meta property="og:image" content="http://example.com/2024/04/24/ThreadPool/image-20240424204306358.png"><meta property="og:image" content="http://example.com/2024/04/24/ThreadPool/image-20240426113224120.png"><meta property="article:published_time" content="2024-04-24T11:55:00.000Z"><meta property="article:modified_time" content="2024-07-04T06:15:34.932Z"><meta property="article:author" content="White Crow"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2024/04/24/ThreadPool/31bad766983e212431077ca8da92762050214.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2024/04/24/ThreadPool/"},"headline":"ThreadPool","image":["http://example.com/2024/04/24/ThreadPool/31bad766983e212431077ca8da92762050214.png","http://example.com/2024/04/24/ThreadPool/java-thread-x-executors-1.png","http://example.com/2024/04/24/ThreadPool/image-20240424204306358.png","http://example.com/2024/04/24/ThreadPool/image-20240426113224120.png"],"datePublished":"2024-04-24T11:55:00.000Z","dateModified":"2024-07-04T06:15:34.932Z","author":{"@type":"Person","name":"white crow"},"publisher":{"@type":"Organization","name":"Crow's Sky","logo":{"@type":"ImageObject","url":"http://example.com/img/avatarCircle.png"}},"description":"https:&#x2F;&#x2F;tech.meituan.com&#x2F;2020&#x2F;04&#x2F;02&#x2F;java-pooling-pratice-in-meituan.html 12345678910111213141516171819202122232425262728293031323334&#x2F;** * Creates a new &amp;#123;@code ThreadPoolExecutor&amp;#125; with the gi"}</script><link rel="canonical" href="http://example.com/2024/04/24/ThreadPool/"><link rel="icon" href="/img/avatarCircle.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/WhileCrow"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-10-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-04-24T11:55:00.000Z" title="4/24/2024, 7:55:00 PM">2024-04-24</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-07-04T06:15:34.932Z" title="7/4/2024, 2:15:34 PM">2024-07-04</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">37 minutes read (About 5518 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">ThreadPool</h1><div class="content"><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment"> * parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment"> *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment"> *        核心线程数量，线程常驻即使空闲，除非设置了allowCoreThreadTimeOut</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment"> *        pool</span></span><br><span class="line"><span class="comment"> *        最大线程数，整个线程池的线程数量（核心线程数+普通线程数）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment"> *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment"> *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment"> *        超过核心线程数后的空闲线程存活时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment"> * 				时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment"> *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment"> *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment"> *        工作队列：任务被执行前的存放队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory the factory to use when the executor</span></span><br><span class="line"><span class="comment"> *        creates a new thread</span></span><br><span class="line"><span class="comment"> *        executor创建线程的工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler the handler to use when execution is blocked</span></span><br><span class="line"><span class="comment"> *        because the thread bounds and queue capacities are reached</span></span><br><span class="line"><span class="comment"> *        ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/24/ThreadPool/31bad766983e212431077ca8da92762050214.png" alt="图4 任务调度流程"></p>
<p>通过<code>Executors</code>工具类可以创建多种类型的线程池，包括：</p>
<ul>
<li><p><code>FixedThreadPool</code>：固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。<strong>核心线程数为n，最大线程数为n，任务队列长度为Interger.MAX_VALUE的LinkedBlockingQueue</strong></p>
</li>
<li><p><code>SingleThreadExecutor</code>： 只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。<strong>核心线程数、最大线程数都为1，任务队列长度为Interger.MAX_VALUE的LinkedBlockingQueue</strong></p>
</li>
<li><p><code>CachedThreadPool</code>： 可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。<strong>核心线程数为0，最大线程数为Interger.MAX_VAULE，任务队列为无容量的SynchronousQueue</strong></p>
</li>
<li><p><code>ScheduledThreadPool</code>：给定的延迟后运行任务或者定期执行任务的线程池。<strong>核心线程为n，最大线程为Interger.MAX_VALUE，任务队列长度为最大Interger_MAX_VALUE的DelayQueue</strong></p>
</li>
</ul>
<p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<p><code>Executors</code> 返回线程池对象的弊端如下：</p>
<ul>
<li><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code>:使用的是无界的 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
<li><code>CachedThreadPool</code>:使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM。</li>
<li><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code>:使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
</ul>
<h2 id="ThreadPoolExecutor使用详解"><a href="#ThreadPoolExecutor使用详解" class="headerlink" title="ThreadPoolExecutor使用详解"></a>ThreadPoolExecutor使用详解</h2><p>其实java线程池的实现原理很简单，说白了就是一个线程集合workerSet和一个阻塞队列workQueue。当用户向线程池提交一个任务(也就是线程)时，线程池会先将任务放入workQueue中。workerSet中的线程会不断的从workQueue中获取线程然后执行。当workQueue中没有任务的时候，worker就会阻塞，直到队列中有任务了就取出来继续执行。</p>
<p><img src="/2024/04/24/ThreadPool/java-thread-x-executors-1.png" alt="img"></p>
<h3 id="Execute原理"><a href="#Execute原理" class="headerlink" title="# Execute原理"></a><a href="#execute%E5%8E%9F%E7%90%86">#</a> Execute原理</h3><p><img src="https://github.com/WhileCrow/BlackCrow/assets/26061465/f2b23a0e-ba3b-4be8-be4c-001699925978" alt="image"><br><a target="_blank" rel="noopener" href="https://excalidraw.com/#json=Y7a8uMRrIrZNGfr7GnQ0M,2qUB-ZmXM-hwP0a3MWnA1A">https://excalidraw.com/#json=Y7a8uMRrIrZNGfr7GnQ0M,2qUB-ZmXM-hwP0a3MWnA1A</a></p>
<p>当一个任务提交至线程池之后:</p>
<ol>
<li>线程池首先当前运行的线程数量是否少于corePoolSize。如果是，则创建一个新的工作线程来执行任务。如果都在执行任务，则进入2.</li>
<li>判断BlockingQueue是否已经满了，倘若还没有满，则将线程放入BlockingQueue。否则进入3.</li>
<li>如果创建一个新的工作线程将使当前运行的线程数量超过maximumPoolSize，则交给RejectedExecutionHandler来处理任务。</li>
</ol>
<blockquote>
<p>运行机制（当任务来了之后的执行流程）：</p>
<ol>
<li>判断核心线程数是否已满；如果未满创建核心线程执行任务；如果满了执行后续操作。</li>
<li>判断任务队列是否已满；如果未满将任务添加到队列；如果满了执行后续流程。</li>
<li>判断最大线程数是否已满；如果未满创建临时线程执行任务；如果满了执行后续流程。</li>
<li>执行拒绝策略（内置4种拒绝策略+自定义的拒绝策略）。</li>
</ol>
</blockquote>
<p>当ThreadPoolExecutor创建新线程时，通过CAS来更新线程池的状态ctl.</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="# 参数"></a><a href="#%E5%8F%82%E6%95%B0">#</a> 参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>corePoolSize</code> 线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize, 即使有其他空闲线程能够执行新来的任务, 也会继续创建线程；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</li>
<li><code>workQueue</code> 用来保存等待被执行的任务的阻塞队列. 在JDK中提供了如下阻塞队列: 具体可以参考<a href>JUC 集合: BlockQueue详解</a><ul>
<li><code>ArrayBlockingQueue</code>: 基于数组结构的有界阻塞队列，按FIFO排序任务；</li>
<li><code>LinkedBlockingQueue</code>: 基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQueue；</li>
<li><code>SynchronousQueue</code>: 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue；</li>
<li><code>PriorityBlockingQueue</code>: 具有优先级的无界阻塞队列；</li>
</ul>
</li>
</ul>
<p><code>LinkedBlockingQueue</code>比<code>ArrayBlockingQueue</code>在插入删除节点性能方面更优，但是二者在<code>put()</code>, <code>take()</code>任务的时均需要加锁，<code>SynchronousQueue</code>使用无锁算法，根据节点的状态判断执行，而不需要用到锁，其核心是<code>Transfer.transfer()</code>.</p>
<ul>
<li><code>maximumPoolSize </code> 线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize；当阻塞队列是无界队列, 则maximumPoolSize则不起作用, 因为无法提交至核心线程池的线程会一直持续地放入workQueue.</li>
<li><code>keepAliveTime </code> 线程空闲时的存活时间，即当线程没有任务执行时，该线程继续存活的时间；默认情况下，该参数只在线程数大于corePoolSize时才有用, 超过这个时间的空闲线程将被终止；</li>
<li><code>unit </code> keepAliveTime的单位</li>
<li><code>threadFactory </code> 创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名。默认为DefaultThreadFactory</li>
<li><code>handler </code> 线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略:<ul>
<li><code>AbortPolicy</code>: 直接抛出异常，默认策略；</li>
<li><code>CallerRunsPolicy</code>: 用调用者所在的线程来执行任务；</li>
<li><code>DiscardOldestPolicy</code>: 丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>
<li><code>DiscardPolicy</code>: 直接丢弃任务；</li>
</ul>
</li>
</ul>
<p>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p>
<h1 id="※线程池ThreadPoolExecutor"><a href="#※线程池ThreadPoolExecutor" class="headerlink" title="※线程池ThreadPoolExecutor"></a>※线程池ThreadPoolExecutor</h1><h2 id="常见的线程池有："><a href="#常见的线程池有：" class="headerlink" title="常见的线程池有："></a>常见的线程池有：</h2><h3 id="无缓存线程"><a href="#无缓存线程" class="headerlink" title="无缓存线程"></a>无缓存线程</h3><h4 id="·-定长线程池（最常见，如Glide）"><a href="#·-定长线程池（最常见，如Glide）" class="headerlink" title="· 定长线程池（最常见，如Glide）"></a>· 定长线程池（最常见，如Glide）</h4><p>FixedThreadPool：<strong>根据入参决定有多少个核心线程，无缓存线程。</strong> 可重用固定线程数的线程池。（适用于负载比较重的服务器） FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列，该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列 中的任务。</p>
<h4 id="·-单线程线程池"><a href="#·-单线程线程池" class="headerlink" title="· 单线程线程池"></a>· 单线程线程池</h4><p>SingleThreadExecutor：<strong>只有一个核心线程，最大线程也为1，无缓存线程。所有任务在此线程中FIFO进行</strong>只会创建一个线程执行任务。（适用于需要保证顺序执行各个任 务；并且在任意时间点，没有多线程活动的场景。） SingleThreadExecutorl也使用无界队列LinkedBlockingQueue作为工作队列 若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先 出的顺序执行队列中的任务。</p>
<h4 id="·-定时线程池"><a href="#·-定时线程池" class="headerlink" title="· 定时线程池"></a>· 定时线程池</h4><p>ScheduledThreadPool：<strong>只有入参数量的核心线程，无缓存线程</strong>。继承自ThreadPoolExecutor。它主要用来在给定的延迟之后运行 任务，或者定期执行任务。使用DelayQueue作为任务队列。如newScheduledThreadPool，用于定时任务。</p>
<h3 id="无核心线程"><a href="#无核心线程" class="headerlink" title="无核心线程"></a>无核心线程</h3><h4 id="·-缓存线程池"><a href="#·-缓存线程池" class="headerlink" title="· 缓存线程池"></a>· 缓存线程池</h4><p>CachedThreadPool：<strong>无核心线程，无限制地增加执行完成就销毁(根据keepaliveTime决定)的缓存线程</strong>，是一个会根据需要调整线程数量的线程池。（大小无界，适用于执行很 多的短期异步任务的小程序，或负载较轻的服务器） CachedThreadPool使用没有容量的SynchronousQueue作为线程池的工作队列，但 CachedThreadPool的maximumPool是无界的。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线 程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕 后，将返回线程池进行复用。</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li>降低资源消耗：通过重复利用现有的线程来执行任务，避免多次创建和销毁线程。<strong>一个线程保留1M大小的内存空间，有效降低OOM</strong></li>
<li>提高相应速度：因为省去了创建线程这个步骤，所以在拿到任务时，可以立刻开始执行。</li>
</ol>
<h2 id="线程数应该怎么设置"><a href="#线程数应该怎么设置" class="headerlink" title="线程数应该怎么设置"></a>线程数应该怎么设置</h2><ul>
<li>如果任务是IO密集型，一般线程数需要设置2倍CPU数以上（2N），以此来尽量利用CPU资源。</li>
<li>如果任务是CPU密集型，一般线程数量只需要设置CPU数加1即可，更多的线程数也只能增加上下文切换，不能增加CPU利用率。</li>
</ul>
<blockquote>
<p>在计算密集型任务中，将线程池大小设置为 CPU 核心数 + 1 的原因是为了应对可能出现的阻塞情况。 虽然计算密集型任务主要消耗 CPU 资源，但在实际应用中，任务内部可能仍然存在一些阻塞操作， 例如：<br>同步 IO： 如果任务需要进行磁盘读写或网络通信等 IO 操作，并且这些操作是同步阻塞的，那么当前线程会被阻塞， 无法继续执行计算任务。<br>锁竞争： 如果任务中存在对共享资源的访问，并且使用了锁机制进行同步， 那么当多个线程同时竞争锁时， 部分线程会被阻塞， 等待获取锁。<br>页面错误： 当线程访问的内存页面不在物理内存中时，会发生页面错误， 导致线程被阻塞， 等待操作系统将页面从磁盘加载到内存。  如果线程池大小刚好等于 CPU 核心数，那么当一个线程被阻塞时，CPU 就无法充分利用，导致整体性能下降。 而增加一个额外的线程，可以确保在某个线程被阻塞时， 仍然有足够的线程可以继续执行计算任务， 从而提高 CPU 利用率和整体性能。 当然，这只是一个经验法则，并不是绝对的。 在某些情况下， 如果任务中不存在阻塞操作， 或者阻塞情况非常少见， 那么将线程池大小设置为 CPU 核心数也可能足够。 最佳的线程池大小仍然需要根据你的具体应用场景和硬件环境进行调整和测试。 </p>
</blockquote>
<p>简单来说就是 io多，则用更多线程充分利用cpu；计算多，则用少的线程数减少线程切换，但仍存在的io操作使数量应为n+1;</p>
<p>Android一般认为多数操作是IO密集，如网络io，本地文件io，所以会设置2N</p>
<h3 id="Android系统对每个进程线程数限制"><a href="#Android系统对每个进程线程数限制" class="headerlink" title="Android系统对每个进程线程数限制"></a>Android系统对每个进程线程数限制</h3><p>root 下adb shell cat /proc/sys/kernel/threads-max</p>
<p>结果如：57439</p>
<p>但每个线程1M左右，基本上几百个线程就可能OOM了</p>
<h3 id="常见的三方库线程池默认数量"><a href="#常见的三方库线程池默认数量" class="headerlink" title="常见的三方库线程池默认数量"></a>常见的三方库线程池默认数量</h3><h4 id="Okhttp"><a href="#Okhttp" class="headerlink" title="Okhttp"></a>Okhttp</h4><p>OkHttp中的线程池是定义在分发器中的，即定义在Dispatcher</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">    executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> SynchronousQueue&lt;&gt;(), Util.threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>, <span class="keyword">false</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>用的其实相当于就是一个无核心线程，最大线程池为Integer.MAX_VALUE，任务队列为SynchronousQueue的缓存线程池</strong></p>
<p>高并发，最大吞吐量。SynchronousQueue队列是无容量队列，<br> 在OkHttp中，配置的线程池的核心线程数为0，最大线程数为Integer.MAX_VALUE，线程的存活时间为60s，采用的队列是SynchronousQueue。</p>
<ol>
<li>okhttp <code>默认同时支持 64 个异步请求(不考虑同步请求)，一个 host 同时最多请求 5 个</code></li>
<li>okhttp 内部的<code>线程池都是 CacheThreadPool</code>：核心线程数为 0，非核心线程数无限，永远添加不到等待队列中</li>
<li><code>okhttpClient 如果不单例，会出现 oom</code>：因为大量的 Dispatcher 对象，不同的对象会使用不同的线程去发起网络请求，从而导致线程过多，OOM</li>
</ol>
<h4 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h4><p><strong>Glide用的都是核心线程数与最大线程数一致（cpu数量与4的最小值），任务队列为PriorityBlockingQueue的定长线程池。</strong>（所以Glide的最大并发量是四个图片?）</p>
<p>glide加载的线程池的配置，使用cpu数量与4的最小值，即线程池的核心线程和最大线程数不超过4个</p>
<p><img src="/2024/04/24/ThreadPool/image-20240424204306358.png" alt="image-20240424204306358"></p>
<p><img src="/2024/04/24/ThreadPool/image-20240426113224120.png" alt="image-20240426113224120"></p>
<h2 id="线程池关闭方法区别"><a href="#线程池关闭方法区别" class="headerlink" title="线程池关闭方法区别"></a>线程池关闭方法区别</h2><p>shutdown() 、 shutdownNow() 、 awaitTermination() 的用法和区别</p>
<h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h4><p>将线程池状态置为SHUTDOWN,并不会立即停止：</p>
<ul>
<li>停止接收外部submit的任务</li>
<li>内部正在跑的任务和队列里等待的任务，会执行完</li>
<li>等到第二步完成后，才真正停止</li>
</ul>
<h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a>shutdownNow()</h4><p>将线程池状态置为STOP。企图立即停止，事实上不一定：</p>
<ul>
<li>跟shutdown()一样，先停止接收外部提交的任务</li>
<li>忽略队列里等待的任务</li>
<li>尝试将正在跑的任务interrupt中断</li>
</ul>
<p>返回未执行的任务列表</p>
<h4 id="awaitTermination"><a href="#awaitTermination" class="headerlink" title="awaitTermination()"></a>awaitTermination()</h4><p>awaitTermination(long timeOut, TimeUnit unit)</p>
<p>当前线程阻塞，直到</p>
<ul>
<li>等所有已提交的任务（包括正在跑的和队列中等待的）执行完</li>
<li>或者等超时时间到</li>
<li>或者线程被中断，抛出InterruptedException</li>
</ul>
<p>然后返回true（shutdown请求后所有任务执行完毕）或false（已超时）</p>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ul>
<li><strong>优雅的关闭</strong>，用shutdown()，<u>停止接受任务</u>并<u>等待进行中</u>的和<u>队列中的任务</u>都执行完后停止。</li>
<li><strong>想立马中断并关闭</strong>，并得到未执行任务列表，用shutdownNow()，会<u>interrupt正在进行的任务</u>并<u>忽略队列中任务</u>，返回未执行的任务队列</li>
<li><strong>优雅的关闭</strong>，并允许关闭声明后新任务能提交，用awaitTermination()</li>
</ul>
<h2 id="线程池都有哪几种工作队列？"><a href="#线程池都有哪几种工作队列？" class="headerlink" title="线程池都有哪几种工作队列？"></a>线程池都有哪几种工作队列？</h2><p><strong>ArrayBlockingQueue</strong>：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。</p>
<p><strong>LinkedBlockingQueue</strong>：是一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量 通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()、newSingleThreadExecutor使用了 这个队列。</p>
<p><strong>SynchronousQueue</strong>：是一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用 移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue。</p>
<p><strong>DelayedWorkQueue</strong>：是一个阻塞队列。保证添加到队列中的任务，会按照任务的延时时间进行排序，延时时间少的任务首先被获取。newScheduledThreadPool使用了这个队列。</p>
<p>假设向线程池提交任务时，核心线程都被占用的情况下：</p>
<p><code>ArrayBlockingQueue</code>：基于数组的阻塞队列，初始化需要指定固定大小。</p>
<p>​    当使用此队列时，向线程池提交任务，会首先加入到等待队列中，当等待队列满了之后，再次提交任务，尝试加入队列就会失败，这时就会检查如果当前线程池中的线程数未达到最大线程，则会新建线程执行新提交的任务。所以最终可能出现后提交的任务先执行，而先提交的任务一直在等待。</p>
<p><code>LinkedBlockingQueue</code>：基于链表实现的阻塞队列，初始化可以指定大小，也可以不指定。</p>
<p>​    当指定大小后，行为就和<code>ArrayBlockingQueu</code>一致。而如果未指定大小，则会使用默认的<code>Integer.MAX_VALUE</code>作为队列大小。这时候就会出现线程池的最大线程数参数无用，因为无论如何，向线程池提交任务加入等待队列都会成功。最终意味着所有任务都是在核心线程执行。如果核心线程一直被占，那就一直等待。</p>
<p><code>SynchronousQueue</code> : 无容量的队列。</p>
<p>​    使用此队列意味着希望获得最大并发量。因为无论如何，向线程池提交任务，往队列提交任务都会失败。而失败后如果没有空闲的非核心线程，就会检查如果当前线程池中的线程数未达到最大线程，则会新建线程执行新提交的任务。完全没有任何等待，唯一制约它的就是最大线程数的个数。因此一般配合<code>Integer.MAX_VALUE</code>就实现了真正的无等待。</p>
<p>//lqr:TODO  <a target="_blank" rel="noopener" href="https://juejin.cn/post/6847902225730109454">https://juejin.cn/post/6847902225730109454</a></p>
<h2 id="拒绝策略rejectHander"><a href="#拒绝策略rejectHander" class="headerlink" title="拒绝策略rejectHander"></a>拒绝策略rejectHander</h2><p>当 Executor 已关闭时，以及当 Executor 对最大线程和工作队列容量使用有限界限且已饱和时，在方法execute(Runnable)中提交的新任务将被拒绝。在任一情况下， execute方法都会调用其<code>RejectedExecutionHandler</code>的<code>RejectedExecutionHandler.rejectedExecution(Runnable, ThreadPoolExecutor)</code>方法。提供了四种预定义的处理程序策略：</p>
<ol>
<li><p>在默认的ThreadPoolExecutor.AbortPolicy中，处理程序在被拒绝时会抛出运行时<code>RejectedExecutionException </code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">   <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">   e.toString());</span><br></pre></td></tr></table></figure></li>
<li><p>在ThreadPoolExecutor.CallerRunsPolicy中，调用execute的线程本身会运行任务。这提供了一种简单的反馈控制机制，可以减慢提交新任务的速度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">		r.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在ThreadPoolExecutor.DiscardPolicy中，无法执行的任务将被直接丢弃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;do nothing</span><br></pre></td></tr></table></figure></li>
<li><p>在ThreadPoolExecutor.DiscardOldestPolicy中，如果执行器未关闭，则工作队列头部的任务将被删除，然后重试执行（这可能会再次失败，导致重复此操作。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">    e.getQueue().poll();</span><br><span class="line">    e.execute(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="如果提交任务时，线程池队列已满，会发生什么"><a href="#如果提交任务时，线程池队列已满，会发生什么" class="headerlink" title="如果提交任务时，线程池队列已满，会发生什么"></a>如果提交任务时，线程池队列已满，会发生什么</h2><p>如果使用的LinkedBlockingQueue，也就是无界队列的话，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以无限存放任务；如果使用的是有界队列比方说ArrayBlockingQueue的话，则会使用拒绝策略RejectedExecutionHandler处理满了的任务。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>ThreadPool</p><p><a href="http://example.com/2024/04/24/ThreadPool/">http://example.com/2024/04/24/ThreadPool/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>white crow</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2024-04-24</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-07-04</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/06/04/FirstScreenCost/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">FirstScreenCost.md</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/04/19/TempEdit/"><span class="level-item"> </span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#ThreadPoolExecutor使用详解"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">ThreadPoolExecutor使用详解</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Execute原理"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item"> Execute原理</span></span></a></li><li><a class="level is-mobile" href="#参数"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item"> 参数</span></span></a></li></ul></li></ul><li><a class="level is-mobile" href="#※线程池ThreadPoolExecutor"><span class="level-left"><span class="level-item">2</span><span class="level-item">※线程池ThreadPoolExecutor</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#常见的线程池有："><span class="level-left"><span class="level-item">2.1</span><span class="level-item">常见的线程池有：</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#无缓存线程"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">无缓存线程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#·-定长线程池（最常见，如Glide）"><span class="level-left"><span class="level-item">2.1.1.1</span><span class="level-item">· 定长线程池（最常见，如Glide）</span></span></a></li><li><a class="level is-mobile" href="#·-单线程线程池"><span class="level-left"><span class="level-item">2.1.1.2</span><span class="level-item">· 单线程线程池</span></span></a></li><li><a class="level is-mobile" href="#·-定时线程池"><span class="level-left"><span class="level-item">2.1.1.3</span><span class="level-item">· 定时线程池</span></span></a></li></ul></li><li><a class="level is-mobile" href="#无核心线程"><span class="level-left"><span class="level-item">2.1.2</span><span class="level-item">无核心线程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#·-缓存线程池"><span class="level-left"><span class="level-item">2.1.2.1</span><span class="level-item">· 缓存线程池</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#作用"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">作用</span></span></a></li><li><a class="level is-mobile" href="#线程数应该怎么设置"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">线程数应该怎么设置</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Android系统对每个进程线程数限制"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">Android系统对每个进程线程数限制</span></span></a></li><li><a class="level is-mobile" href="#常见的三方库线程池默认数量"><span class="level-left"><span class="level-item">2.3.2</span><span class="level-item">常见的三方库线程池默认数量</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Okhttp"><span class="level-left"><span class="level-item">2.3.2.1</span><span class="level-item">Okhttp</span></span></a></li><li><a class="level is-mobile" href="#Glide"><span class="level-left"><span class="level-item">2.3.2.2</span><span class="level-item">Glide</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#线程池关闭方法区别"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">线程池关闭方法区别</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#shutdown"><span class="level-left"><span class="level-item">2.4.1.1</span><span class="level-item">shutdown()</span></span></a></li><li><a class="level is-mobile" href="#shutdownNow"><span class="level-left"><span class="level-item">2.4.1.2</span><span class="level-item">shutdownNow()</span></span></a></li><li><a class="level is-mobile" href="#awaitTermination"><span class="level-left"><span class="level-item">2.4.1.3</span><span class="level-item">awaitTermination()</span></span></a></li><li><a class="level is-mobile" href="#小结："><span class="level-left"><span class="level-item">2.4.1.4</span><span class="level-item">小结：</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#线程池都有哪几种工作队列？"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">线程池都有哪几种工作队列？</span></span></a></li><li><a class="level is-mobile" href="#拒绝策略rejectHander"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">拒绝策略rejectHander</span></span></a></li><li><a class="level is-mobile" href="#如果提交任务时，线程池队列已满，会发生什么"><span class="level-left"><span class="level-item">2.7</span><span class="level-item">如果提交任务时，线程池队列已满，会发生什么</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatarPng.png" alt="White Crow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">White Crow</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">81</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">4</p></a></div></div></nav></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a><p class="is-size-7"><span>&copy; 2025 white crow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://github.com/WhileCrow"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>