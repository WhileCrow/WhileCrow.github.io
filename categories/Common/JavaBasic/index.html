<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Category: JavaBasic - Crow&#039;s Sky</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Crow&#039;s Sky"><meta name="msapplication-TileImage" content="/img/avatarCircle.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Crow&#039;s Sky"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Crow&#039;s Sky"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Crow&#039;s Sky"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="White Crow"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Crow's Sky","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"white crow"},"publisher":{"@type":"Organization","name":"Crow's Sky","logo":{"@type":"ImageObject","url":"http://example.com/img/avatarCircle.png"}},"description":""}</script><link rel="icon" href="/img/avatarCircle.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/WhileCrow"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-10-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">Categories</a></li><li><a href="/categories/Common/">Common</a></li><li class="is-active"><a href="#" aria-current="page">JavaBasic</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-07-26T00:20:27.000Z" title="7/26/2024, 8:20:27 AM">2024-07-26</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-08-09T03:43:52.576Z" title="8/9/2024, 11:43:52 AM">2024-08-09</time></span><span class="level-item"><a class="link-muted" href="/categories/Common/">Common</a><span> / </span><a class="link-muted" href="/categories/Common/JavaBasic/">JavaBasic</a></span><span class="level-item">29 minutes read (About 4385 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/07/26/Tread/">Thread</a></h1><div class="content"><h1 id="线程-进程"><a href="#线程-进程" class="headerlink" title="线程/进程"></a>线程/进程</h1><p><strong>进程</strong>：进程是系统进行资源分配和调度的一个独立单位 (拥有独立内存空间)，一个app就是一个进程，进程包含线程。</p>
<p><strong>线程</strong>：是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一些在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
<p><strong>静态</strong>的是资源和<strong>动态</strong>的是计算</p>
<ol>
<li><p>进程是一个资源的容器，为进程里的所有线程提供共享资源，是对程序的一种静态描述</p>
</li>
<li><p>线程是计算机最小的<u>调度和运行</u>（计算）单位，是对程序的一种动态描述</p>
</li>
</ol>
<h2 id="Java里的线程有哪些状态？"><a href="#Java里的线程有哪些状态？" class="headerlink" title="Java里的线程有哪些状态？"></a>Java里的线程有哪些状态？</h2><p>JDK中，线程（Thread）定义了6种状态： NEW（新建）、RUNNABLE（可执行）、BLOCKED（阻塞）、WAITING（等待）、TIMED_WAITING（限时等待）、TERMINATED（结束）。</p>
<p>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * A thread state.  A thread can be in one of the following  states:</span><br><span class="line"> * &lt;ul&gt;</span><br><span class="line"> * &lt;li&gt;&#123;@link #NEW&#125;</span><br><span class="line"></span><br><span class="line"> *     A thread that has not yet started is in this state.</span><br><span class="line"> *     &lt;&#x2F;li&gt;</span><br><span class="line"> * &lt;li&gt;&#123;@link #RUNNABLE&#125;</span><br><span class="line"></span><br><span class="line"> *     A thread executing in the Java virtual machine is in  this state.</span><br><span class="line"> *     &lt;&#x2F;li&gt;</span><br><span class="line"> * &lt;li&gt;&#123;@link #BLOCKED&#125;</span><br><span class="line"></span><br><span class="line"> *     A thread that is blocked waiting for a monitor lock</span><br><span class="line"> *     is in this state.</span><br><span class="line"> *     &lt;&#x2F;li&gt;</span><br><span class="line"> * &lt;li&gt;&#123;@link #WAITING&#125;</span><br><span class="line"></span><br><span class="line"> *     A thread that is waiting indefinitely for another  thread to</span><br><span class="line"> *     perform a particular action is in this state.</span><br><span class="line"> *     &lt;&#x2F;li&gt;</span><br><span class="line"> * &lt;li&gt;&#123;@link #TIMED_WAITING&#125;</span><br><span class="line"></span><br><span class="line"> *     A thread that is waiting for another thread to perform  an action</span><br><span class="line"> *     for up to a specified waiting time is in this state.</span><br><span class="line"> *     &lt;&#x2F;li&gt;</span><br><span class="line"> * &lt;li&gt;&#123;@link #TERMINATED&#125;</span><br><span class="line"></span><br><span class="line"> *     A thread that has exited is in this state.</span><br><span class="line"> *     &lt;&#x2F;li&gt;</span><br><span class="line"> * &lt;&#x2F;ul&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * A thread can be in only one state at a given point in  time.</span><br><span class="line"> * These states are virtual machine states which do not  reflect</span><br><span class="line"> * any operating system thread states.</span><br><span class="line"> *</span><br><span class="line"> * @since   1.5</span><br><span class="line"> * @see #getState</span><br><span class="line"> *&#x2F;</span><br><span class="line">public enum State &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Thread state for a thread which has not yet started.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    NEW,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Thread state for a runnable thread.  A thread in the  runnable</span><br><span class="line">     * state is executing in the Java virtual machine but it  may</span><br><span class="line">     * be waiting for other resources from the operating  system</span><br><span class="line">     * such as processor.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Thread state for a thread blocked waiting for a  monitor lock.</span><br><span class="line">     * A thread in the blocked state is waiting for a monitor  lock</span><br><span class="line">     * to enter a synchronized block&#x2F;method or</span><br><span class="line">     * reenter a synchronized block&#x2F;method after calling</span><br><span class="line">     * &#123;@link Object#wait() Object.wait&#125;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    BLOCKED,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Thread state for a waiting thread.</span><br><span class="line">     * A thread is in the waiting state due to calling one of  the</span><br><span class="line">     * following methods:</span><br><span class="line">     * &lt;ul&gt;</span><br><span class="line">     *   &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no  timeout&lt;&#x2F;li&gt;</span><br><span class="line">     *   &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;&#x2F;li&gt;</span><br><span class="line">     *   &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;&#x2F;li&gt;</span><br><span class="line">     * &lt;&#x2F;ul&gt;</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;A thread in the waiting state is waiting for  another thread to</span><br><span class="line">     * perform a particular action.</span><br><span class="line">     *</span><br><span class="line">     * For example, a thread that has called  &lt;tt&gt;Object.wait()&lt;&#x2F;tt&gt;</span><br><span class="line">     * on an object is waiting for another thread to call</span><br><span class="line">     * &lt;tt&gt;Object.notify()&lt;&#x2F;tt&gt; or  &lt;tt&gt;Object.notifyAll()&lt;&#x2F;tt&gt; on</span><br><span class="line">     * that object. A thread that has called  &lt;tt&gt;Thread.join()&lt;&#x2F;tt&gt;</span><br><span class="line">     * is waiting for a specified thread to terminate.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    WAITING,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Thread state for a waiting thread with a specified  waiting time.</span><br><span class="line">     * A thread is in the timed waiting state due to calling  one of</span><br><span class="line">     * the following methods with a specified positive  waiting time:</span><br><span class="line">     * &lt;ul&gt;</span><br><span class="line">     *   &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;&#x2F;li&gt;</span><br><span class="line">     *   &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with  timeout&lt;&#x2F;li&gt;</span><br><span class="line">     *   &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with  timeout&lt;&#x2F;li&gt;</span><br><span class="line">     *   &lt;li&gt;&#123;@link LockSupport#parkNanos  LockSupport.parkNanos&#125;&lt;&#x2F;li&gt;</span><br><span class="line">     *   &lt;li&gt;&#123;@link LockSupport#parkUntil  LockSupport.parkUntil&#125;&lt;&#x2F;li&gt;</span><br><span class="line">     * &lt;&#x2F;ul&gt;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Thread state for a terminated thread.</span><br><span class="line">     * The thread has completed execution.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://assets.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h3 id="状态说明"><a href="#状态说明" class="headerlink" title="状态说明"></a>状态说明</h3><p>线程在一个给定的时间点只能处于下面其中一种状态：</p>
<p>这些状态是虚拟机状态，并不能反映任何操作系统的线程状态。</p>
<ul>
<li><p>NEW：尚未启动的线程处于这个状态。Thread thread = new Thread(new Runnable(){…});处于这个状态。</p>
</li>
<li><p>RUNNABLE：可运行的线程处于这个状态。对应操作系统中的两种状态：ready和running，也就是说RUNNABLE状态既可以是可运行的，也可以是实际运行中的，有可能正在执行，也有可能没有正在执行。关于这个问题的理解，可以对比想一下，thread.start()调用之后线程会立刻执行吗？</p>
</li>
<li><p>BLOCKED：阻塞，<strong>进入synchronized修饰的方法或者代码块，等待监视器锁的线程</strong>处于这个状态。</p>
</li>
<li><p>WAITING：无限期等待另一个线程执行特定操作的线程处于这种状态。</p>
</li>
<li><p>TIMED_WAITING：正在等待另一个线程执行某个操作的线程在指定的等待时间内处于这种状态。</p>
</li>
<li><p>TERMINATED：已经退出的线程处于这个状态。</p>
</li>
</ul>
<h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><p>NEW：线程尚未启动的线程状态。当在程序中创建一个线程的时候Thread t = new Thread(Runnable);，线程处于NEW状态。</p>
<p>RUNNABLE：可运行线程的线程状态。处于可运行状态的线程正在Java虚拟机中执行，但它可能正在等待操作系统中的其他资源，比如处理器。也就是说， 这个状态就是可运行也可不运行的状态。注意Runnable ≠ Running。</p>
<p>BLOCKED：进入synchronized修饰的方法或者代码块，等待监视器锁的阻塞线程的线程状态。比如，线程试图通过synchronized去获取监视器锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。等到获得了监视器锁之后会再次进入RUNNABLE状态。</p>
<p>WAITING：调用以下方法之一，线程会处于等待状态：</p>
<ul>
<li>Object.wait()注意：括号内不带参数；</li>
<li>Thread.join()注意：扩号内不带参数；</li>
<li>LockSupport.park()；</li>
</ul>
<p>其实wait()方法有多重形式，可以不带参数，可以带参数，参数表示等待时间（单位ms），如图所示：</p>
<p><img src alt="img"><img src="/2024/07/26/Tread/1538609-20220626174204766-251050442.png" alt="img"></p>
<p>“BLOCKED（阻塞状态）”和“WAITING（等待状态）”的区别：阻塞状态在等待获取一个排它锁，这个事件将会在另外一个线程放弃这个锁的时候发生，然后由阻塞状态变为可执行状态；而等待状态则是在等待一段时间，或者等待唤醒动作的发生。</p>
<p>TIMED_WAITING：一个线程调用了以下方法之一（方法需要带具体的等待时间），会处于定时等待状态：</p>
<ul>
<li>Thread.sleep(long timeout)</li>
<li>Object.wait(long timeout)</li>
<li>Thread.join(long timeout)</li>
<li>LockSupport.parkNanos()</li>
<li>LockSupport.parkUntil()</li>
</ul>
<p>TERMINATED：  该线程已经执行完毕。执行完毕指的是线程正常执行完了run方法之后退出，也可以是遇到了未捕获的异常而退出。</p>
<p><img src="/2024/07/26/Tread/1538609-20220626174204590-1253779990.png" alt="img"></p>
<h3 id="初始-NEW"><a href="#初始-NEW" class="headerlink" title="初始(NEW)"></a>初始(NEW)</h3><p>新创建了一个线程对象，但还没有调用start()方法。</p>
<h3 id="运行-RUNNABLE"><a href="#运行-RUNNABLE" class="headerlink" title="运行(RUNNABLE)"></a>运行(RUNNABLE)</h3><h4 id="Ready"><a href="#Ready" class="headerlink" title="Ready"></a>Ready</h4><h4 id="Running"><a href="#Running" class="headerlink" title="Running"></a>Running</h4><p>Java线程中将就绪（ready）和运行中（running）两种状态笼统 的称为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方 法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此 时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态 （running）。</p>
<h3 id="阻塞-BLOCKED"><a href="#阻塞-BLOCKED" class="headerlink" title="阻塞(BLOCKED)"></a>阻塞(BLOCKED)</h3><p>表示线程阻塞于锁。或称“挂起”</p>
<blockquote>
<p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间</p>
</blockquote>
<h3 id="等待-WAITING"><a href="#等待-WAITING" class="headerlink" title="等待(WAITING)"></a>等待(WAITING)</h3><p>等待状态，处于等待状态的线程是由于执行了<strong>Thread.join</strong>或<strong>Object.wait</strong>方法</p>
<p> 处于waiting状态的线程会等待另外一个线程处理特殊的行为。 再举个例子，如果一个线程调用了一个对象的wait方法，那么这个线程就会处于waiting状态直到另外一个线程调用这个对象的notify或者notifyAll方法后才会解除这个状态</p>
<h3 id="超时等待-TIMED-WAITING"><a href="#超时等待-TIMED-WAITING" class="headerlink" title="超时等待(TIMED_WAITING)"></a>超时等待(TIMED_WAITING)</h3><p>有等待时间的等待状态，比如调用了**Thread.sleep(long timeout)、Thread.join(long timeout)、Object.wait(long timeout)**，并且指定了等待时间，线程就会处于这个状态。 </p>
<h3 id="终止-TERMINATED"><a href="#终止-TERMINATED" class="headerlink" title="终止(TERMINATED)"></a>终止(TERMINATED)</h3><p>表示该线程已经执行完毕。</p>
<blockquote>
<p>对比分析Java中的各个线程相关的wait()、notify()、sleep()、interrupt()方法</p>
</blockquote>
<h1 id="线程相关方法"><a href="#线程相关方法" class="headerlink" title="线程相关方法"></a>线程相关方法</h1><h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><h4 id="sleep：暂停当前正在执行的线程；（类方法）"><a href="#sleep：暂停当前正在执行的线程；（类方法）" class="headerlink" title="sleep：暂停当前正在执行的线程；（类方法）"></a>sleep：暂停当前正在执行的线程；（<strong>类方法</strong>）</h4><p>​    是Thread的静态方法，很显然它是让当前线程按照指定的时间休眠，其休眠时间的精度取决于处理器的计时器和调度器。需要注意的是如果当前线程获得了锁，sleep方法并不会失去锁。sleep方法经常拿来与Object.wait()方法进行比价，这也是面试经常被问的地方。</p>
<blockquote>
<p><strong>sleep() VS wait()</strong></p>
</blockquote>
<p>  两者主要的区别：</p>
<pre><code>1. sleep()方法是Thread的静态方法，而wait是Object实例方法
2. wait()方法必须要在同步方法或者同步块中调用，也就是必须已经获得对象锁。而sleep()方法没有这个限制可以在任何地方种使用。另外，wait()方法会释放占有的对象锁，使得该线程进入等待池中，等待下一次获取资源。而sleep()方法只是会让出CPU并不会释放掉对象锁；
3. sleep()方法在休眠时间达到后如果再次获得CPU时间片就会继续执行，而wait()方法必须等待Object.notift/Object.notifyAll通知后，才会离开等待池，并且再次获得CPU时间片才会继续执行。
</code></pre>
<h4 id="yield：暂停当前正在执行的线程，并执行其他线程；（类方法）"><a href="#yield：暂停当前正在执行的线程，并执行其他线程；（类方法）" class="headerlink" title="yield：暂停当前正在执行的线程，并执行其他线程；（类方法）"></a>yield：暂停当前正在执行的线程，并执行其他线程；（<strong>类方法</strong>）</h4><p>​    是Thread的静态方法，一旦执行，它会是当前线程让出CPU，但是，需要注意的是，让出的CPU并不是代表当前线程不再运行了，如果在下一次竞争中，又获得了CPU时间片当前线程依然会继续运行。另外，让出的时间片只会分配<strong>给当前线程相同优先级</strong>的线程。</p>
<p>​    yield()方法使当前线程出让CPU执行时间，但并不会释放当前线程所持有的锁。执行完yield()方法后，线程从Running状态转变为Runnable状态，既然是Runnable状态，那么也很可能马上会被CPU调度再次进入Running状态。</p>
<blockquote>
<p>什么是线程优先级了？下面就来具体聊一聊。</p>
<p>现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当前时间片用完后就会发生线程调度，并等待这下次分配。线程分配到的时间多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要或多或少分配一些处理器资源的线程属性。</p>
<p>在Java程序中，通过一个<strong>整型成员变量Priority</strong>来控制优先级，优先级的范围从1~10.在构建线程的时候可以通过**setPriority(int)**方法进行设置，默认优先级为5，优先级高的线程相较于优先级低的线程优先获得处理器时间片。需要注意的是在不同JVM以及操作系统上，线程规划存在差异，有些操作系统甚至会忽略线程优先级的设定。</p>
<p>另外需要注意的是，sleep()和yield()方法，同样都是当前线程会交出处理器资源，而它们不同的是，sleep()交出来的时间片其他线程都可以去竞争，也就是说都有机会获得当前线程让出的时间片。而yield()方法只允许与当前线程具有相同优先级的线程能够获得释放出来的CPU时间片。</p>
</blockquote>
<h4 id="join：等待该线程终止；"><a href="#join：等待该线程终止；" class="headerlink" title="join：等待该线程终止；"></a>join：等待该线程终止；</h4><p>​    join()方法的作用，是等待这个线程结束，是主线程等待子线程的终止。也就是说主线程的代码块中，如果碰到了t.join()方法，此时主线程需要等待（阻塞），等待子线程结束了(Waits for this thread to die.),才能继续执行t.join()之后的代码块。</p>
<h4 id="interrupt：中断该线程，"><a href="#interrupt：中断该线程，" class="headerlink" title="interrupt：中断该线程，"></a>interrupt：中断该线程，</h4><p>interrupt()方法的工作仅仅是改变中断状态，并不是直接中断正在运行的线程。中断的真正原理是当线程被Object.wait(),Thread.join()或sleep()方法阻塞时，调用interrupt()方法后改变中断状态，而wait/join/sleep这些方法内部会不断地检查线程的中断状态值，当发现中断状态值改变时则抛出InterruptedException异常；对于没有阻塞的线程，调用interrupt()方法是没有任何作用。</p>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><ul>
<li>wait：暂停当前正在执行的线程，直到调用notify()或notifyAll()方法或超时，退出等待状态；</li>
<li>notify：唤醒在该对象上等待的一个线程；</li>
<li>notifyAll：唤醒在该对象上等待的所有线程；</li>
</ul>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><h3 id="sleep-VS-wait"><a href="#sleep-VS-wait" class="headerlink" title="sleep VS wait"></a>sleep VS wait</h3><p>sleep()和wait()方法都是暂停当前正在执行的线程，出让CPU资源。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">所属类</th>
<th align="left">方法类型</th>
<th align="left">锁</th>
<th align="left">解除方法</th>
<th align="left">场景</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">sleep</td>
<td align="left">Thread</td>
<td align="left">静态方法</td>
<td align="left">不释放锁</td>
<td align="left">timeout,interrupt</td>
<td align="left">无限制</td>
<td align="left">线程内的控制</td>
</tr>
<tr>
<td align="left">wait</td>
<td align="left">Object</td>
<td align="left">非静态方法</td>
<td align="left">释放锁</td>
<td align="left">timeout,notify,interrupt</td>
<td align="left">同步语句块</td>
<td align="left">线程间的通信</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException </span></span><br><span class="line"><span class="function">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span></span><br><span class="line"><span class="function"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException </span></span><br><span class="line"><span class="function"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure>

<h3 id="wait-amp-amp-notify"><a href="#wait-amp-amp-notify" class="headerlink" title="wait &amp;&amp; notify"></a>wait &amp;&amp; notify</h3><p>调用对象的wait()、notify()、notifyAll()方法的线程，必须是作为此对象监视器的所有者。常见的场景便是就是synchronized关键字的语句块内部使用这3个方法，如果直接在线程中使用wait()、notify()、notifyAll()方法，那么会抛出异常IllegalMonitorStateException，抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。。</p>
<p>调用wait()方法的线程，在调用该线程的interrupt()方法，则会重新尝试获取对象锁。只有当获取到对象锁，才开始抛出相应的异常，则执行该线程之后的程序。</p>
<h2 id="怎么终止一个线程"><a href="#怎么终止一个线程" class="headerlink" title="怎么终止一个线程"></a>怎么终止一个线程</h2><p>首先，一个<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%BA%BF%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:89431513%7D">线程</a>不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。</p>
<p>所以，Thread.stop, Thread.suspend, Thread.resume 都已经被废弃了。</p>
<h3 id="interrupt："><a href="#interrupt：" class="headerlink" title="interrupt："></a>interrupt：</h3><p>Thread.interrupt 的作用其实也不是<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:89431513%7D">中断线程</a>，而是「通知线程应该中断了」，</p>
<p>具体到底中断还是继续运行，应该由被通知的线程自己处理。</p>
<p>具体来说，当对一个线程，调用 interrupt() 时，</p>
<p>① 如果线程处于被<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:89431513%7D">阻塞状态</a>（例如处于sleep, wait, join 等状态），那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。仅此而已。</p>
<p>② 如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true，仅此而已。被设置<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%B8%AD%E6%96%AD%E6%A0%87%E5%BF%97&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:89431513%7D">中断标志</a>的线程将继续正常运行，不受影响。</p>
<p><strong>interrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行。</strong></p>
<p>① 在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程。</p>
<p>② 在调用<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E9%98%BB%E5%A1%9E%E6%96%B9%E6%B3%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:89431513%7D">阻塞方法</a>时正确处理InterruptedException异常。（例如，catch异常后就结束线程。）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">    while (!Thread.interrupted()) &#123;</span><br><span class="line">        // do more work.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line">// 一段时间以后</span><br><span class="line">thread.interrupt();</span><br></pre></td></tr></table></figure>





<h3 id="stop"><a href="#stop" class="headerlink" title="stop():"></a>stop():</h3><p>弃用，因为在stop时会释放所有的锁，可能导致线程不同步，另一个也可能导致资源如文件文件数据库的关闭行为不被执行</p>
<blockquote>
<ol>
<li>调用 stop() 方法会立刻停止 run() 方法中剩余的全部工作，包括在 catch 或 finally 语句中的，并抛出ThreadDeath异常(通常情况下此异常不需要显示的捕获)，因此可能会导致一些清理性的工作的得不到完成，如文件，数据库等的关闭。</li>
<li>调用 stop() 方法会立即释放该线程所持有的所有的锁，导致数据得不到同步，出现数据不一致的问题。</li>
</ol>
</blockquote>
<h3 id="使用volatile标志位"><a href="#使用volatile标志位" class="headerlink" title="使用volatile标志位"></a>使用volatile标志位</h3><p>以标志位为循环条件 </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-11-11T12:20:27.000Z" title="11/11/2021, 8:20:27 PM">2021-11-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-07-29T08:13:23.384Z" title="7/29/2024, 4:13:23 PM">2024-07-29</time></span><span class="level-item"><a class="link-muted" href="/categories/Common/">Common</a><span> / </span><a class="link-muted" href="/categories/Common/JavaBasic/">JavaBasic</a></span><span class="level-item">an hour read (About 8820 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/11/11/Concurrent/">Concurrent</a></h1><div class="content"><p><a target="_blank" rel="noopener" href="https://www.wwwbuild.net/JavaAmazing/112187.html">https://www.wwwbuild.net/JavaAmazing/112187.html</a></p>
<h1 id="并发操作：原子性、可见性、有序性"><a href="#并发操作：原子性、可见性、有序性" class="headerlink" title="并发操作：原子性、可见性、有序性"></a>并发操作：原子性、可见性、有序性</h1><h2 id="1、原子性"><a href="#1、原子性" class="headerlink" title="1、原子性"></a><strong>1、原子性</strong></h2><p><strong>即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</strong></p>
<p>如java.util.concurrent.atomic包下的原子类，就是用CAS(Compare And Swap)保证原子性和可见性（内存屏障）</p>
<blockquote>
<p>虽然 <code>java.util.concurrent.atomic</code> 提供了原子操作，但这些解决方案主要针对单一变量。对于涉及多个变量时的原子性操作，仍然需要使用高级同步机制（如 <code>synchronized</code> 块或 <code>ReentrantLock</code>）。</p>
<p>Java 内存模型（JMM）确保在使用原子类和 CAS 操作时，数值的更新对其他线程是可见的。这是通过内存屏障来实现的。</p>
</blockquote>
<h2 id="2、可见性"><a href="#2、可见性" class="headerlink" title="2、可见性"></a>2、可见性</h2><p><strong>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</strong></p>
<p>如volatile能保证被修饰变量的可见性、有序性；原子类可以保证原子性和可见性；</p>
<blockquote>
<ul>
<li><strong>可见性</strong>：<code>volatile</code> 关键字确保变量的更新对所有线程立即可见，避免线程读取到变量的过期值。</li>
<li><strong>禁止指令重排序优化</strong>：编译器和运行时不会把 <code>volatile</code> 变量的写操作与之前的内存操作重排序，也不会把 <code>volatile</code> 变量的读操作与之后的内存操作重排序。</li>
</ul>
</blockquote>
<h2 id="3、有序性"><a href="#3、有序性" class="headerlink" title="3、有序性"></a>3、有序性</h2><p><strong>即程序执行的顺序按照代码的先后顺序执行。（指令编排可能会导致多线程下执行结果不一致）</strong></p>
<p>如volatile能保证被修饰变量的可见性、有序性</p>
<p><strong>synchronized关键字三者都能保证。</strong></p>
<h1 id="Volatile-和synchronized的区别："><a href="#Volatile-和synchronized的区别：" class="headerlink" title="Volatile 和synchronized的区别："></a>Volatile 和synchronized的区别：</h1><p><strong><code>java.util.concurrent.atomic</code>包的原子类可以保证数据的原子性、可见性；volatile关键字能保证数据的可见性、有序性，但不能保证数据的原子性。synchronized关键字三者都能保证。</strong></p>
<h2 id="1：并发特性比较："><a href="#1：并发特性比较：" class="headerlink" title="1：并发特性比较："></a>1：并发特性比较：</h2><p>volatile关键字能保证数据的可见性、有序性，但不能保证数据的原子性（即volatile int x; x++ 是三步操作：一取x值，二加一，三赋值回x）。synchronized关键字两者都能保证。</p>
<p>有序性则volatile和synchronized都能保证，volatile关键字禁止JVM编译器已及处理器对其进行重排序,</p>
<p>synchronized保证顺序性是串行化的结果，但同步块里的语句是会发生指令从排。</p>
<h2 id="2：volatile-的原理"><a href="#2：volatile-的原理" class="headerlink" title="2：volatile 的原理"></a>2：volatile 的原理</h2><p>  1).  修改volatile变量时会强制将修改后的值刷新的主内存中。</p>
<p>  2).  修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。</p>
<p>  3).  <strong>禁止指令重排序优化</strong>：编译器和运行时不会把 <code>volatile</code> 变量的写操作与之前的内存操作重排序，也不会把 <code>volatile</code> 变量的读操作与之后的内存操作重排序。</p>
<p>（Intel 的MESI协议：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的高速缓存置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取重新加载到高速缓存。）</p>
<h2 id="3：阻塞与否"><a href="#3：阻塞与否" class="headerlink" title="3：阻塞与否"></a>3：阻塞与否</h2><p>多线程访问volatile关键字不会发生阻塞（2所述原理），而synchronized关键字可能会发生阻塞(重量级锁时会阻塞)</p>
<h2 id="4：性能"><a href="#4：性能" class="headerlink" title="4：性能"></a>4：性能</h2><p>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用synchronized关键字的场景还是更多一些。</p></div><a class="article-more button is-small is-size-7" href="/2021/11/11/Concurrent/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-11-01T12:20:27.000Z" title="11/1/2021, 8:20:27 PM">2021-11-01</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-05-10T06:53:55.353Z" title="5/10/2024, 2:53:55 PM">2024-05-10</time></span><span class="level-item"><a class="link-muted" href="/categories/Common/">Common</a><span> / </span><a class="link-muted" href="/categories/Common/JavaBasic/">JavaBasic</a></span><span class="level-item">29 minutes read (About 4375 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/11/01/HashMap/">HashMap</a></h1><div class="content"><h2 id="常见Map类"><a href="#常见Map类" class="headerlink" title="常见Map类"></a>常见Map类</h2><p>简述：HashMap是非线程安全的，如需要线程安全的哈希隐射类，应使用实现了分段锁（1.8）的ConcurrentHashMap，而不建议使用遗留类HashTable（HashTable实现线程安全是依靠用synchronized关键字修饰put/get方法，效率较低）。</p>
<p>如果需要保存记录插入的顺序，可使用LinkHashMap()，其内部实现了一个双向链表，即每个节点本身记录了前后节点的引用。(btw:MessageQueue是单链表)</p></div><a class="article-more button is-small is-size-7" href="/2021/11/01/HashMap/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-05-14T02:43:27.000Z" title="5/14/2021, 10:43:27 AM">2021-05-14</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.414Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Common/">Common</a><span> / </span><a class="link-muted" href="/categories/Common/JavaBasic/">JavaBasic</a></span><span class="level-item">5 minutes read (About 815 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/14/ThreadLocal/">ThreadLocal</a></h1><div class="content"><h1 id="ThreadLocal："><a href="#ThreadLocal：" class="headerlink" title="ThreadLocal："></a>ThreadLocal：</h1><p><strong>ThreadLocal</strong>： 线程本地存储区（Thread Local Storage，简称为TLS），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的TLS区域。</p>
<p>ThreadLocal类不过是为了执行set/get，确定泛型的工具人而已。真正数据是靠的每个Thread内部维护。</p>
<p><strong>实际上就是 每个Thread对象中 维护了一个</strong></p>
<p><strong>叫ThreadLocal.ThreadLocalMap的</strong></p>
<p>**key为 <em>ThreadLocal对象</em>,    value为 <em>存储的值</em> **</p>
<p><strong>的key-vale映射结构，(实际上是一个键值对组成entry的唯一环形数组，线性探测，初始值3/4容量扩容)</strong></p>
<p><strong>当调用threadLocalInstance.set(value)时，其实时调用的CurrentThread.threadLocalMap.set(threadLocalInstance, value)</strong></p></div><a class="article-more button is-small is-size-7" href="/2021/05/14/ThreadLocal/#more">Read more</a></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatarPng.png" alt="White Crow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">White Crow</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">79</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">4</p></a></div></div></nav></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a><p class="is-size-7"><span>&copy; 2024 white crow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://github.com/WhileCrow"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>