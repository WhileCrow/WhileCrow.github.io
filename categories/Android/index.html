<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Category: Android - Crow&#039;s Sky</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Crow&#039;s Sky"><meta name="msapplication-TileImage" content="/img/avatarCircle.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Crow&#039;s Sky"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Crow&#039;s Sky"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Crow&#039;s Sky"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="White Crow"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Crow's Sky","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"white crow"},"publisher":{"@type":"Organization","name":"Crow's Sky","logo":{"@type":"ImageObject","url":"http://example.com/img/avatarCircle.png"}},"description":""}</script><link rel="icon" href="/img/avatarCircle.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/WhileCrow"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-10-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">Categories</a></li><li class="is-active"><a href="#" aria-current="page">Android</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-06-04T03:37:41.537Z" title="6/4/2024, 11:37:41 AM">2024-06-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-06-04T03:37:41.538Z" title="6/4/2024, 11:37:41 AM">2024-06-04</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">3 minutes read (About 427 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/04/FirstScreenCost/">FirstScreenCost.md</a></h1><div class="content"><h1 id="Activity启动耗时"><a href="#Activity启动耗时" class="headerlink" title="Activity启动耗时"></a>Activity启动耗时</h1><p>首先：测试方法：</p>
<p>AMS会打印启动Activity的耗时，Android 10之后打印tag为ActivityTaskManager，Android10之前打印ActivityManager;</p>
<blockquote>
<p>在Android 10（Q）版本中，Android系统引入了ActivityTaskManager（ATM），并在很大程度上取代了之前的ActivityManagerService（AMS）的许多职责。具体来说，AMS负责管理整个系统的活动生命周期和任务堆栈，而在Android 10中，这些职责被重新分配并分离到新的ActivityTaskManager和ActivityManager中。</p>
<p>ActivityTaskManager专注于任务和活动的管理，处理任务堆栈的操作和活动的启动、切换等。而ActivityManager则更多地处理与应用进程管理相关的功能，如进程的生命周期、内存管理等。</p>
<p>这一改变是为了简化代码结构、提升系统的模块化和可维护性，同时也是为了更好地支持多窗口和多任务操作等新的特性。</p>
<p>总结起来，ActivityTaskManager的引入和实现从Android 10开始正式应用，取代了原有的部分ActivityManagerService的功能。</p>
</blockquote>
<p><strong>ActivityManager : Display / startActivity Android6/7</strong></p>
<p> 简单结论：display 只统计A onPause之后（不包含A onPause）</p>
<p>AMS 启动新ActivityB 并 执行 B的onCreate、onstart、onresume 与 B向WMS注册窗口到编舞者发起的第一次测绘 完成</p>
<p>Activity的启动可以分为三个步骤，以ActivityA启动ActivityB为例，三步骤分别为：</p>
<ol>
<li><p>以ActivityA调用startActivity，到ActivityA成功pause为止</p>
<p>displayTimeStart</p>
</li>
<li><p>ActivityB成功初始化，到执行完resume为止</p>
</li>
<li><p>ActivityB向WSM注册窗口，到第一帧绘制完成为止<br>displayTimeEnd</p>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-04-24T11:55:00.000Z" title="4/24/2024, 7:55:00 PM">2024-04-24</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-07-04T06:15:34.932Z" title="7/4/2024, 2:15:34 PM">2024-07-04</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">37 minutes read (About 5518 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/04/24/ThreadPool/">ThreadPool</a></h1><div class="content"><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment"> * parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment"> *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment"> *        核心线程数量，线程常驻即使空闲，除非设置了allowCoreThreadTimeOut</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment"> *        pool</span></span><br><span class="line"><span class="comment"> *        最大线程数，整个线程池的线程数量（核心线程数+普通线程数）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment"> *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment"> *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment"> *        超过核心线程数后的空闲线程存活时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment"> * 				时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment"> *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment"> *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment"> *        工作队列：任务被执行前的存放队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory the factory to use when the executor</span></span><br><span class="line"><span class="comment"> *        creates a new thread</span></span><br><span class="line"><span class="comment"> *        executor创建线程的工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler the handler to use when execution is blocked</span></span><br><span class="line"><span class="comment"> *        because the thread bounds and queue capacities are reached</span></span><br><span class="line"><span class="comment"> *        ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/24/ThreadPool/31bad766983e212431077ca8da92762050214.png" alt="图4 任务调度流程"></p>
<p>通过<code>Executors</code>工具类可以创建多种类型的线程池，包括：</p>
<ul>
<li><p><code>FixedThreadPool</code>：固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。<strong>核心线程数为n，最大线程数为n，任务队列长度为Interger.MAX_VALUE的LinkedBlockingQueue</strong></p>
</li>
<li><p><code>SingleThreadExecutor</code>： 只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。<strong>核心线程数、最大线程数都为1，任务队列长度为Interger.MAX_VALUE的LinkedBlockingQueue</strong></p>
</li>
<li><p><code>CachedThreadPool</code>： 可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。<strong>核心线程数为0，最大线程数为Interger.MAX_VAULE，任务队列为无容量的SynchronousQueue</strong></p>
</li>
<li><p><code>ScheduledThreadPool</code>：给定的延迟后运行任务或者定期执行任务的线程池。<strong>核心线程为n，最大线程为Interger.MAX_VALUE，任务队列长度为最大Interger_MAX_VALUE的DelayQueue</strong></p>
</li>
</ul>
<p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<p><code>Executors</code> 返回线程池对象的弊端如下：</p>
<ul>
<li><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code>:使用的是无界的 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
<li><code>CachedThreadPool</code>:使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM。</li>
<li><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code>:使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
</ul>
<h2 id="ThreadPoolExecutor使用详解"><a href="#ThreadPoolExecutor使用详解" class="headerlink" title="ThreadPoolExecutor使用详解"></a>ThreadPoolExecutor使用详解</h2><p>其实java线程池的实现原理很简单，说白了就是一个线程集合workerSet和一个阻塞队列workQueue。当用户向线程池提交一个任务(也就是线程)时，线程池会先将任务放入workQueue中。workerSet中的线程会不断的从workQueue中获取线程然后执行。当workQueue中没有任务的时候，worker就会阻塞，直到队列中有任务了就取出来继续执行。</p>
<p><img src="/2024/04/24/ThreadPool/java-thread-x-executors-1.png" alt="img"></p>
<h3 id="Execute原理"><a href="#Execute原理" class="headerlink" title="# Execute原理"></a><a href="#execute%E5%8E%9F%E7%90%86">#</a> Execute原理</h3><p><img src="https://github.com/WhileCrow/BlackCrow/assets/26061465/f2b23a0e-ba3b-4be8-be4c-001699925978" alt="image"><br><a target="_blank" rel="noopener" href="https://excalidraw.com/#json=Y7a8uMRrIrZNGfr7GnQ0M,2qUB-ZmXM-hwP0a3MWnA1A">https://excalidraw.com/#json=Y7a8uMRrIrZNGfr7GnQ0M,2qUB-ZmXM-hwP0a3MWnA1A</a></p>
<p>当一个任务提交至线程池之后:</p>
<ol>
<li>线程池首先当前运行的线程数量是否少于corePoolSize。如果是，则创建一个新的工作线程来执行任务。如果都在执行任务，则进入2.</li>
<li>判断BlockingQueue是否已经满了，倘若还没有满，则将线程放入BlockingQueue。否则进入3.</li>
<li>如果创建一个新的工作线程将使当前运行的线程数量超过maximumPoolSize，则交给RejectedExecutionHandler来处理任务。</li>
</ol>
<blockquote>
<p>运行机制（当任务来了之后的执行流程）：</p>
<ol>
<li>判断核心线程数是否已满；如果未满创建核心线程执行任务；如果满了执行后续操作。</li>
<li>判断任务队列是否已满；如果未满将任务添加到队列；如果满了执行后续流程。</li>
<li>判断最大线程数是否已满；如果未满创建临时线程执行任务；如果满了执行后续流程。</li>
<li>执行拒绝策略（内置4种拒绝策略+自定义的拒绝策略）。</li>
</ol>
</blockquote>
<p>当ThreadPoolExecutor创建新线程时，通过CAS来更新线程池的状态ctl.</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="# 参数"></a><a href="#%E5%8F%82%E6%95%B0">#</a> 参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>corePoolSize</code> 线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize, 即使有其他空闲线程能够执行新来的任务, 也会继续创建线程；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</li>
<li><code>workQueue</code> 用来保存等待被执行的任务的阻塞队列. 在JDK中提供了如下阻塞队列: 具体可以参考<a href>JUC 集合: BlockQueue详解</a><ul>
<li><code>ArrayBlockingQueue</code>: 基于数组结构的有界阻塞队列，按FIFO排序任务；</li>
<li><code>LinkedBlockingQueue</code>: 基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQueue；</li>
<li><code>SynchronousQueue</code>: 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue；</li>
<li><code>PriorityBlockingQueue</code>: 具有优先级的无界阻塞队列；</li>
</ul>
</li>
</ul>
<p><code>LinkedBlockingQueue</code>比<code>ArrayBlockingQueue</code>在插入删除节点性能方面更优，但是二者在<code>put()</code>, <code>take()</code>任务的时均需要加锁，<code>SynchronousQueue</code>使用无锁算法，根据节点的状态判断执行，而不需要用到锁，其核心是<code>Transfer.transfer()</code>.</p>
<ul>
<li><code>maximumPoolSize </code> 线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize；当阻塞队列是无界队列, 则maximumPoolSize则不起作用, 因为无法提交至核心线程池的线程会一直持续地放入workQueue.</li>
<li><code>keepAliveTime </code> 线程空闲时的存活时间，即当线程没有任务执行时，该线程继续存活的时间；默认情况下，该参数只在线程数大于corePoolSize时才有用, 超过这个时间的空闲线程将被终止；</li>
<li><code>unit </code> keepAliveTime的单位</li>
<li><code>threadFactory </code> 创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名。默认为DefaultThreadFactory</li>
<li><code>handler </code> 线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略:<ul>
<li><code>AbortPolicy</code>: 直接抛出异常，默认策略；</li>
<li><code>CallerRunsPolicy</code>: 用调用者所在的线程来执行任务；</li>
<li><code>DiscardOldestPolicy</code>: 丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>
<li><code>DiscardPolicy</code>: 直接丢弃任务；</li>
</ul>
</li>
</ul>
<p>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p>
<h1 id="※线程池ThreadPoolExecutor"><a href="#※线程池ThreadPoolExecutor" class="headerlink" title="※线程池ThreadPoolExecutor"></a>※线程池ThreadPoolExecutor</h1><h2 id="常见的线程池有："><a href="#常见的线程池有：" class="headerlink" title="常见的线程池有："></a>常见的线程池有：</h2><h3 id="无缓存线程"><a href="#无缓存线程" class="headerlink" title="无缓存线程"></a>无缓存线程</h3><h4 id="·-定长线程池（最常见，如Glide）"><a href="#·-定长线程池（最常见，如Glide）" class="headerlink" title="· 定长线程池（最常见，如Glide）"></a>· 定长线程池（最常见，如Glide）</h4><p>FixedThreadPool：<strong>根据入参决定有多少个核心线程，无缓存线程。</strong> 可重用固定线程数的线程池。（适用于负载比较重的服务器） FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列，该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列 中的任务。</p>
<h4 id="·-单线程线程池"><a href="#·-单线程线程池" class="headerlink" title="· 单线程线程池"></a>· 单线程线程池</h4><p>SingleThreadExecutor：<strong>只有一个核心线程，最大线程也为1，无缓存线程。所有任务在此线程中FIFO进行</strong>只会创建一个线程执行任务。（适用于需要保证顺序执行各个任 务；并且在任意时间点，没有多线程活动的场景。） SingleThreadExecutorl也使用无界队列LinkedBlockingQueue作为工作队列 若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先 出的顺序执行队列中的任务。</p>
<h4 id="·-定时线程池"><a href="#·-定时线程池" class="headerlink" title="· 定时线程池"></a>· 定时线程池</h4><p>ScheduledThreadPool：<strong>只有入参数量的核心线程，无缓存线程</strong>。继承自ThreadPoolExecutor。它主要用来在给定的延迟之后运行 任务，或者定期执行任务。使用DelayQueue作为任务队列。如newScheduledThreadPool，用于定时任务。</p>
<h3 id="无核心线程"><a href="#无核心线程" class="headerlink" title="无核心线程"></a>无核心线程</h3><h4 id="·-缓存线程池"><a href="#·-缓存线程池" class="headerlink" title="· 缓存线程池"></a>· 缓存线程池</h4><p>CachedThreadPool：<strong>无核心线程，无限制地增加执行完成就销毁(根据keepaliveTime决定)的缓存线程</strong>，是一个会根据需要调整线程数量的线程池。（大小无界，适用于执行很 多的短期异步任务的小程序，或负载较轻的服务器） CachedThreadPool使用没有容量的SynchronousQueue作为线程池的工作队列，但 CachedThreadPool的maximumPool是无界的。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线 程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕 后，将返回线程池进行复用。</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li>降低资源消耗：通过重复利用现有的线程来执行任务，避免多次创建和销毁线程。<strong>一个线程保留1M大小的内存空间，有效降低OOM</strong></li>
<li>提高相应速度：因为省去了创建线程这个步骤，所以在拿到任务时，可以立刻开始执行。</li>
</ol>
<h2 id="线程数应该怎么设置"><a href="#线程数应该怎么设置" class="headerlink" title="线程数应该怎么设置"></a>线程数应该怎么设置</h2><ul>
<li>如果任务是IO密集型，一般线程数需要设置2倍CPU数以上（2N），以此来尽量利用CPU资源。</li>
<li>如果任务是CPU密集型，一般线程数量只需要设置CPU数加1即可，更多的线程数也只能增加上下文切换，不能增加CPU利用率。</li>
</ul>
<blockquote>
<p>在计算密集型任务中，将线程池大小设置为 CPU 核心数 + 1 的原因是为了应对可能出现的阻塞情况。 虽然计算密集型任务主要消耗 CPU 资源，但在实际应用中，任务内部可能仍然存在一些阻塞操作， 例如：<br>同步 IO： 如果任务需要进行磁盘读写或网络通信等 IO 操作，并且这些操作是同步阻塞的，那么当前线程会被阻塞， 无法继续执行计算任务。<br>锁竞争： 如果任务中存在对共享资源的访问，并且使用了锁机制进行同步， 那么当多个线程同时竞争锁时， 部分线程会被阻塞， 等待获取锁。<br>页面错误： 当线程访问的内存页面不在物理内存中时，会发生页面错误， 导致线程被阻塞， 等待操作系统将页面从磁盘加载到内存。  如果线程池大小刚好等于 CPU 核心数，那么当一个线程被阻塞时，CPU 就无法充分利用，导致整体性能下降。 而增加一个额外的线程，可以确保在某个线程被阻塞时， 仍然有足够的线程可以继续执行计算任务， 从而提高 CPU 利用率和整体性能。 当然，这只是一个经验法则，并不是绝对的。 在某些情况下， 如果任务中不存在阻塞操作， 或者阻塞情况非常少见， 那么将线程池大小设置为 CPU 核心数也可能足够。 最佳的线程池大小仍然需要根据你的具体应用场景和硬件环境进行调整和测试。 </p>
</blockquote>
<p>简单来说就是 io多，则用更多线程充分利用cpu；计算多，则用少的线程数减少线程切换，但仍存在的io操作使数量应为n+1;</p>
<p>Android一般认为多数操作是IO密集，如网络io，本地文件io，所以会设置2N</p>
<h3 id="Android系统对每个进程线程数限制"><a href="#Android系统对每个进程线程数限制" class="headerlink" title="Android系统对每个进程线程数限制"></a>Android系统对每个进程线程数限制</h3><p>root 下adb shell cat /proc/sys/kernel/threads-max</p>
<p>结果如：57439</p>
<p>但每个线程1M左右，基本上几百个线程就可能OOM了</p>
<h3 id="常见的三方库线程池默认数量"><a href="#常见的三方库线程池默认数量" class="headerlink" title="常见的三方库线程池默认数量"></a>常见的三方库线程池默认数量</h3><h4 id="Okhttp"><a href="#Okhttp" class="headerlink" title="Okhttp"></a>Okhttp</h4><p>OkHttp中的线程池是定义在分发器中的，即定义在Dispatcher</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">    executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> SynchronousQueue&lt;&gt;(), Util.threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>, <span class="keyword">false</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>用的其实相当于就是一个无核心线程，最大线程池为Integer.MAX_VALUE，任务队列为SynchronousQueue的缓存线程池</strong></p>
<p>高并发，最大吞吐量。SynchronousQueue队列是无容量队列，<br> 在OkHttp中，配置的线程池的核心线程数为0，最大线程数为Integer.MAX_VALUE，线程的存活时间为60s，采用的队列是SynchronousQueue。</p>
<ol>
<li>okhttp <code>默认同时支持 64 个异步请求(不考虑同步请求)，一个 host 同时最多请求 5 个</code></li>
<li>okhttp 内部的<code>线程池都是 CacheThreadPool</code>：核心线程数为 0，非核心线程数无限，永远添加不到等待队列中</li>
<li><code>okhttpClient 如果不单例，会出现 oom</code>：因为大量的 Dispatcher 对象，不同的对象会使用不同的线程去发起网络请求，从而导致线程过多，OOM</li>
</ol>
<h4 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h4><p><strong>Glide用的都是核心线程数与最大线程数一致（cpu数量与4的最小值），任务队列为PriorityBlockingQueue的定长线程池。</strong>（所以Glide的最大并发量是四个图片?）</p>
<p>glide加载的线程池的配置，使用cpu数量与4的最小值，即线程池的核心线程和最大线程数不超过4个</p>
<p><img src="/2024/04/24/ThreadPool/image-20240424204306358.png" alt="image-20240424204306358"></p>
<p><img src="/2024/04/24/ThreadPool/image-20240426113224120.png" alt="image-20240426113224120"></p>
<h2 id="线程池关闭方法区别"><a href="#线程池关闭方法区别" class="headerlink" title="线程池关闭方法区别"></a>线程池关闭方法区别</h2><p>shutdown() 、 shutdownNow() 、 awaitTermination() 的用法和区别</p>
<h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h4><p>将线程池状态置为SHUTDOWN,并不会立即停止：</p>
<ul>
<li>停止接收外部submit的任务</li>
<li>内部正在跑的任务和队列里等待的任务，会执行完</li>
<li>等到第二步完成后，才真正停止</li>
</ul>
<h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a>shutdownNow()</h4><p>将线程池状态置为STOP。企图立即停止，事实上不一定：</p>
<ul>
<li>跟shutdown()一样，先停止接收外部提交的任务</li>
<li>忽略队列里等待的任务</li>
<li>尝试将正在跑的任务interrupt中断</li>
</ul>
<p>返回未执行的任务列表</p>
<h4 id="awaitTermination"><a href="#awaitTermination" class="headerlink" title="awaitTermination()"></a>awaitTermination()</h4><p>awaitTermination(long timeOut, TimeUnit unit)</p>
<p>当前线程阻塞，直到</p>
<ul>
<li>等所有已提交的任务（包括正在跑的和队列中等待的）执行完</li>
<li>或者等超时时间到</li>
<li>或者线程被中断，抛出InterruptedException</li>
</ul>
<p>然后返回true（shutdown请求后所有任务执行完毕）或false（已超时）</p>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ul>
<li><strong>优雅的关闭</strong>，用shutdown()，<u>停止接受任务</u>并<u>等待进行中</u>的和<u>队列中的任务</u>都执行完后停止。</li>
<li><strong>想立马中断并关闭</strong>，并得到未执行任务列表，用shutdownNow()，会<u>interrupt正在进行的任务</u>并<u>忽略队列中任务</u>，返回未执行的任务队列</li>
<li><strong>优雅的关闭</strong>，并允许关闭声明后新任务能提交，用awaitTermination()</li>
</ul>
<h2 id="线程池都有哪几种工作队列？"><a href="#线程池都有哪几种工作队列？" class="headerlink" title="线程池都有哪几种工作队列？"></a>线程池都有哪几种工作队列？</h2><p><strong>ArrayBlockingQueue</strong>：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。</p>
<p><strong>LinkedBlockingQueue</strong>：是一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量 通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()、newSingleThreadExecutor使用了 这个队列。</p>
<p><strong>SynchronousQueue</strong>：是一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用 移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue。</p>
<p><strong>DelayedWorkQueue</strong>：是一个阻塞队列。保证添加到队列中的任务，会按照任务的延时时间进行排序，延时时间少的任务首先被获取。newScheduledThreadPool使用了这个队列。</p>
<p>假设向线程池提交任务时，核心线程都被占用的情况下：</p>
<p><code>ArrayBlockingQueue</code>：基于数组的阻塞队列，初始化需要指定固定大小。</p>
<p>​    当使用此队列时，向线程池提交任务，会首先加入到等待队列中，当等待队列满了之后，再次提交任务，尝试加入队列就会失败，这时就会检查如果当前线程池中的线程数未达到最大线程，则会新建线程执行新提交的任务。所以最终可能出现后提交的任务先执行，而先提交的任务一直在等待。</p>
<p><code>LinkedBlockingQueue</code>：基于链表实现的阻塞队列，初始化可以指定大小，也可以不指定。</p>
<p>​    当指定大小后，行为就和<code>ArrayBlockingQueu</code>一致。而如果未指定大小，则会使用默认的<code>Integer.MAX_VALUE</code>作为队列大小。这时候就会出现线程池的最大线程数参数无用，因为无论如何，向线程池提交任务加入等待队列都会成功。最终意味着所有任务都是在核心线程执行。如果核心线程一直被占，那就一直等待。</p>
<p><code>SynchronousQueue</code> : 无容量的队列。</p>
<p>​    使用此队列意味着希望获得最大并发量。因为无论如何，向线程池提交任务，往队列提交任务都会失败。而失败后如果没有空闲的非核心线程，就会检查如果当前线程池中的线程数未达到最大线程，则会新建线程执行新提交的任务。完全没有任何等待，唯一制约它的就是最大线程数的个数。因此一般配合<code>Integer.MAX_VALUE</code>就实现了真正的无等待。</p>
<p>//lqr:TODO  <a target="_blank" rel="noopener" href="https://juejin.cn/post/6847902225730109454">https://juejin.cn/post/6847902225730109454</a></p>
<h2 id="拒绝策略rejectHander"><a href="#拒绝策略rejectHander" class="headerlink" title="拒绝策略rejectHander"></a>拒绝策略rejectHander</h2><p>当 Executor 已关闭时，以及当 Executor 对最大线程和工作队列容量使用有限界限且已饱和时，在方法execute(Runnable)中提交的新任务将被拒绝。在任一情况下， execute方法都会调用其<code>RejectedExecutionHandler</code>的<code>RejectedExecutionHandler.rejectedExecution(Runnable, ThreadPoolExecutor)</code>方法。提供了四种预定义的处理程序策略：</p>
<ol>
<li><p>在默认的ThreadPoolExecutor.AbortPolicy中，处理程序在被拒绝时会抛出运行时<code>RejectedExecutionException </code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">   <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">   e.toString());</span><br></pre></td></tr></table></figure></li>
<li><p>在ThreadPoolExecutor.CallerRunsPolicy中，调用execute的线程本身会运行任务。这提供了一种简单的反馈控制机制，可以减慢提交新任务的速度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">		r.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在ThreadPoolExecutor.DiscardPolicy中，无法执行的任务将被直接丢弃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;do nothing</span><br></pre></td></tr></table></figure></li>
<li><p>在ThreadPoolExecutor.DiscardOldestPolicy中，如果执行器未关闭，则工作队列头部的任务将被删除，然后重试执行（这可能会再次失败，导致重复此操作。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">    e.getQueue().poll();</span><br><span class="line">    e.execute(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="如果提交任务时，线程池队列已满，会发生什么"><a href="#如果提交任务时，线程池队列已满，会发生什么" class="headerlink" title="如果提交任务时，线程池队列已满，会发生什么"></a>如果提交任务时，线程池队列已满，会发生什么</h2><p>如果使用的LinkedBlockingQueue，也就是无界队列的话，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以无限存放任务；如果使用的是有界队列比方说ArrayBlockingQueue的话，则会使用拒绝策略RejectedExecutionHandler处理满了的任务。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-03-25T07:35:03.229Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-05-14T09:49:26.170Z" title="5/14/2024, 5:49:26 PM">2024-05-14</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">13 minutes read (About 1991 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/03/25/GraphicsOverriew/">Graphics</a></h1><div class="content"><h3 id="移动端渲染"><a href="#移动端渲染" class="headerlink" title="移动端渲染"></a><strong>移动端渲染</strong></h3><p><img src="/2024/03/25/GraphicsOverriew/3d5bf360cf944e2ab413b60b93c31515~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p></div><a class="article-more button is-small is-size-7" href="/2024/03/25/GraphicsOverriew/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-12-22T06:24:28.000Z" title="12/22/2023, 2:24:28 PM">2023-12-22</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-06-13T06:09:15.701Z" title="6/13/2024, 2:09:15 PM">2024-06-13</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">10 minutes read (About 1496 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/22/Fragment/">Fragment</a></h1><div class="content"><p><a target="_blank" rel="noopener" href="https://developer.android.com/guide/fragments/lifecycle?hl=zh-cn">https://developer.android.com/guide/fragments/lifecycle?hl=zh-cn</a></p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>//简述：还有一个生命周期是<code> onViewCreated()</code>，该生命周期会在onCreateView后立即调用（此时布局inflate已完成），故而一般fragment的onCreateView中执行inflate layout操作后返回rootView，之后在<code>onViewCreated</code>中执行具体的View操作。    </p>
<p><img src="/2023/12/22/Fragment/168137f2adfe6b44~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75-8250473.png" alt="168137f2adfe6b44~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75"></p>
<h1 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h1><h2 id="FragmentTransaction的4种提交方式"><a href="#FragmentTransaction的4种提交方式" class="headerlink" title="FragmentTransaction的4种提交方式"></a>FragmentTransaction的4种提交方式</h2><h3 id="commit-："><a href="#commit-：" class="headerlink" title="commit()："></a>commit()：</h3><p>commit是<strong>非同步提交（我认为不应称为异步）</strong>且<strong>检查是否存储状态</strong>的</p>
<blockquote>
<p>The commit does not happen immediately; it will be scheduled as work on the main thread to be done the next time that thread is ready.</p>
</blockquote>
<p>非同步提交：即操作会被post到主线程handler的消息队列中，等候轮到时执行；</p>
<p>检查存储状态：如果宿主(FragmentActivity)已经执行了onSaveInstanceState再执行该操作，会抛出异常</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FragmentManager.class</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkStateLoss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isStateSaved()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Can not perform this action after onSaveInstanceState&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="commitAllowingStateLoss"><a href="#commitAllowingStateLoss" class="headerlink" title="commitAllowingStateLoss():"></a><strong>commitAllowingStateLoss</strong>():</h3><p><strong>非同步提交</strong>且<strong>不检查状态</strong></p>
<p>如果在宿主执行了onSaveInstanceSate之后再执行该操作，不会去检查宿主状态,不会抛出异常。但该操作不会被Activity记录，恢复时也就没办法恢复这些提交操作，所以该操作适用不重要的事务。同属于异步事务。 </p>
<h3 id="commitNow"><a href="#commitNow" class="headerlink" title="commitNow():"></a>commitNow():</h3><p><strong>同步提交</strong>且<strong>检查状态</strong>。</p>
<p>会立刻执行当前提交的transaction事务。</p>
<h3 id="commitNowAllowingStateLoss"><a href="#commitNowAllowingStateLoss" class="headerlink" title="commitNowAllowingStateLoss():"></a><strong>commitNowAllowingStateLoss</strong>():</h3><p><strong>同步提交</strong>且<strong>不检查状态</strong></p>
<p>既是同步执行，也不会检查宿主的状态,有可能该操作不会被正确恢复</p>
<p>同时：<strong>使用 commitNow() 或 commitNowAllowingStateLoss() 提交的事务不允许加入回退栈</strong> </p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commitNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    disallowAddToBackStack();</span><br><span class="line">    mManager.execSingleAction(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commitNowAllowingStateLoss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    disallowAddToBackStack();</span><br><span class="line">    mManager.execSingleAction(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="Principle"><a href="#Principle" class="headerlink" title="Principle"></a>Principle</h1><p>源码中fragment的生命周期方法回调在于 内置定义的五种状态的转移：</p>
<p>当宿主生命周期发生变化时，Fragment 的状态会同步到宿主的状态。从源码看，体现在宿主生命周期回调中会调用 FragmentManager 中一系列 dispatchXXX() 方法来触发 Fragment 状态转移。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FragmentActivity</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    mFragmentLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);</span><br><span class="line">    mFragments.dispatchCreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//android.fragment:fragment:1.3.6   Fragment		</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIALIZING = -<span class="number">1</span>;          <span class="comment">// Not yet attached.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ATTACHED = <span class="number">0</span>;               <span class="comment">// Attached to the host.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CREATED = <span class="number">1</span>;                <span class="comment">// Created.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VIEW_CREATED = <span class="number">2</span>;           <span class="comment">// View Created.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AWAITING_EXIT_EFFECTS = <span class="number">3</span>;  <span class="comment">// Downward state, awaiting exit effects</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTIVITY_CREATED = <span class="number">4</span>;       <span class="comment">// Fully created, not started.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STARTED = <span class="number">5</span>;                <span class="comment">// Created and started, not resumed.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AWAITING_ENTER_EFFECTS = <span class="number">6</span>; <span class="comment">// Upward state, awaiting enter effects</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESUMED = <span class="number">7</span>;                <span class="comment">// Created started and resumed.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mState = INITIALIZING;</span><br></pre></td></tr></table></figure>

<p><strong>INITIALIZING，ATTACHED，CREATED，VIEW_CREATED，ACTIVITY_CREATED，STARTED，RESUMED</strong>七种状态轮换，每个状态轮换之间，生命周期也就自然被调用到</p>
<p>如一次创建流程，</p>
<p>枚举状态INITALIZING-&gt;RESUME，就会依次调用到：<strong>onAttach(), onCreate(), onCreateView(), onActivityCreate(), onStart(), onResume();</strong> </p>
<p>反之，RESUME-&gt;INITIALIZING，就会依次调用:<strong>onPause(), onStop(), onSaveInstanceState(), onDestroyView(), onDestroy(), onDetach()</strong></p>
<p>当然，是否需要被调用，case也会自己判断；</p>
<img src="/2023/12/22/Fragment/image-20231225150420117.png" alt="image-20231225150420117" style="zoom:30%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(<span class="meta">@NonNull</span> Fragment f, <span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    FragmentStateManager fragmentStateManager = mFragmentStore.getFragmentStateManager(f.mWho);</span><br><span class="line">    <span class="keyword">if</span> (fragmentStateManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Ideally, we only call moveToState() on active Fragments. However,</span></span><br><span class="line">        <span class="comment">// in restoreSaveState() we can call moveToState() on retained Fragments</span></span><br><span class="line">        <span class="comment">// just to clean them up without them ever being added to mActive.</span></span><br><span class="line">        <span class="comment">// For these cases, a brand new FragmentStateManager is enough.</span></span><br><span class="line">        fragmentStateManager = <span class="keyword">new</span> FragmentStateManager(mLifecycleCallbacksDispatcher,</span><br><span class="line">                mFragmentStore, f);</span><br><span class="line">        <span class="comment">// Only allow this FragmentStateManager to go up to CREATED at the most</span></span><br><span class="line">        fragmentStateManager.setFragmentManagerState(Fragment.CREATED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// When inflating an Activity view with a resource instead of using setContentView(), and</span></span><br><span class="line">    <span class="comment">// that resource adds a fragment using the &lt;fragment&gt; tag (i.e. from layout and in layout),</span></span><br><span class="line">    <span class="comment">// the fragment will move to the VIEW_CREATED state before the fragment manager</span></span><br><span class="line">    <span class="comment">// moves to CREATED. So when moving the fragment manager moves to CREATED and the</span></span><br><span class="line">    <span class="comment">// inflated fragment is already in VIEW_CREATED we need to move new state up from CREATED</span></span><br><span class="line">    <span class="comment">// to VIEW_CREATED. This avoids accidentally moving the fragment back down to CREATED</span></span><br><span class="line">    <span class="comment">// which would immediately destroy the Fragment&#x27;s view. We rely on computeExpectedState()</span></span><br><span class="line">    <span class="comment">// to pull the state back down if needed.</span></span><br><span class="line">    <span class="keyword">if</span> (f.mFromLayout &amp;&amp; f.mInLayout &amp;&amp; f.mState == Fragment.VIEW_CREATED) &#123;</span><br><span class="line">        newState = Math.max(newState, Fragment.VIEW_CREATED);</span><br><span class="line">    &#125;</span><br><span class="line">    newState = Math.min(newState, fragmentStateManager.computeExpectedState());</span><br><span class="line">    <span class="keyword">if</span> (f.mState &lt;= newState) &#123;</span><br><span class="line">        <span class="comment">// If we are moving to the same state, we do not need to give up on the animation.</span></span><br><span class="line">        <span class="keyword">if</span> (f.mState &lt; newState &amp;&amp; !mExitAnimationCancellationSignals.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// The fragment is currently being animated...  but!  Now we</span></span><br><span class="line">            <span class="comment">// want to move our state back up.  Give up on waiting for the</span></span><br><span class="line">            <span class="comment">// animation and proceed from where we are.</span></span><br><span class="line">            cancelExitAnimation(f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (f.mState) &#123;</span><br><span class="line">            <span class="keyword">case</span> Fragment.INITIALIZING:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.INITIALIZING) &#123;</span><br><span class="line">                    fragmentStateManager.attach();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> Fragment.ATTACHED:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.ATTACHED) &#123;</span><br><span class="line">                    fragmentStateManager.create();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> Fragment.CREATED:</span><br><span class="line">                <span class="comment">// We want to unconditionally run this anytime we do a moveToState that</span></span><br><span class="line">                <span class="comment">// moves the Fragment above INITIALIZING, including cases such as when</span></span><br><span class="line">                <span class="comment">// we move from CREATED =&gt; CREATED as part of the case fall through above.</span></span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.INITIALIZING) &#123;</span><br><span class="line">                    fragmentStateManager.ensureInflatedView();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.CREATED) &#123;</span><br><span class="line">                    fragmentStateManager.createView();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> Fragment.VIEW_CREATED:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.VIEW_CREATED) &#123;</span><br><span class="line">                    fragmentStateManager.activityCreated();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> Fragment.ACTIVITY_CREATED:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.ACTIVITY_CREATED) &#123;</span><br><span class="line">                    fragmentStateManager.start();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> Fragment.STARTED:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.STARTED) &#123;</span><br><span class="line">                    fragmentStateManager.resume();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f.mState &gt; newState) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (f.mState) &#123;</span><br><span class="line">            <span class="keyword">case</span> Fragment.RESUMED:</span><br><span class="line">                <span class="keyword">if</span> (newState &lt; Fragment.RESUMED) &#123;</span><br><span class="line">                    fragmentStateManager.pause();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> Fragment.STARTED:</span><br><span class="line">                <span class="keyword">if</span> (newState &lt; Fragment.STARTED) &#123;</span><br><span class="line">                    fragmentStateManager.stop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> Fragment.ACTIVITY_CREATED:</span><br><span class="line">                <span class="keyword">if</span> (newState &lt; Fragment.ACTIVITY_CREATED) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isLoggingEnabled(Log.DEBUG)) &#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">&quot;movefrom ACTIVITY_CREATED: &quot;</span> + f);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (f.mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// Need to save the current view state if not</span></span><br><span class="line">                        <span class="comment">// done already.</span></span><br><span class="line">                        <span class="keyword">if</span> (mHost.onShouldSaveFragmentState(f) &amp;&amp; f.mSavedViewState == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            fragmentStateManager.saveViewState();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> Fragment.VIEW_CREATED:</span><br><span class="line">                <span class="keyword">if</span> (newState &lt; Fragment.VIEW_CREATED) &#123;</span><br><span class="line">                    FragmentAnim.AnimationOrAnimator anim = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (f.mView != <span class="keyword">null</span> &amp;&amp; f.mContainer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// Stop any current animations:</span></span><br><span class="line">                        f.mContainer.endViewTransition(f.mView);</span><br><span class="line">                        f.mView.clearAnimation();</span><br><span class="line">                        <span class="comment">// If parent is being removed, no need to handle child animations.</span></span><br><span class="line">                        <span class="keyword">if</span> (!f.isRemovingParent()) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (mCurState &gt; Fragment.INITIALIZING &amp;&amp; !mDestroyed</span><br><span class="line">                                    &amp;&amp; f.mView.getVisibility() == View.VISIBLE</span><br><span class="line">                                    &amp;&amp; f.mPostponedAlpha &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                anim = FragmentAnim.loadAnimation(mHost.getContext(),</span><br><span class="line">                                        f, <span class="keyword">false</span>, f.getPopDirection());</span><br><span class="line">                            &#125;</span><br><span class="line">                            f.mPostponedAlpha = <span class="number">0</span>;</span><br><span class="line">                            <span class="comment">// Robolectric tests do not post the animation like a real device</span></span><br><span class="line">                            <span class="comment">// so we should keep up with the container and view in case the</span></span><br><span class="line">                            <span class="comment">// fragment view is destroyed before we can remove it.</span></span><br><span class="line">                            ViewGroup container = f.mContainer;</span><br><span class="line">                            View view = f.mView;</span><br><span class="line">                            <span class="keyword">if</span> (anim != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                FragmentAnim.animateRemoveFragment(f, anim,</span><br><span class="line">                                        mFragmentTransitionCallback);</span><br><span class="line">                            &#125;</span><br><span class="line">                            container.removeView(view);</span><br><span class="line">                            <span class="keyword">if</span> (FragmentManager.isLoggingEnabled(Log.VERBOSE)) &#123;</span><br><span class="line">                                Log.v(FragmentManager.TAG, <span class="string">&quot;Removing view &quot;</span> + view + <span class="string">&quot; for &quot;</span></span><br><span class="line">                                        + <span class="string">&quot;fragment &quot;</span> + f + <span class="string">&quot; from container &quot;</span> + container);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// If the local container is different from the fragment</span></span><br><span class="line">                            <span class="comment">// container, that means onAnimationEnd was called, onDestroyView</span></span><br><span class="line">                            <span class="comment">// was dispatched and the fragment was already moved to state, so</span></span><br><span class="line">                            <span class="comment">// we should early return here instead of attempting to move to</span></span><br><span class="line">                            <span class="comment">// state again.</span></span><br><span class="line">                            <span class="keyword">if</span> (container != f.mContainer) &#123;</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// If a fragment has an exit animation (or transition), do not destroy</span></span><br><span class="line">                    <span class="comment">// its view immediately and set the state after animating</span></span><br><span class="line">                    <span class="keyword">if</span> (mExitAnimationCancellationSignals.get(f) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        fragmentStateManager.destroyFragmentView();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> Fragment.CREATED:</span><br><span class="line">                <span class="keyword">if</span> (newState &lt; Fragment.CREATED) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mExitAnimationCancellationSignals.get(f) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// We are waiting for the fragment&#x27;s view to finish animating away.</span></span><br><span class="line">                        newState = Fragment.CREATED;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        fragmentStateManager.destroy();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// fall through</span></span><br><span class="line">            <span class="keyword">case</span> Fragment.ATTACHED:</span><br><span class="line">                <span class="keyword">if</span> (newState &lt; Fragment.ATTACHED) &#123;</span><br><span class="line">                    fragmentStateManager.detach();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f.mState != newState) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isLoggingEnabled(Log.DEBUG)) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;moveToState: Fragment state for &quot;</span> + f + <span class="string">&quot; not updated inline; &quot;</span></span><br><span class="line">                    + <span class="string">&quot;expected state &quot;</span> + newState + <span class="string">&quot; found &quot;</span> + f.mState);</span><br><span class="line">        &#125;</span><br><span class="line">        f.mState = newState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-12-20T08:33:02.000Z" title="12/20/2023, 4:33:02 PM">2023-12-20</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.402Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a><span> / </span><a class="link-muted" href="/categories/Android/Framework/">Framework</a></span><span class="level-item">10 minutes read (About 1480 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/20/ServiceManager/">ServiceManager</a></h1><div class="content"><h1 id="ServiceManager的启动"><a href="#ServiceManager的启动" class="headerlink" title="ServiceManager的启动"></a>ServiceManager的启动</h1><p>ServiceManager进程<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/frameworks/native/+/refs/heads/android10-android13-mainline-tzdata-release/cmds/servicemanager/service_manager.c">service_manager.c</a>并没有使用libbinder框架代码，而是自行编写了<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/frameworks/native/+/refs/heads/android10-android13-mainline-tzdata-release/cmds/servicemanager/binder.c">binder.c</a>直接和Binder驱动来通信，ServiceManager是单线程的进程， 不断地循环在binder_loop()过程来读取和处理事务，从而对外提供查询和注册服务的功能，这样的好处是简单而高效。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service_manager.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *driver;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        driver = argv[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        driver = <span class="string">&quot;/dev/binder&quot;</span>; <span class="comment">// 默认的Binder设备节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Step 1: 打开binder驱动，申请128k字节内存</span></span><br><span class="line">    bs = binder_open(driver, <span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Step 2: 成为上下文管理者</span></span><br><span class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Step 3: 进入无限循环，处理client端发来的请求</span></span><br><span class="line">    binder_loop(bs, svcmgr_handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动过程主要划分为以下几个阶段：(每个阶段具体见<a target="_blank" rel="noopener" href="https://gityuan.com/2014/01/02/servicemanager/">5.2.1 启动ServiceManager服务</a>)</p>
<p><img src="/2023/12/20/ServiceManager/create_servicemanager.jpg" alt="create_servicemanager"></p>
<ul>
<li><p>首先，打开设备驱动：调用binder_open()方法来打开binder驱动，默认地采用/dev/binder设备节点，申请地内存空间大小为128KB；</p>
</li>
<li><p>其次，注册成为大管家：调用binder_become_context_manager()方法，将自己注册成为binder服务的唯一管家；</p>
<blockquote>
<p>通过ioctl系统调用向Binder驱动发送命令BINDER_SET_CONTEXT_MGR，成为上下文的管理者，<strong>由于servicemanager进程启动非常早（先于Zygote）</strong>，可以确定在Binder整体机制正式投入产线之前，就能完成向Binder驱动注册成为大管家的工作。 关于驱动层处理BINDER_SET_CONTEXT_MGR命令的主要任务：</p>
<ul>
<li>保证每个Binder上下文有且仅有一个binder管家实体，如果已存在则不再创建</li>
<li>创建binder管家实体，初始化异步事务和binder工作两个队列，并分别增加其强弱引用计数</li>
<li>初始化当前binder_context的管家实体（binder_context_mgr_node）和管家uid(binder_context_mgr_uid)信息</li>
<li>handle等于0的服务实体都是指servicemanager管家实体</li>
</ul>
</blockquote>
</li>
<li><p>最后，等待客户请求：调用binder_loop()方法进入无限循环，作为守护进程，随时待命等待处理client端发来的请求。</p>
</li>
</ul>
<blockquote>
<p>servicemanager先向Binder驱动发送BC_ENTER_LOOPER协议，让ServiceManager进入循环。然后再向驱动发送BINDER_WRITE_READ命令， 进入内核态，等待客户端的请求数据。若没有数据，则进入等待状态，直到收到数据后返回用户态，解析并处理，周而复始地不断循环该过程。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; servicemanager&#x2F;binder.c</span><br><span class="line">void binder_loop(struct binder_state *bs, binder_handler func) &#123;</span><br><span class="line">    int res;</span><br><span class="line">    struct binder_write_read bwr;</span><br><span class="line">    uint32_t readbuf[32];</span><br><span class="line"></span><br><span class="line">    bwr.write_size &#x3D; 0;</span><br><span class="line">    bwr.write_consumed &#x3D; 0;</span><br><span class="line">    bwr.write_buffer &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    readbuf[0] &#x3D; BC_ENTER_LOOPER;</span><br><span class="line">    &#x2F;&#x2F;向binder驱动发送BC_ENTER_LOOPER协议</span><br><span class="line">    binder_write(bs, readbuf, sizeof(uint32_t));</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        bwr.read_size &#x3D; sizeof(readbuf);</span><br><span class="line">        bwr.read_consumed &#x3D; 0;</span><br><span class="line">        bwr.read_buffer &#x3D; (uintptr_t) readbuf;</span><br><span class="line">        &#x2F;&#x2F;等待客户的数据</span><br><span class="line">        res &#x3D; ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">        &#x2F;&#x2F;解析binder信息</span><br><span class="line">        res &#x3D; binder_parse(bs, 0, (uintptr_t) readbuf, bwr.read_consumed, func);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<h1 id="ServiceManager提供的服务"><a href="#ServiceManager提供的服务" class="headerlink" title="ServiceManager提供的服务"></a>ServiceManager提供的服务</h1><p>ServiceManager对外提供查询/注册功能，通过接收到客户端进程发送过来的BR_TRANSACTION协议。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; service_manager.c</span><br><span class="line">int svcmgr_handler(struct binder_state *bs,</span><br><span class="line">                   struct binder_transaction_data *txn,</span><br><span class="line">                   struct binder_io *msg,</span><br><span class="line">                   struct binder_io *reply)</span><br><span class="line">&#123;</span><br><span class="line">    struct svcinfo *si;</span><br><span class="line">    uint16_t *s;</span><br><span class="line">    size_t len;</span><br><span class="line">    uint32_t handle;</span><br><span class="line">    uint32_t strict_policy;</span><br><span class="line">    int allow_isolated;</span><br><span class="line">    ...</span><br><span class="line">    strict_policy &#x3D; bio_get_uint32(msg);</span><br><span class="line">    s &#x3D; bio_get_string16(msg, &amp;len);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    switch(txn-&gt;code) &#123;</span><br><span class="line">    case SVC_MGR_GET_SERVICE:</span><br><span class="line">    case SVC_MGR_CHECK_SERVICE:</span><br><span class="line">        s &#x3D; bio_get_string16(msg, &amp;len); &#x2F;&#x2F;服务名</span><br><span class="line">        &#x2F;&#x2F;根据名称查找相应服务</span><br><span class="line">        handle &#x3D; do_find_service(bs, s, len, txn-&gt;sender_euid, txn-&gt;sender_pid);</span><br><span class="line">        bio_put_ref(reply, handle);</span><br><span class="line">        return 0;</span><br><span class="line">    </span><br><span class="line">    case SVC_MGR_ADD_SERVICE:</span><br><span class="line">        s &#x3D; bio_get_string16(msg, &amp;len); &#x2F;&#x2F;服务名</span><br><span class="line">        handle &#x3D; bio_get_ref(msg); &#x2F;&#x2F;服务实体在servicemanager中的handle</span><br><span class="line">        allow_isolated &#x3D; bio_get_uint32(msg) ? 1 : 0;</span><br><span class="line">         &#x2F;&#x2F;注册指定服务</span><br><span class="line">        if (do_add_service(bs, s, len, handle, txn-&gt;sender_euid,</span><br><span class="line">            allow_isolated, txn-&gt;sender_pid))</span><br><span class="line">            return -1;</span><br><span class="line">        break;</span><br><span class="line">    </span><br><span class="line">    case SVC_MGR_LIST_SERVICES: &#123;  </span><br><span class="line">        uint32_t n &#x3D; bio_get_uint32(msg);</span><br><span class="line">        if (!svc_can_list(txn-&gt;sender_pid)) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        si &#x3D; svclist;</span><br><span class="line">        while ((n-- &gt; 0) &amp;&amp; si)</span><br><span class="line">            si &#x3D; si-&gt;next;</span><br><span class="line">        if (si) &#123;</span><br><span class="line">            bio_put_string16(reply, si-&gt;name);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bio_put_uint32(reply, 0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<p>该方法的功能：查询服务，注册服务，以及列举所有服务。不同的code对应不同的工作，定义在IBinder.h文件，跟IServiceManager.h中定义的code具有一一对应关系，具体关系如下所示。</p>
<table>
<thead>
<tr>
<th align="left">code</th>
<th align="left">IBinder.h</th>
<th align="left">IServiceManager.h</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">SVC_MGR_GET_SERVICE</td>
<td align="left">GET_SERVICE_TRANSACTION</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">SVC_MGR_CHECK_SERVICE</td>
<td align="left">CHECK_SERVICE_TRANSACTION</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">SVC_MGR_ADD_SERVICE</td>
<td align="left">ADD_SERVICE_TRANSACTION</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">SVC_MGR_LIST_SERVICES</td>
<td align="left">LIST_SERVICES_TRANSACTION</td>
</tr>
</tbody></table>
<h2 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h2><p>servicemanager进程里面有一个链表svclist，记录着所有注册的服务svcinfo，每一个服务用svcinfo结构体来表示，该handle值是在注册服务的过程中，由服务所在进程那一端所确定的。svcinfo结构体如下所示。</p>
<img src="/2023/12/20/ServiceManager/5-2-1-service_manager.jpg" alt="ServiceManager进程" style="zoom:80%;">


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> handle; <span class="comment">//服务的handle值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_death</span> <span class="title">death</span>;</span></span><br><span class="line">    <span class="keyword">int</span> allow_isolated;</span><br><span class="line">    <span class="keyword">size_t</span> len; <span class="comment">//服务名的长度</span></span><br><span class="line">    <span class="keyword">uint16_t</span> name[<span class="number">0</span>]; <span class="comment">//服务名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>整个ServiceManager启动过程的完整流程，这里整个过程都的都离不开Binder驱动层的实现。</p>
<p><img src="/2023/12/20/ServiceManager/5-2-2.start_service_manager.jpg" alt="ServiceManager启动过程"></p>
<h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><h3 id="vndservicemanager"><a href="#vndservicemanager" class="headerlink" title="vndservicemanager"></a>vndservicemanager</h3><p>以前，Binder 服务通过 <code>servicemanager</code> 注册，其他进程可从中检索这些服务。在 Android 8 中，<code>servicemanager</code> 现在专供框架使用，而应用进程和供应商进程无法再对其进行访问。</p>
<p>不过，供应商服务现在可以使用 <code>vndservicemanager</code>，这是一个使用 <code>/dev/vndbinder</code>（作为构建基础的源代码与框架 <code>servicemanager</code> 的相同）而非 <code>/dev/binder</code> 的 <code>servicemanager</code> 的新实例。供应商进程无需更改即可与 <code>vndservicemanager</code> 通信；当供应商进程打开 /<code>dev/vndbinder</code> 时，服务查询会自动转至 <code>vndservicemanager</code>。</p>
<p><code>vndservicemanager</code> 二进制文件包含在 Android 的默认设备 Makefile 中。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-10-26T03:34:39.000Z" title="10/26/2023, 11:34:39 AM">2023-10-26</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-04-17T06:45:43.567Z" title="4/17/2024, 2:45:43 PM">2024-04-17</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">25 minutes read (About 3729 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/26/Animation/">Animation</a></h1><div class="content"><p>Android动画分三种：View动画、帧动画、属性动画</p>
<p><img src="/2023/10/26/Animation/image-20231027151841094.png" alt="image-20231027151841094"></p>
<p>是的， check， √</p>
<h2 id="View动画"><a href="#View动画" class="headerlink" title="View动画"></a>View动画</h2><p>View动画定义了渐变Alpha、旋转Rotate、缩放Scale、平移Translate四种基本动画，并且通过这四种基本动画的组合使用，可以实现多种交互效果。<br>View动画使用非常简单，不仅可以通过XML文件来定义动画，同样可以通过Java代码来实现动画过程。</p>
<p>原理：</p>
<p>首先view的绘制是 drawBackground() -&gt; onDraw() -&gt; dispatchDraw() -&gt; onDrawForeground() 的顺序，</p>
<p>//android/view/View.java中的boolean draw(Canvas canvas, ViewGroup parent, long drawingTime)方法</p>
<p>View.setAnimation会将旋转、缩放、平移等动画存下来，动画启动后通过invalidate() ，每一帧中在draw的时候通过canvas.translate、canvas.scale、cavas.setLayerAlpha等方式，执行动画。</p>
<p>故而view动画只会影响view的视觉效果，而不影响起事件响应区域，因为只有draw中处理了，measure和layout都没动</p>
<h3 id="Xml文件实现"><a href="#Xml文件实现" class="headerlink" title="Xml文件实现"></a>Xml文件实现</h3><p>通过xml来定义View动画涉及到一些公有的属性（在AndroidStudio上不能提示）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android:duration     动画持续时间</span><br><span class="line">android:fillAfter    为true动画结束时，View将保持动画结束时的状态</span><br><span class="line">android:fillBefore   为true动画结束时，View将还原到开始开始时的状态</span><br><span class="line">android:repeatCount  动画重复执行的次数</span><br><span class="line">android:repeatMode   动画重复模式 ，重复播放时restart重头开始，reverse重复播放时倒叙回放，该属性需要和android:repeatCount一起使用</span><br><span class="line">android:repeatCount 默认是0，-1是无限循环</span><br><span class="line">android:interpolator 插值器，相当于变速器，改变动画的不同阶段的执行速度</span><br></pre></td></tr></table></figure>

<p>这些属性是从Animation中继承下来的，在<code>alpha</code>、<code>rotate</code>、<code>scale</code>、<code>translate</code>标签中都可以直接使用。<br>利用xml文件定义View动画需要在工程的res目录下创建anim文件夹，所有的xml定义的View动画都要放在anim目录下。其中标签   translate、scale、alpha、rotate，就是对应四种动画。set标签是动画集合，对应AnimationSet类，有多个动画构成。</p>
<p>其中android:duration是指动画时间，fillAfter为true是动画结束后保持，false会回到初始状态。interpolator是指动画的执行速度，默认是先加速后减速。其他标签及属性较简单可自行研究验证。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">&quot;5000&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fillAfter</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:interpolator</span>=<span class="string">&quot;@android:anim/accelerate_decelerate_interpolator&quot;</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--set里面的duration如果有值，会覆盖子标签的duration--&gt;</span></span><br><span class="line"></span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration=&quot;1000&quot;</span><br><span class="line">        android:fromXDelta=&quot;0&quot;</span><br><span class="line">        android:toXDelta=&quot;400&quot; /&gt;</span><br><span class="line">    &lt;scale</span><br><span class="line">        android:duration=&quot;2000&quot;</span><br><span class="line">        android:fromXScale=&quot;0.5&quot;</span><br><span class="line">        android:fromYScale=&quot;0.5&quot;</span><br><span class="line">        android:toXScale=&quot;1&quot;</span><br><span class="line">        android:toYScale=&quot;1&quot; /&gt;</span><br><span class="line">    &lt;alpha</span><br><span class="line">        android:duration=&quot;3000&quot;</span><br><span class="line">        android:fromAlpha=&quot;0.2&quot;</span><br><span class="line">        android:toAlpha=&quot;1&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;rotate</span><br><span class="line">        android:fromDegrees=&quot;0&quot;</span><br><span class="line">        android:toDegrees=&quot;90&quot; /&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>定义好动画后，使用也很简单，调用view的startAnimation方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//view动画使用，方式一：xml，建议使用。</span></span><br><span class="line">      Animation animation = AnimationUtils.loadAnimation(<span class="keyword">this</span>, R.anim.animation_test);</span><br><span class="line">      textView1.startAnimation(animation);</span><br></pre></td></tr></table></figure>

<p><code>rotate</code>、<code>scale</code>动画的<code>android:pivotX</code>和<code>android:pivotY</code>属性、<code>translate</code>动画的<code>android:toXDelta</code>和<code>android:toYDelta</code>属性的取值都可以是都可以数值、百分数、百分数<code>p</code>，比如：<code>50</code>、<code>50%</code>、<code>50%p</code>，他们取值的代表的意义各不相同：<br><code>50</code>表示以View左上角为原点沿坐标轴正方向(<code>x</code>轴向右，<code>y</code>轴向下)偏移<code>50px</code>的位置；<br><code>50%</code>表示以View左上角为原点沿坐标轴正方向(<code>x</code>轴向右，<code>y</code>轴向下)偏移View宽度或高度的50%处的位置；<br><code>50%p</code>表示以View左上角为原点沿坐标轴正方向(<code>x</code>轴向右，<code>y</code>轴向下)偏移父控件宽度或高度的50%处的位置（<code>p</code>表示相对于<code>ParentView</code>的位置）。</p>
<p>“50”：<img src="/2023/10/26/Animation/207f5681fbd42866692f260039ceaca8~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img" style="zoom: 50%;">  ； </p>
<p> “50%”<img src="/2023/10/26/Animation/8fafba2a2171db1efb63052a0370faed~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img" style="zoom:50%;">；</p>
<p>“50%p”<img src="/2023/10/26/Animation/613da23e462d2d04b9afa15d27029749~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img" style="zoom:50%;"></p>
<h3 id="代码动态实现"><a href="#代码动态实现" class="headerlink" title="代码动态实现"></a>代码动态实现</h3><p>在平常的业务逻辑中也可以直接用Java代码来实现Veiw动画，Android系统给我们提供了<code>AlphaAnimation</code>、<code>RotateAnimation</code>、<code>ScaleAnimation</code>、<code>TranslateAnimation</code>四个动画类分别来实现View的渐变、旋转、缩放、平移动画。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;view动画使用，方式二：new 动画对象</span><br><span class="line">        AnimationSet animationSet &#x3D; new AnimationSet(false);</span><br><span class="line">        animationSet.setDuration(3000);</span><br><span class="line">        animationSet.addAnimation(new TranslateAnimation(0, 100, 0, 0));</span><br><span class="line">        animationSet.addAnimation(new ScaleAnimation(0.1f, 1f, 0.1f, 1f));</span><br><span class="line">        animationSet.setFillAfter(true);</span><br><span class="line">        textView2.startAnimation(animationSet);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;view动画使用，方式二：new 动画对象,使用setAnimation</span><br><span class="line">        AnimationSet animationSet2 &#x3D; new AnimationSet(false);</span><br><span class="line">        animationSet2.setDuration(3000);</span><br><span class="line">        animationSet2.addAnimation(new TranslateAnimation(0, 100, 0, 0));</span><br><span class="line">        animationSet2.addAnimation(new ScaleAnimation(0.1f, 1f, 0.1f, 1f));</span><br><span class="line">        animationSet2.setFillAfter(true);</span><br><span class="line">        animationSet2.setAnimationListener(new Animation.AnimationListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationStart(Animation animation) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationEnd(Animation animation) &#123;</span><br><span class="line">                MyToast.showMsg(AnimationTestActivity.this, &quot;View动画：代码 set：View动画结束~&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationRepeat(Animation animation) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        textView3.setAnimation(animationSet2);</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ol>
<li>startAnimation方法是立刻播放动画；setAnimation是设置要播放的下一个动画。</li>
<li>setAnimationListener可以监听动画的开始、结束、重复。</li>
</ol>
<h3 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904105589080078#heading-3">[3D旋转动画]</a></p>
<p>Like:ProgressBarAnimation</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProgressBarAnimation</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> progressBar: ProgressBar, <span class="keyword">private</span> <span class="keyword">val</span> from: <span class="built_in">Int</span>, <span class="keyword">private</span> <span class="keyword">val</span> to: <span class="built_in">Int</span>) :</span><br><span class="line">    Animation() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">applyTransformation</span><span class="params">(interpolatedTime: <span class="type">Float</span>, t: <span class="type">Transformation</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.applyTransformation(interpolatedTime, t)</span><br><span class="line">        <span class="keyword">val</span> value = from + (to - from) * interpolatedTime</span><br><span class="line">        progressBar.progress = value.toInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="布局动画"><a href="#布局动画" class="headerlink" title="布局动画"></a>布局动画</h3><h4 id="LayoutTransition"><a href="#LayoutTransition" class="headerlink" title="LayoutTransition"></a>LayoutTransition</h4><p>使用LayoutAnimation给ViewGroup指定child的出场动画，方法如下：</p>
<p>1.先用xml定义标签LayoutAnimation：</p>
<ul>
<li>android:animation设置child的出场动画</li>
<li>android:animationOrder设置child的出场顺序，normal就是顺序</li>
<li>delay是指：每个child延迟（在android:animation中指定的动画时间）0.8倍后播放动画。如果android:animation中的动画时间是100ms，那么每个child都会延迟800ms后播放动画。 如果不设置delay，那么所有child同时执行动画。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layoutAnimation xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    android:animation&#x3D;&quot;@anim&#x2F;enter_from_left_for_child_of_group&quot;</span><br><span class="line">    android:animationOrder&#x3D;&quot;normal&quot;</span><br><span class="line">    android:delay&#x3D;&quot;0.8&quot;&gt;</span><br><span class="line">&lt;&#x2F;layoutAnimation&gt;</span><br><span class="line">R.anim.enter_from_left_for_child_of_group</span><br><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;set xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;</span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration&#x3D;&quot;1000&quot;</span><br><span class="line">        android:fromXDelta&#x3D;&quot;-100%p&quot;</span><br><span class="line">        android:toXDelta&#x3D;&quot;0&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;set&gt;</span><br></pre></td></tr></table></figure>

<p>2.把LayoutAnimation设置给ViewGroup</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout</span><br><span class="line">    android:id=&quot;@+id/ll_layout_animation&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:orientation=&quot;horizontal&quot;</span><br><span class="line">    android:layoutAnimation=&quot;@anim/layout_animation&quot;&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=&quot;50dp&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:textColor=&quot;#ff0000&quot;</span><br><span class="line">        android:text=&quot;呵呵呵&quot;/&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=&quot;60dp&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:textColor=&quot;#ff0000&quot;</span><br><span class="line">        android:text=&quot;qq&quot;</span><br><span class="line">        android:background=&quot;@color/colorPrimary&quot;/&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=&quot;30dp&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:textColor=&quot;#ff0000&quot;</span><br><span class="line">        android:text=&quot;啊啊&quot;/&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>除了xml，当然也可以使用LayoutAnimationController 指定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码设置LayoutAnimation，实现ViewGroup的child的出场动画</span></span><br><span class="line">Animation enterAnim = AnimationUtils.loadAnimation(<span class="keyword">this</span>, R.anim.enter_from_left_for_child_of_group);</span><br><span class="line">LayoutAnimationController controller = <span class="keyword">new</span> LayoutAnimationController(enterAnim);</span><br><span class="line">controller.setDelay(<span class="number">0.8f</span>);</span><br><span class="line">controller.setOrder(LayoutAnimationController.ORDER_NORMAL);</span><br><span class="line">llLayoutAnimation.setLayoutAnimation(controller);</span><br></pre></td></tr></table></figure>



<h4 id="animateLayoutChanges用处及原理"><a href="#animateLayoutChanges用处及原理" class="headerlink" title="animateLayoutChanges用处及原理"></a>animateLayoutChanges用处及原理</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:animateLayoutChanges=&quot;true&quot;</span><br></pre></td></tr></table></figure>

<p><strong>animateLayoutChanges的实际实现就是LayoutTransition，</strong></p>
<p>android.view.ViewGroup.java</p>
<p><img src="/2023/10/26/Animation/image-20231026114011752.png" alt="image-20231026114011752"></p>
<h3 id="Dialog-Activity转场动画"><a href="#Dialog-Activity转场动画" class="headerlink" title="Dialog/Activity转场动画"></a>Dialog/Activity转场动画</h3><h4 id="Activity转场"><a href="#Activity转场" class="headerlink" title="Activity转场"></a>Activity转场</h4><p>overridePendingTransition</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class XXActivity : Activity() &#123;</span><br><span class="line">	override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">      super.onCreate(savedInstanceState)</span><br><span class="line">      setContentView(R.layout.activity_checkout_rec)</span><br><span class="line">      overridePendingTransition(</span><br><span class="line">          R.anim.slide_in_down, R.anim.slide_in_down</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;set</span><br><span class="line">  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">  android:interpolator=&quot;@android:anim/decelerate_interpolator&quot; &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">translate</span> <span class="attr">android:duration</span>=<span class="string">&quot;200&quot;</span> <span class="attr">android:fromYDelta</span>=<span class="string">&quot;100%p&quot;</span> <span class="attr">android:toYDelta</span>=<span class="string">&quot;0%p&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;set</span><br><span class="line">  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">  android:interpolator=&quot;@android:anim/decelerate_interpolator&quot; &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">translate</span> <span class="attr">android:duration</span>=<span class="string">&quot;200&quot;</span> <span class="attr">android:fromYDelta</span>=<span class="string">&quot;0%p&quot;</span> <span class="attr">android:toYDelta</span>=<span class="string">&quot;100%p&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Dialog转场"><a href="#Dialog转场" class="headerlink" title="Dialog转场"></a>Dialog转场</h4><p>Window?.setWindowAnimatinos()</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXDialog</span></span>(context: Context, <span class="keyword">val</span> anim: PointBean.PointAnimation) :Dialog(context) &#123;</span><br><span class="line">  <span class="keyword">init</span> &#123;</span><br><span class="line">    setContentView(R.layout.threshold_dialog)</span><br><span class="line">    setCanceledOnTouchOutside(<span class="literal">true</span>)</span><br><span class="line">    window?.setGravity(Gravity.CENTER)</span><br><span class="line">    window?.setLayout(MATCH_PARENT, AndroidUtil.getScreenWidth(context))</span><br><span class="line">    window?.setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT));</span><br><span class="line">    window?.setWindowAnimations(R.style.XXDialogAnim)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;XXDialogAnim&quot;</span> <span class="attr">mce_bogus</span>=<span class="string">&quot;1&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;android:Animation&quot;</span>&gt;</span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowEnterAnimation&quot;</span>&gt;</span>@anim/cart_threshold_dialog_enter_anim<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowExitAnimation&quot;</span>&gt;</span>@anim/cart_threshold_dialog_exit_anim<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>







<h2 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h2><p>属性动画本质上是 使用反射调用对象的setXX()、getXX()方法，根据插值器的值变化曲线修改对象属性，所以是视图实实在在的位置、尺寸等属性发生变化并会触发measure、layout，因此点击区域也就发生变化。</p>
<p>属性动画可对任意对象做动画，不仅仅是View。默认动画时间是300ms，10ms/帧。具体理解就是：<strong>可在给定的时间间隔内 实现 对象的某属性值 从 value1 到 value2的改变。</strong></p>
<p>使用很简单，可以直接<strong>代码实现</strong>（推荐），也可xml实现，举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//属性动画使用，方式一：代码，建议使用。 横移</span></span><br><span class="line">      ObjectAnimator translationX = ObjectAnimator</span><br><span class="line">              .ofFloat(textView6, <span class="string">&quot;translationX&quot;</span>, <span class="number">0</span>, <span class="number">200</span>)</span><br><span class="line">              .setDuration(<span class="number">1000</span>);</span><br><span class="line">      translationX.setInterpolator(<span class="keyword">new</span> LinearInterpolator());</span><br><span class="line">      setAnimatorListener(translationX);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//属性动画使用，方式二：xml。   竖移</span></span><br><span class="line">      Animator animatorUpAndDown = AnimatorInflater.loadAnimator(<span class="keyword">this</span>, R.animator.animator_test);</span><br><span class="line">      animatorUpAndDown.setTarget(textView6);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//文字颜色变化</span></span><br><span class="line">      ObjectAnimator textColor = ObjectAnimator</span><br><span class="line">              .ofInt(textView6, <span class="string">&quot;textColor&quot;</span>, <span class="number">0xffff0000</span>, <span class="number">0xff00ffff</span>)</span><br><span class="line">              .setDuration(<span class="number">1000</span>);</span><br><span class="line">      textColor.setRepeatCount(ValueAnimator.INFINITE);</span><br><span class="line">      textColor.setRepeatMode(ValueAnimator.REVERSE);</span><br><span class="line">      <span class="comment">//注意，这里如果不设置 那么颜色就是跳跃的，设置ArgbEvaluator 就是连续过度的颜色变化</span></span><br><span class="line">      textColor.setEvaluator(<span class="keyword">new</span> ArgbEvaluator());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//animatorSet</span></span><br><span class="line">      mAnimatorSet = <span class="keyword">new</span> AnimatorSet();</span><br><span class="line">      mAnimatorSet</span><br><span class="line">              .play(animatorUpAndDown)</span><br><span class="line">              .with(textColor)</span><br><span class="line">              .after(translationX);</span><br><span class="line"></span><br><span class="line">      mAnimatorSet.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置属性动画的监听</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> translationX</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setAnimatorListener</span><span class="params">(ObjectAnimator translationX)</span> </span>&#123;</span><br><span class="line">      translationX.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">              <span class="comment">//每播放一帧，都会调用</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">          translationX.addPauseListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationResume</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">super</span>.onAnimationResume(animation);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      translationX.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">super</span>.onAnimationEnd(animation);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>R.animator.animator_test，是放在res/animator中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--属性动画test,一般建议采用代码实现，不用xml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:ordering</span>=<span class="string">&quot;sequentially&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--repeatCount：默认是0，-1是无限循环--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--repeatMode：重复模式：restart-从头来一遍、reverse-反向来一遍--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--valueType：指定propertyName的类型可选intType、floatType--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--android:pathData=&quot;&quot;</span></span><br><span class="line"><span class="comment">        android:propertyXName=&quot;&quot;</span></span><br><span class="line"><span class="comment">        android:propertyYName=&quot;&quot;--&gt;</span></span><br><span class="line">    &lt;objectAnimator</span><br><span class="line">        android:propertyName=&quot;translationY&quot;</span><br><span class="line">        android:duration=&quot;1000&quot;</span><br><span class="line">        android:valueFrom=&quot;0&quot;</span><br><span class="line">        android:valueTo=&quot;120&quot;</span><br><span class="line">        android:startOffset=&quot;0&quot;</span><br><span class="line">        android:repeatCount=&quot;0&quot;</span><br><span class="line">        android:repeatMode=&quot;reverse&quot;</span><br><span class="line">        android:valueType=&quot;floatType&quot;</span><br><span class="line">        android:interpolator=&quot;@android:interpolator/accelerate_decelerate&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--animator对用vueAnimator，比objectAnimator少了propertyName--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;animator--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--android:duration=&quot;2000&quot;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--android:valueFrom=&quot;&quot;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--android:valueTo=&quot;&quot;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--android:startOffset=&quot;&quot;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--android:repeatCount=&quot;&quot;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--android:repeatMode=&quot;&quot;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--android:valueType=&quot;&quot;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--android:interpolator=&quot;&quot;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--android:pathData=&quot;&quot;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--android:propertyXName=&quot;&quot;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--android:propertyYName=&quot;&quot;/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>translationX是实现横移，animatorUpAndDown是实现竖移、textColor是实现文字颜色变化。其中animatorUpAndDown是使用xml定义，标签含义也很好理解。 最后使用AnimatorSet的play、with、after 实现 先横移，然后 竖移和颜色变化 同时的动画集合效果。</p>
<p><strong>注意点</strong>：</p>
<ol>
<li><strong>关于View动画和属性动画的平移</strong>，<strong>属性动画改变属性值setTranslationX 的视图效果像view动画的平移一样，都是view实际的layout位置没变，只改变了视图位置；不同点是属性动画 给触摸点生效区域增加了位移（而view动画仅改变了视图位置）。</strong></li>
<li><strong>插值器</strong>：Interpolator，根据 时间流逝的百分比，计算当前属性值改变的百分比。    例如duration是1000，start后过了200，那么时间百分比是0.2，那么如果差值器是LinearInterpolator线性差值器，那么属性值改变的百分比也是0.2</li>
<li><strong>估值器</strong>：Evaluator，就是根据 差值器获取的 属性值百分比，计算改变后的属性值。  ofInt、onFloat内部会自动设置IntEvaluator、FloatEvaluator。如果使用ofInt且是颜色相关的属性，就要设置ArgbEvaluator。 上面例子中 文字颜色变化动画 设置了ArgbEvaluator：textColor.setEvaluator(new ArgbEvaluator())。</li>
<li><strong>动画监听</strong>：主要是两个监听接口，AnimatorUpdateListener、AnimatorListenerAdapter。AnimatorUpdateListener的回调方法在每帧更新时都会调用一次；AnimatorListenerAdapter可以监听开始、结束、暂停、继续、重复、取消，重写你要关注的方法即可。</li>
</ol>
<h3 id="对任意属性做动画"><a href="#对任意属性做动画" class="headerlink" title="对任意属性做动画"></a>对任意属性做动画</h3><p>一个问题，针对下面的Button，如何实现 的宽度逐渐拉长的动画，即文字不变，仅拉长背景宽度？</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">    android:id=&quot;@+id/button_animator_test&quot;</span><br><span class="line">    android:layout_width=&quot;180dp&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:text=&quot;任意属性动画-宽度拉长&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>首先，View动画的ScaleAnimation是无法实现的，因为view的scale是把view的视图放大，这样文字也会拉长变形。那么属性动画呢？试试~</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator width1 = ObjectAnimator.ofInt(button, &quot;width&quot;, 1000);</span><br><span class="line">width1.setDuration(2000);</span><br><span class="line">width1.start();</span><br></pre></td></tr></table></figure>

<p>但是发现，没有效果！这是为啥呢？解释如下.</p>
<p><strong>对object 的任意属性做动画 要求两个条件：</strong></p>
<ol>
<li>object有 对应属性 的set方法，动画中没设置初始值 还要有get方法，系统要去取初始值（不满足则会crash）。</li>
<li>set方法要对object有所改变，如UI的变化。不满足则会没有动画效果</li>
</ol>
<p>上面Button没有动画效果，就是没有满足第二条。看下Button的setWidth方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> pixels)</span> </span>&#123;</span><br><span class="line">    mMaxWidth = mMinWidth = pixels;</span><br><span class="line">    mMaxWidthMode = mMinWidthMode = PIXELS;</span><br><span class="line">    requestLayout();</span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际就是TextView的setWidth方法，看到设置进去的值仅影响了宽度最大值和最小值。按照官方注释和实测，发现只有当Button/TextView在xml中设置android:layout_width为”wrap_content”时，才会setWidth改变宽度；而当Button/TextView在xml中设置android:layout_width为固定dp值时，setWidth无效。 而我们上面给出的Button xml中确实是固定值180dp，所以是属性”width”的setWidth是无效的，即不满足第二条要求，就没有动画效果了。（当修改Button xml中设置android:layout_width为”wrap_content”时，上面执行的属性动画是生效的。）</p>
<p>那么，当不满足条件时，如何解决此问题呢？ 有如下处理方法：</p>
<ol>
<li>给object添加set、get方法，如果有权限。（一般不行，如TextView是SDK里面的不能直接改）</li>
<li><strong>给Object包装一层，在包装类中提供set、get方法。</strong></li>
<li><strong>使用ValueAnimator，监听Value变化过程，自己实现属性的改变。</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testAnimatorAboutButtonWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Button width 属性动画：如果xml中宽度是wrap_content，那么动画有效。</span></span><br><span class="line">        <span class="comment">// 如果设置button确切的dp值，那么无效，因为对应属性&quot;width&quot;的setWidth()方法就是 在wrap_content是才有效。</span></span><br><span class="line">        ObjectAnimator width1 = ObjectAnimator.ofInt(button, <span class="string">&quot;width&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">        width1.setDuration(<span class="number">2000</span>);</span><br><span class="line"><span class="comment">//        width1.start();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//那么，想要在button原本有确切dp值时，要能对width动画，怎么做呢？</span></span><br><span class="line">        <span class="comment">//方法一，包一层，然后用layoutParams</span></span><br><span class="line">        ViewWrapper wrapper = <span class="keyword">new</span> ViewWrapper(button);</span><br><span class="line">        ObjectAnimator width2 = ObjectAnimator.ofInt(wrapper, <span class="string">&quot;width&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">        width2.setDuration(<span class="number">2000</span>);</span><br><span class="line"><span class="comment">//        width2.start();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法二，使用ValueAnimator，每一帧自己显示宽度的变化</span></span><br><span class="line">        ValueAnimator valueAnimator = ValueAnimator.ofInt(button.getLayoutParams().width, <span class="number">1000</span>);</span><br><span class="line">        valueAnimator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> animatedValue = (Integer) animation.getAnimatedValue();</span><br><span class="line">                Log.i(<span class="string">&quot;hfy&quot;</span>, <span class="string">&quot;onAnimationUpdate: animatedValue=&quot;</span> + animatedValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">//                IntEvaluator intEvaluator = new IntEvaluator();</span></span><br><span class="line"><span class="comment">////                获取属性值改变比例、计算属性值</span></span><br><span class="line"><span class="comment">//                float animatedFraction = animation.getAnimatedFraction();</span></span><br><span class="line"><span class="comment">//                Integer evaluate = intEvaluator.evaluate(animatedFraction, 300, 600);</span></span><br><span class="line"><span class="comment">//                Log.i(&quot;hfy&quot;, &quot;onAnimationUpdate: evaluate=&quot;+evaluate);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (button != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    button.getLayoutParams().width = animatedValue;</span><br><span class="line">                    button.requestLayout();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        valueAnimator.setDuration(<span class="number">4000</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包一层，提供对应属性的set、get方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> View mView;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ViewWrapper</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            mView = view;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mView.getLayoutParams().width;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">            ViewGroup.LayoutParams layoutParams = mView.getLayoutParams();</span><br><span class="line">            layoutParams.width = width;</span><br><span class="line">            mView.setLayoutParams(layoutParams);</span><br><span class="line">            mView.requestLayout();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h3 id="属性动画的原理"><a href="#属性动画的原理" class="headerlink" title="属性动画的原理"></a>属性动画的原理</h3><p>属性动画，要求对象有这个属性的set方法，执行时会根据传入的 属性初始值、最终值，在每帧更新时调用set方法设置当前时刻的 属性值。随着时间推移，set的属性值会接近最终值，从而达到动画效果。如果没传入初始值，那么对象还要有get方法，用于获取初始值。</p>
<p><strong>在获取初始值、set属性值时，都是使用  反射  的方式，进行 get、set方法的调用。</strong> 见PropertyValuesHolder的setupValue、setAnimatedValue方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupValue</span><span class="params">(Object target, Keyframe kf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mProperty != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object value = convertBack(mProperty.get(target));</span><br><span class="line">        kf.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mGetter == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Class targetClass = target.getClass();</span><br><span class="line">                setupGetter(targetClass);</span><br><span class="line">                <span class="keyword">if</span> (mGetter == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Already logged the error - just return to avoid NPE</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Object value = convertBack(mGetter.invoke(target));</span><br><span class="line">            kf.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;PropertyValuesHolder&quot;</span>, e.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;PropertyValuesHolder&quot;</span>, e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAnimatedValue</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mProperty != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mProperty.set(target, getAnimatedValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mSetter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mTmpValueArray[<span class="number">0</span>] = getAnimatedValue();</span><br><span class="line">            mSetter.invoke(target, mTmpValueArray);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;PropertyValuesHolder&quot;</span>, e.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;PropertyValuesHolder&quot;</span>, e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上效果图：</p>
<p><img src="/2023/10/26/Animation/17121317607bf110~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<h3 id="使用动画的注意事项"><a href="#使用动画的注意事项" class="headerlink" title="使用动画的注意事项"></a>使用动画的注意事项</h3><ol>
<li><p>使用帧动画，避免OOM。因为图片多。</p>
</li>
<li><p>属性动画 如果有循环动画，在页面退出时要及时停止，避免内存泄漏。</p>
</li>
<li><p>使用View动画后，调用setVisibility(View.GONE)失效时，使用view.clearAnimation()可解决。</p>
</li>
<li><p>属性动画，可能会由于View属性变化导致频繁触发重新measure layout，注意性能</p>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-10-10T07:40:35.000Z" title="10/10/2023, 3:40:35 PM">2023-10-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.376Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a><span> / </span><a class="link-muted" href="/categories/Android/AAC/">AAC</a></span><span class="level-item">a few seconds read (About 1 word)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/10/Lifecycle/">Lifecycle</a></h1><div class="content"><span id="more"></span>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-10-10T07:40:13.000Z" title="10/10/2023, 3:40:13 PM">2023-10-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-12-10T07:10:22.424Z" title="12/10/2024, 3:10:22 PM">2024-12-10</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a><span> / </span><a class="link-muted" href="/categories/Android/AAC/">AAC</a></span><span class="level-item">17 minutes read (About 2543 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/10/ViewModel/">ViewModel</a></h1><div class="content"><p><strong>ViewModel的原理是系统配置更改情况下在onDestroy时Actvitity中保存ViewModel的viewModelStore并不会被销毁（非配置更改的情况会销毁viewModelStore）。重建后在获取ViewModel时会根据传入的类全限定名从ViewModelStore中取；</strong></p>
<p><strong>上述并不能针对内存不足而Activity被回收的情况下生效，针对内存不足回收activity的情况，需要手动在onSaveInstanceState中存</strong>储</p>
<p><strong>之后手动在onRestoreInstanceState中取，或者是使用SavedStateHandle封装了这个过程</strong></p>
<p>简述：<code>fragment</code>或<code>componentActivity</code>实现了<code>ViewModelStoreOwner</code>接口，实现该接口方法<code>getViewModelStore()</code>，当调用<code>ViewModelProvider(ViewModelStoreOwner owner).get(Class&lt;T&gt; modelClass)</code>时，会使用工厂模式创建<code>viewModel</code>，之后将其以<code>canonicalName（全限定名）</code>为key存入<code>mViewModelStore</code>中，<code>ViewModelStore</code>内部是个<code>HashMap&lt;String, ViewModel&gt;</code>。</p>
<p>当屏幕旋转或切换系统语言等配置修改的行为发生时，<code>Activity</code> 生命周期从销毁再重建，在销毁时（配置修改），如果判断系统配置没有变化（即<code>!isChangingConfigurations</code>）清空保存的<code>ViewModel</code>（即<code> getViewModelStore().clear();</code>）</p>
<p>如果发生变化则调用<code>onRetainNonConfigurationInstance()</code> 方法将 <code>viewModelStore</code> 保存起来，当Activity重建时则从<code>getLastNonConfigurationInstance()</code>中获取保存的<code>mViewModelStore</code></p>
<p>ps：如果ViewModelProvider传入Activity，则取得是Activity的ViewModelStore，如果传入了fragment，则根据以下代码取ViewModelStore，即先取父fragment的FragmentManager的ViewModelStore，再取hostActivty的ViewModelStore，最后才是新建一个。</p></div><a class="article-more button is-small is-size-7" href="/2023/10/10/ViewModel/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-08-17T03:31:21.000Z" title="8/17/2023, 11:31:21 AM">2023-08-17</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.005Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">14 minutes read (About 2097 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/08/17/Design-Pattrens/">Design Pattrens</a></h1><div class="content"><h1 id="设计模式的六个原则"><a href="#设计模式的六个原则" class="headerlink" title="设计模式的六个原则"></a>设计模式的六个原则</h1><ol>
<li>单一原则<br>每个类或方法都应该只被一个原因影响</li>
<li>开闭原则<br>类或方法应该对扩展开放, 对修改封闭</li>
<li>里氏替换原则<br>子类出现的地方一定可以被父类替换</li>
<li>接口隔离原则<br>接口的粒度要尽量的小</li>
<li>依赖倒置原则<br>抽象依赖抽象, 具体依赖抽象</li>
<li>迪米特原则<br>尽量无知, 朋友的朋友不是我的朋友</li>
</ol></div><a class="article-more button is-small is-size-7" href="/2023/08/17/Design-Pattrens/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-07-12T09:00:29.000Z" title="7/12/2023, 5:00:29 PM">2023-07-12</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-04-24T09:35:45.497Z" title="4/24/2024, 5:35:45 PM">2024-04-24</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">5 minutes read (About 767 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/07/12/BIDI-%E7%AE%97%E6%B3%95/">bidi 算法</a></h1><div class="content"><h2 id="逻辑顺序与视觉顺序"><a href="#逻辑顺序与视觉顺序" class="headerlink" title="逻辑顺序与视觉顺序"></a><strong>逻辑顺序与视觉顺序</strong></h2><p>[I] 逻辑顺序：指人们阅读和从键盘上输入的文字顺序，文本在内存里也是以逻辑顺序存储的。<br>[II] 视觉顺序：则是文本在屏幕或是打印机中显示的顺序。</p>
<h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><p><strong>[I] 阿拉伯文、希伯来文及其派生语言的本土字符为“强RTL字符”</strong><br><strong>[II] 我们通常见到的中文、英文等语言的本土字符为“强LTR字符”</strong><br><strong>[III] 欧洲数字、东方阿拉伯，数字，逗号，冒号，句号（即小数点）等为“弱字符”</strong><br><strong>[IV] 括号，中括号，尖括号，空格符，大多数标点符号为“中性字符”</strong></p>
<p><img src="/2023/07/12/BIDI-%E7%AE%97%E6%B3%95/image-20230818153319225.png" alt="image-20230818153319225"></p></div><a class="article-more button is-small is-size-7" href="/2023/07/12/BIDI-%E7%AE%97%E6%B3%95/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-03-16T07:49:00.000Z" title="3/16/2023, 3:49:00 PM">2023-03-16</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.272Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">a few seconds read (About 0 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/03/16/InputMangerService/">InputMangerService</a></h1><div class="content"></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-03-14T03:05:17.000Z" title="3/14/2023, 11:05:17 AM">2023-03-14</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.414Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">4 minutes read (About 664 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/03/14/Tools/">Tools</a></h1><div class="content"><h3 id="AOSP"><a href="#AOSP" class="headerlink" title="AOSP"></a>AOSP</h3><p>Android 代码搜索 ( <a target="_blank" rel="noopener" href="https://cs.android.com/?hl=zh-cn">cs.android.com</a> ) </p>
<p><a target="_blank" rel="noopener" href="https://developers.google.com/code-search?hl=zh-cn">代码搜索文档</a>。</p>
<h3 id="ClipBoard"><a href="#ClipBoard" class="headerlink" title="ClipBoard"></a>ClipBoard</h3><p>Download the <a target="_blank" rel="noopener" href="https://github.com/majido/clipper/releases/download/v1.2.1/clipper.apk">application apk</a> and manually install application on your android device.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># am broadcast -a clipper.set -e text &quot;this can be pasted now&quot;</span><br><span class="line"># am broadcast -a clipper.get</span><br></pre></td></tr></table></figure>





<h3 id="BookMark"><a href="#BookMark" class="headerlink" title="BookMark"></a>BookMark</h3><p><a target="_blank" rel="noopener" href="https://www.processon.com/apps/6239af581e085306f8cba701">ProcessOn</a></p>
<p><a target="_blank" rel="noopener" href="https://write.youdao.com/edit/#/index?from=index_top">语法</a></p>
<p><a target="_blank" rel="noopener" href="https://apilevels.com/">API Levels | Android versions, SDK/API levels, version codes, codenames, and cumulative usage</a></p>
<p><a target="_blank" rel="noopener" href="https://www.qrcode-monkey.com/">QRCode生成</a></p>
<p><a target="_blank" rel="noopener" href="http://gityuan.com/2016/01/02/memory-analysis-command/">Android内存分析命令 - Gityuan博客 | 袁辉辉的技术博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.myfixguide.com/color-converter/">Color Converter - RGB, HEX, HSL, ARGB, RGBA</a></p>
<p><a target="_blank" rel="noopener" href="https://www.unixtimestamp.com/">Unix Time Stamp - Epoch Converter</a></p>
<p><a target="_blank" rel="noopener" href="https://time.is/zh/Los_Angeles">Time 洛杉矶: 01:04</a></p>
<p><a target="_blank" rel="noopener" href="https://chat.openai.com/chat">chatGpt-New chat</a></p>
<h3 id="Watching"><a href="#Watching" class="headerlink" title="Watching"></a>Watching</h3><ul>
<li>TechPlatform<a target="_blank" rel="noopener" href="https://deepin-wine.i-m.dev/">软件包列表</a><a target="_blank" rel="noopener" href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站</a><a target="_blank" rel="noopener" href="http://linuxcommand.org/lc3_lts0010.php">Learning the shell - Lesson 1: What is the shell?</a><a target="_blank" rel="noopener" href="https://juejin.cn/team/6930545192860647431/posts">字节跳动技术团队 的团队主页</a><a target="_blank" rel="noopener" href="https://www.infoq.cn/">InfoQ - 促进软件开发及相关领域知识与创新的传播-极客邦</a><a target="_blank" rel="noopener" href="https://time.geekbang.org/">极客时间-轻松学习，高效学习-极客邦</a></li>
<li><a target="_blank" rel="noopener" href="http://gityuan.com/2017/01/01/input-anr/">Input系统—ANR原理分析 - Gityuan博客 | 袁辉辉的技术博客</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/fWoXprt2TFL1tTapt7esYg">微信Android客户端的ANR监控方案</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ApNSEWxQdM19QoCNijagtg">今日头条 ANR 优化实践系列 - 设计原理及影响因素</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huansky/p/14954020.html">深入理解 Android ANR 触发原理以及信息收集过程 - huansky - 博客园</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7062552765117136903">一文读懂直播卡顿优化那些事儿 - 掘金</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7072198840035573790">一文读懂 Android FFmpeg 视频解码过程与实战分析 - 掘金</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7052625610295738382">btrace 开源！基于 Systrace 高性能 Trace 工具 - 掘金</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1821336">深入剖析虚拟内存工作原理 - 云+社区 - 腾讯云</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6874916707543187463">OutOfMemoryError 可以被 try catch 吗？ - 掘金</a></li>
<li><a target="_blank" rel="noopener" href="https://ata.alibaba-inc.com/articles/249046">Android高性能高稳定性代码覆盖率方案探索实践 - ATA</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1xy4y1K71K/?buvid=XY2DD82264BAE13B4DF90BC5EA9D8E57584EE&is_story_h5=false&mid=in/X7XJiuX641FpfUXYHvw==&p=1&plat_id=114&share_from=ugc&share_medium=android&share_plat=android&share_session_id=06adf935-8599-4e31-b1fc-22e0bc2c2cbb&share_source=COPY&share_tag=s_i&timestamp=1675050106&unique_k=nI06Mby&up_id=1902539924">word list 1_哔哩哔哩_bilibili</a></li>
<li><a target="_blank" rel="noopener" href="https://source.android.com/source/code-style?hl=zh-cn#follow-field-naming-conventions">面向贡献者的 AOSP 代码样式指南  | Android 开源项目  | Android Open Source Project</a></li>
</ul>
<h3 id="Doc"><a href="#Doc" class="headerlink" title="Doc"></a>Doc</h3><h3 id="doc"><a href="#doc" class="headerlink" title="doc"></a>doc</h3><ul>
<li><a target="_blank" rel="noopener" href="https://shimo.im/docs/gXqmezbm8piQZWqo">Articles</a></li>
<li><a target="_blank" rel="noopener" href="https://shimo.im/docs/WlArzKMYxlFvJ7A2">technology</a></li>
<li><a target="_blank" rel="noopener" href="https://shimo.im/docs/2wAlXDBwrMSGONAP">Other</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-03-06T07:19:06.000Z" title="3/6/2023, 3:19:06 PM">2023-03-06</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-12-10T08:14:25.675Z" title="12/10/2024, 4:14:25 PM">2024-12-10</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">19 minutes read (About 2793 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/03/06/CustomView/">CustomView</a></h1><div class="content"><img src="/2023/03/06/CustomView/image-20230306192616454.png" alt="image-20230306192616454" style="zoom:33%;"></div><a class="article-more button is-small is-size-7" href="/2023/03/06/CustomView/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-02-22T03:46:25.000Z" title="2/22/2023, 11:46:25 AM">2023-02-22</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.434Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">2 minutes read (About 247 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/02/22/bash-profile/">.bash_profile</a></h1><div class="content"><p>#jdk<br>#jdk-11.0.12.jdk or jdk1.8.0_291.jdk<br>export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_291.jdk/Contents/Home<br>#export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-11.0.12.jdk/Contents/Home<br>export PATH=$JAVA_HOME/bin:$PATH<br>export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar<br>#android sdk<br>export ANDROID_HOME=/Users/crow/Library/Android/sdk<br>export PATH=${PATH}:${ANDROID_HOME}/tools<br>export PATH=${PATH}:${ANDROID_HOME}/platform-tools<br>#android ndk<br>export ANDROID_NDK_HOME=/Users/crow/Library/Android/sdk/ndk-bundle<br>export PATH=$PATH:$ANDROID_NDK_HOME</p>
<p>#alias<br>#screen shot phone<br>alias ss=’adb shell screencap /sdcard/screenshot.png &amp;&amp; adb pull /sdcard/screenshot.png . &amp;&amp; open ./screenshot.png’<br>alias screenShot=’adb shell screencap /sdcard/screenshot.png &amp;&amp; adb pull /sdcard/screenshot.png . &amp;&amp; open ./screenshot.png’</p>
<p>#screen record<br>alias sr=’adb shell screenrecord /sdcard/video.mp4’<br>alias startRecord=’adb shell screenrecord /sdcard/video.mp4’<br>#control + c to stop<br>alias showRecord=’adb pull /sdcard/video.mp4 . &amp;&amp; open ./video.mp4’</p>
<p>#adb input text to phone<br>myinput() { adb shell input text “$1” }<br>alias input=’myinput ‘</p>
<p>#adb stop/start app<br>alias stopApp=’adb shell am force-stop com.alibaba.aliexpresshd’<br>alias startApp=’adb shell am start “com.alibaba.aliexpresshd/com.alibaba.aliexpresshd.home.ui.MainActivity”‘</p>
<p>#adb debug app<br>alias debugApp=’adb shell am start -D “com.alibaba.aliexpresshd/com.alibaba.aliexpresshd.home.ui.MainActivity”‘</p>
<p>#gradle<br>dependencies() { ./gradlew “$1”:dependencies –configuration debugRuntimeClasspath }<br>alias depen=’dependencies’</p>
<p>#incremental command<br>alias increment=’bash &lt;(curl -s <a target="_blank" rel="noopener" href="https://gitlab.alibaba-inc.com/chenzhong.cz/incremental_scripts/raw/dev_parallel_aliexpress_mtl4/incremental.sh)&#39;">https://gitlab.alibaba-inc.com/chenzhong.cz/incremental_scripts/raw/dev_parallel_aliexpress_mtl4/incremental.sh)&#39;</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-08-10T07:25:27.000Z" title="8/10/2022, 3:25:27 PM">2022-08-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.414Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">a few seconds read (About 0 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/08/10/Throwable/">Throwable</a></h1><div class="content"></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-08-08T09:14:02.000Z" title="8/8/2022, 5:14:02 PM">2022-08-08</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:02.929Z" title="3/25/2024, 3:35:02 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a><span> / </span><a class="link-muted" href="/categories/Android/Framework/">Framework</a></span><span class="level-item">34 minutes read (About 5028 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/08/08/Binder/">Binder</a></h1><div class="content"><p>为什么是Binder</p>
<p><img src="/2022/08/08/Binder/v2-30dce36be4e6617596b5fab96ef904c6_1440w.jpg" alt="img"></p>
<p>具体见QA。</p>
<p>一次完整的 Binder IPC 通信过程通常是这样：</p>
<ol>
<li></li>
</ol>
<p>其内存流向是这样的：</p>
<ol>
<li>首先 Binder 驱动在内核空间创建一个数据接收缓存区；</li>
<li>接着在内核空间开辟一块内核缓存区，建立<strong>内核缓存区</strong>和<strong>内核中数据接收缓存区</strong>之间的映射关系，以及<strong>内核中数据接收缓存区</strong>和<strong>接收进程用户空间地址</strong>的映射关系；</li>
<li>发送方进程通过系统调用 copy_from_user() 将数据 copy 到内核中的<strong>内核缓存区</strong>，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。</li>
</ol>
<p>如下图：</p>
<p><img src="/2022/08/08/Binder/nzNJUA.png" alt="nzNJUA.png"></p></div><a class="article-more button is-small is-size-7" href="/2022/08/08/Binder/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-07-26T03:36:06.000Z" title="7/26/2022, 11:36:06 AM">2022-07-26</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.218Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">9 minutes read (About 1303 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/26/Git/">Git</a></h1><div class="content"><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p><strong>Q：每次commit，Git储存的是全新的文件快照还是储存文件的变更部分？</strong></p>
<p><strong>A: 全新的文件快照</strong></p>
<p>Git储存的是全新的文件快照，而不是文件的变更记录。也就是说，就算你只是在文件中添加一行，Git也会新建一个全新的blob object。那这样子是不是很浪费空间呢?</p>
<p>这其实是Git在空间和时间上的一个取舍，思考一下你要checkout一个commit，或对比两个commit之间的差异。如果Git储存的是问卷的变更部分，那么为了拿到一个commit的内容，Git都只能从第一个commit开始，然后一直计算变更，直到目标commit，这会花费很长时间。而相反，Git采用的储存全新文件快照的方法能使这个操作变得很快，直接从快照里面拿取内容就行了。</p>
<p>当然，在涉及网络传输或者Git仓库真的体积很大的时候，Git会有垃圾回收机制gc，不仅会清除无用的object，还会把已有的相似object打包压缩。</p></div><a class="article-more button is-small is-size-7" href="/2022/07/26/Git/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-07-05T11:28:18.000Z" title="7/5/2022, 7:28:18 PM">2022-07-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.056Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">3 hours read (About 27678 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/05/Full-QA/">Full-QA</a></h1><div class="content"><h1 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h1><h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a><strong>TCP三次握手</strong></h3><p> <strong>三次握手过程：</strong></p>
<p> 客户端——发送带有SYN标志的数据包——服务端 <strong>一次握手</strong> Client进入syn_sent状态</p>
<p> 服务端——发送带有SYN/ACK标志的数据包——客户端 <strong>二次握手</strong> 服务端进入syn_rcvd</p>
<p> 客户端——发送带有ACK标志的数据包——服务端 <strong>三次握手</strong> 连接就进入Established状态</p></div><a class="article-more button is-small is-size-7" href="/2022/07/05/Full-QA/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-03-16T08:02:24.000Z" title="3/16/2022, 4:02:24 PM">2022-03-16</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.410Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">4 minutes read (About 614 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/03/16/TaskPerFrame/">TaskPerFrame</a></h1><div class="content"><h3 id="16ms-内都需要完成什么？"><a href="#16ms-内都需要完成什么？" class="headerlink" title="16ms 内都需要完成什么？"></a><strong>16ms 内都需要完成什么</strong>？</h3><p>from :  <a target="_blank" rel="noopener" href="https://juejin.cn/post/7062552765117136903">https://juejin.cn/post/7062552765117136903</a></p>
<p><img src="/2022/03/16/TaskPerFrame/039f2506191a4c738fba6fb40545123e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="图片"></p>
<h4 id="Vsync顶层"><a href="#Vsync顶层" class="headerlink" title="// Vsync顶层"></a>// Vsync顶层</h4><ol>
<li><p><strong>Vsync 调度</strong>：硬件每隔16.6ms发出硬件Vsync信号，需要经过软件调度，类似注册，才能收到回调</p>
</li>
<li><p><strong>消息调度</strong>：主要是 doframe 的消息调度，如果消息被阻塞，会直接造成卡顿；</p>
</li>
<li><p><strong>input 处理</strong>：触摸事件的处理；</p>
</li>
<li><p><strong>动画处理</strong>：animator 动画执行和渲染；</p>
</li>
<li><p><strong>view 处理</strong>：主要是 view 相关的遍历和三大流程；</p>
</li>
<li><p><strong>measure、layout、draw</strong>：view 三大流程的执行；</p>
<h4 id="Vsync底层"><a href="#Vsync底层" class="headerlink" title="//Vsync底层"></a>//Vsync底层</h4></li>
<li><p><strong>DisplayList 更新</strong>：view 硬件加速后的 draw op；</p>
</li>
<li><p><strong>OpenGL 指令转换</strong>：canvas指令转换为 OpenGL 指令；</p>
</li>
<li><p><strong>指令 buffer 交换</strong>：OpenGL 的指令交换到 GPU 内部执行；</p>
</li>
<li><p><strong>GPU 处理</strong>：GPU 对数据的处理过程；</p>
</li>
<li><p><strong>layer 合成</strong>：surface buffer 合成屏幕显示 buffer 的流程；</p>
</li>
<li><p><strong>光栅化</strong>：将矢量图转换为位图；</p>
</li>
<li><p><strong>Display</strong>：显示控制；</p>
</li>
<li><p><strong>buffer 切换</strong>：切换屏幕显示的帧 buffer；</p></li></ol></div><a class="article-more button is-small is-size-7" href="/2022/03/16/TaskPerFrame/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-03-10T08:16:46.000Z" title="3/10/2022, 4:16:46 PM">2022-03-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-07-04T06:15:34.931Z" title="7/4/2024, 2:15:34 PM">2024-07-04</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">33 minutes read (About 4951 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/03/10/RenderBlock/">RenderBlock</a></h1><div class="content"><p>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7062552765117136903">https://juejin.cn/post/7062552765117136903</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/topic/performance/rendering/profile-gpu?hl=zh-cn">https://developer.android.com/topic/performance/rendering/profile-gpu?hl=zh-cn</a></p>
<h3 id="RenderThread的作用："><a href="#RenderThread的作用：" class="headerlink" title="RenderThread的作用："></a>RenderThread的作用：</h3><p>主线程的 draw 函数并没有真正的执行 drawCall ，而是把要 draw 的内容记录到 DIsplayList 里面（在 Measure、Layout、Draw 的 Draw 这个环节，Android 使用 DisplayList 进行绘制而非直接使用 CPU 绘制每一帧。），同步到 RenderThread 中，一旦同步完成，主线程就可以被释放出来做其他的事情，RenderThread 则继续进行渲染工作<br><img src="https://github.com/WhileCrow/BlackCrow/assets/26061465/174fcbc3-c736-45c7-8613-c73bbb81cd7f" alt="image"></p>
<h3 id="2-3-生产者和消费者"><a href="#2-3-生产者和消费者" class="headerlink" title="2.3 生产者和消费者"></a>2.3 生产者和消费者</h3><p><img src="/2022/03/10/RenderBlock/e76602c2c7b34d7ba98b8cdf8719445a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="图片"></p>
<p>我们再回到 Vsync 的话题，消费 Vsync 的双方分别是 App 和 sf，<strong>其中 App 代表的是生产者，sf 代表的是消费者，两者交付的中间产物则是 surface buffer</strong>。</p>
<p><strong>再具体一点，生产者大致可以分为两类，一类是以 window 为代表的页面，也就是我们平时所看到的 view 树这一套；另一类是以视频流为代表的可以直接和 surface 完成数据交换的来源，比如相机预览等。</strong></p>
<p>对于一般的生产者和消费者模式，我们知道会存在<strong>相互阻塞</strong>的问题。比如生产者速度快但是消费者速度慢，亦或是生产者速度慢消费者速度快，都会导致整体速度慢且造成资源浪费。所以 Vsync 的协同以及双缓冲甚至三缓冲的作用就体现出来了。</p>
<blockquote>
<p>思考一个问题：是否缓冲的个数越多越好？过多的缓冲会造成什么问题？</p>
<p> 答案是会造成另一个严重的问题：lag，响应延迟</p>
</blockquote>
<p>这里结合 view 的一生，我们可以把两个流程合在一起，让我们的视角再高一层：</p>
<p><img src="/2022/03/10/RenderBlock/52a7e6f5fd734b1db159b76a0b21d3ba~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="图片"></p>
<p>我们一般都比较了解 view 渲染的三大流程，但是 view 的渲染远不止于此：</p>
<blockquote>
<p>此处以一个通用的硬件加速流程来表征</p>
</blockquote>
<p><img src="/2022/03/10/RenderBlock/039f2506191a4c738fba6fb40545123e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="图片"></p>
<ol>
<li><strong>Vsync 调度</strong>：很多同学的一个认知误区在于认为 vsync 是每 16ms 都会有的，但是其实 vsync 是需要调度的，没有调度就不会有回调；</li>
<li><strong>消息调度</strong>：主要是 doframe 的消息调度，如果消息被阻塞，会直接造成卡顿；</li>
<li><strong>input 处理</strong>：触摸事件的处理；</li>
<li><strong>动画处理</strong>：animator 动画执行和渲染；</li>
<li><strong>view 处理</strong>：主要是 view 相关的遍历和三大流程；</li>
<li><strong>measure、layout、draw</strong>：view 三大流程的执行；</li>
<li><strong>DisplayList 更新</strong>：view 硬件加速后的 draw op；</li>
<li><strong>OpenGL 指令转换</strong>：绘制指令转换为 OpenGL 指令；</li>
<li><strong>指令 buffer 交换</strong>：OpenGL 的指令交换到 GPU 内部执行；</li>
<li><strong>GPU 处理</strong>：GPU 对数据的处理过程；</li>
<li><strong>layer 合成</strong>：surface buffer 合成屏幕显示 buffer 的流程；</li>
<li><strong>光栅化</strong>：将矢量图转换为位图；</li>
<li><strong>Display</strong>：显示控制；</li>
<li><strong>buffer 切换</strong>：切换屏幕显示的帧 buffer；</li>
</ol></div><a class="article-more button is-small is-size-7" href="/2022/03/10/RenderBlock/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-02-24T09:33:41.000Z" title="2/24/2022, 5:33:41 PM">2022-02-24</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-12-10T06:07:49.161Z" title="12/10/2024, 2:07:49 PM">2024-12-10</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a><span> / </span><a class="link-muted" href="/categories/Android/AAC/">AAC</a></span><span class="level-item">28 minutes read (About 4186 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/02/24/LiveData/">LiveData</a></h1><div class="content"><p>简述：</p>
<p><strong>liveData持有一个版本，observer持有一个版本，当livedata.setValue时，如果observer的版本低于livedata版本并且observer是活跃状态时，observer的onchange才会被调用</strong></p>
<p><strong>另外lifeCycleOwner在切换到活跃态时会给observer发送最新数据，以及在切换到DESTROYED时会移除observer</strong></p>
<p><strong>还有就是粘性数据</strong></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/593472898">https://zhuanlan.zhihu.com/p/593472898</a></p>
<h2 id="Featrue"><a href="#Featrue" class="headerlink" title="Featrue"></a>Featrue</h2><ul>
<li><p><strong>UI和实时数据保持一致</strong> 因为LiveData采用的是观察者模式，这样一来就可以在数据发生改变时获得通知，更新UI。</p>
</li>
<li><p><strong>避免内存泄漏</strong> 观察者被绑定到组件的生命周期上，当被绑定的组件销毁（destroy）时，观察者会立刻自动清理自身的数据。</p>
</li>
<li><p><strong>不会再产生由于Activity处于stop状态而引起的崩溃</strong>，例如：当Activity处于后台状态时，是不会收到LiveData的任何事件的。</p>
</li>
<li><p><strong>不需要再解决生命周期带来的问题</strong> LiveData可以感知被绑定的组件的生命周期，只有在活跃状态才会通知数据变化。</p>
</li>
<li><p><strong>实时数据刷新</strong> 当组件处于活跃状态或者从不活跃状态到活跃状态时总是能收到最新的数据。</p>
</li>
<li><p><strong>解决Configuration Change问题</strong> 在屏幕发生旋转或者被回收再次启动，立刻就能收到最新的数据。</p></li></ul></div><a class="article-more button is-small is-size-7" href="/2022/02/24/LiveData/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-02-16T09:12:36.000Z" title="2/16/2022, 5:12:36 PM">2022-02-16</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.380Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">5 minutes read (About 679 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/02/16/Mmap/">Mmap</a></h1><div class="content"><h1 id="Binder-内存拷贝的本质和变迁"><a href="#Binder-内存拷贝的本质和变迁" class="headerlink" title="Binder | 内存拷贝的本质和变迁"></a>Binder | 内存拷贝的本质和变迁</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/user/149189312913511/posts">芦半山</a></p>
<h3 id="虚拟地址和数据的关系"><a href="#虚拟地址和数据的关系" class="headerlink" title="虚拟地址和数据的关系"></a>虚拟地址和数据的关系</h3><p>所有的数据都存储在物理内存中，而进程访问内存只能通过虚拟地址。因此，若是想成功访问必须得有个前提：</p>
<blockquote>
<p>虚拟地址和物理内存之间建立映射关系</p>
</blockquote>
<p>若是这层映射关系不建立，则访问会出错。信号11(SIGSEGV)的MAPERR就是专门用来描述这种错误的。</p>
<p>虚拟地址和物理地址间建立映射关系通过mmap完成。这里我们不考虑file-back的mapping，只考虑anonymous mapping。当mmap被调用(flag=MAP_ANONYMOUS)时，实际上会做以下两件事：</p>
<ol>
<li>分配一块连续的虚拟地址空间。</li>
<li>更新这些虚拟地址对应的PTE(Page Table Entry)。</li>
</ol>
<p>mmap做完这两件事后，就会返回连续虚拟地址空间的起始地址。在mmap调用结束后，其实并不会立即分配物理页。如果此时不分配物理页，那么就会有如下两个问题：</p>
<ol>
<li>没有新的物理页分配，那么PTE都更新了哪些内容？</li>
<li>如果后续使用mmap返回的虚拟地址访问内存，会有什么情况产生呢？</li>
</ol>
<h4 id="1-1-1-没有新的物理页分配，那么PTE都更新了些什么内容呢？"><a href="#1-1-1-没有新的物理页分配，那么PTE都更新了些什么内容呢？" class="headerlink" title="1.1.1 没有新的物理页分配，那么PTE都更新了些什么内容呢？"></a>1.1.1 没有新的物理页分配，那么PTE都更新了些什么内容呢？</h4><p>PTE也即页表的条目，它的内容反映了一个虚拟地址到物理地址之间的映射关系。如果没有新的物理页分配，那这些新的虚拟地址都和哪些物理地址之间建立了映射关系呢？答案是所有的虚拟地址都和同一个zero page（页内容全为0）建立了映射关系。</p>
<h4 id="1-1-2-如果后续使用mmap返回的虚拟地址访问内存，会有什么情况产生呢？"><a href="#1-1-2-如果后续使用mmap返回的虚拟地址访问内存，会有什么情况产生呢？" class="headerlink" title="1.1.2 如果后续使用mmap返回的虚拟地址访问内存，会有什么情况产生呢？"></a>1.1.2 如果后续使用mmap返回的虚拟地址访问内存，会有什么情况产生呢？</h4><p>拿到mmap返回的虚拟地址后，并不会有新的物理页分配。此时若是直接读取虚拟地址中的值，则会通过PTE追踪到刚刚建立映射关系的zero page，因此读取出来的值都是0。</p>
<p>如果此时往虚拟地址中写入数据，将会在page fault handler中触发一个正常的copy-on-write机制。需要写多少页，就会新分配多少物理页。所以我们可以看到，真实的物理页是符合lazy(on-demand) allocation原则的。这一点，极大地保证了物理资源的合理分配和使用。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-02-16T08:45:30.000Z" title="2/16/2022, 4:45:30 PM">2022-02-16</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.380Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a><span> / </span><a class="link-muted" href="/categories/Android/Framework/">Framework</a></span><span class="level-item">a minute read (About 127 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/02/16/PackageManager/">PackageManager</a></h1><div class="content"><p><img src="/2022/02/16/PackageManager/4d40d322bc9245f98b676235b5625bc6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp.png" alt="img"></p>
<p>PackageManger的核心作用：</p>
<ol>
<li>在系统启动过程中，通过**PackageManagerService(PKMS)*<em>对特定系统文件(如package.list, package.xml)进行扫描解析后，将所有app的信息整合存储，通过</em>IPackageManger*对外暴露</li>
<li>通过<strong>PackageInstallerService</strong>提供Apk/Apex的安装、更新、卸载等操作(<em>IPackageInstaller</em>)</li>
<li>应用运行过程中的权限检查</li>
</ol></div><a class="article-more button is-small is-size-7" href="/2022/02/16/PackageManager/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-02-16T08:45:15.000Z" title="2/16/2022, 4:45:15 PM">2022-02-16</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.427Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">an hour read (About 8958 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/02/16/Window/">Window</a></h1><div class="content"><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huan89/p/14111360.html">https://www.cnblogs.com/huan89/p/14111360.html</a></p>
<p>从来都没什么Window，有的只是一个个View树，每个窗口(activity/dialog/popupWindow)都是一个view树（代码中都是叫addView，直到WMS中才叫addWindow），在需要显示时被添加进WMS中，最后通过surfalceFlinger合成后渲染到屏幕中。</p>
<p>每个窗口都对应一个Token，一个应用只对应一个session。</p>
<h1 id="从Window视角看ActivityStart"><a href="#从Window视角看ActivityStart" class="headerlink" title="从Window视角看ActivityStart"></a>从Window视角看ActivityStart</h1><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><p>简述：首先回顾一下，activity是怎么显示出来的：</p>
<ol>
<li>为activity创建PhoneWindow和WindowManager(WindowManagerImpl)对象</li>
</ol>
<p>在handleLaunchActivity()被回调的时候，调用<code>WindowManagerGlobal.initialize();</code>初始化WindoWindowManagerGlobal，之后<code>       Application app = r.packageInfo.makeApplication(false, mInstrumentation);</code>创建Application（如果还没有创建过Application），然后调用<code>activity.attach()</code>，这里面<code>   mWindow = new PhoneWindow(this, window, activityConfigCallback);</code>初始化PhoneWindow并给它设置<strong>WindowManager</strong>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);        </span><br></pre></td></tr></table></figure>

<p>Window.setWindowManager()中通过<strong>WMS</strong>创建了WindowManagerImpl（其实就是个一百多行代码的壳）。</p>
<blockquote>
<p>从这里可以看到是利用系统服务的windowManager来创建新的windowManagerImpl，因而这个应用所有的WindowManagerImpl都是同个内核windowManager，而创建出来的仅仅是包了个壳。</p>
</blockquote>
<ol start="2">
<li>setContentView实际上掉的是getWindow()（也就是上面的<strong>PhoneWindow</strong>）的setContentView()，其中调用PhoneWindow.installDecor()，</li>
</ol>
<ul>
<li>首先看decorView创建了没有，没有的话创建DecorView</li>
<li>把布局加载到<strong>DecorView</strong>中（LayoutInflater加载预设模板布局，见下）</li>
</ul>
<blockquote>
<p>DecorView是在PhoneWindow中预设好的一个布局，这个布局长这样：</p>
<p><img src="/2022/02/16/Window/7b50be9e59004b98b23781a7b25330cd~tplv-k3u1fbpfcp-zoom-1.png" alt="decorView"></p>
<p>他是一个垂直排列的布局，上面是ActionBar，下面是ContentView，他是一个FrameLayout。我们的Activity布局就加载到ContentView里进行显示。所以Decorview是Activity布局最顶层的viewGroup。</p>
</blockquote>
<p>// DecorView创建完成了，但还缺少了最重要的一步：<strong>把DecorView</strong>作为window添加到屏幕上。</p>
<ol start="3">
<li><p>在handleResumeActivity中，执行了最后的  <code>wm.addView(mDecor, getWindow().getAttributes());</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest, <span class="keyword">boolean</span> isForward,</span></span></span><br><span class="line"><span class="function"><span class="params">        String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用Activity的onResume方法</span></span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 让decorView显示到屏幕上</span></span><br><span class="line">	<span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">        r.activity.makeVisible();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeVisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mWindowAdded) &#123;</span><br><span class="line">        ViewManager wm = getWindowManager();</span><br><span class="line">        wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">        mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接调用<strong>WindowManagerImpl</strong>的addView方法来吧decorView添加到屏幕上，至此，我们的Activity界面就会显示在屏幕上了。</p>
<p>进一步需要看WindowManagerImpl.addView之后是怎么将View（即Window）添加入屏幕的</p>
<ol start="4">
<li><code>wm.addView(mDecor, getWindow().getAttributes());</code>其中wm是<strong>WindowManagerImpl</strong>实例，<code>WindowManagerImpl.addView</code>其实是通过桥接，调用<strong>WindowManagerGlobal</strong>的全局单例的方法<code>WindowManagerGlobal.addView</code>，该方法中会新建一个<strong>ViewRootImpl</strong>，然后将入参的decorView、新建的ViewRootImp等加入自身维护的mViews、mRoots列表中，同时将DecorView注入ViewRootImpl<code>root.setView(view, wparams, panelParentView)</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">WindowMangerGlobal.clss</span><br><span class="line">维护着WMS实例sWindowManagerService和以下列表</span><br><span class="line"> </span><br><span class="line"><span class="comment">//应用所有的decorView</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;View&gt; mViews = <span class="keyword">new</span> ArrayList&lt;View&gt;();</span><br><span class="line"><span class="comment">//应用所有的ViewRootImpl</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;ViewRootImpl&gt; mRoots = <span class="keyword">new</span> ArrayList&lt;ViewRootImpl&gt;();</span><br><span class="line"><span class="comment">//应用所有的WindowManager.LayoutParams</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;WindowManager.LayoutParams&gt; mParams =</span><br><span class="line">        <span class="keyword">new</span> ArrayList&lt;WindowManager.LayoutParams&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//... 主要是校验参数和调整子窗口的参数</span></span><br><span class="line">	<span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 这里新建了一个viewRootImpl，并设置参数</span></span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加到windowManagerGlobal的三个重要list中，每一个window所对应的这三个对象都会保存在这里，之后对window的一些操作就可以直接来这里取对象了。当window被删除的时候，这些对象也会被从list中移除。</span></span><br><span class="line">        mViews.add(view);</span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后通过viewRootImpl来添加window</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            root.setView(view, wparams, panelParentView);</span><br><span class="line">        &#125; </span><br><span class="line">        ...</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​    5. ViewRootImpl.setView()将调用到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">        getHostVisibility(), mDisplay.getDisplayId(), mWinFrame,</span><br><span class="line">        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">        mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel);</span><br></pre></td></tr></table></figure>

<p>这个mWindowSession来自于构造器的入参，是由WindowManagerGlobal.getWindowSession中来的，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWindowSession <span class="title">getWindowSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">     <span class="keyword">if</span> (sWindowSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             ...</span><br><span class="line">             sWindowSession = windowManager.openSession(</span><br><span class="line">                     <span class="keyword">new</span> IWindowSessionCallback.Stub() &#123;</span><br><span class="line">                         ...</span><br><span class="line">                     &#125;);</span><br><span class="line">         &#125; </span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> sWindowSession;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，这个session是一个单例，也就是<strong>整个应用的所有viewRootImpl的windowSession都是同一个，也就是一个应用只有一个windowSession</strong>。</p>
<p><code>Session.addToDisplay</code>实际上走的是<strong>WMS</strong>的addWindow方法，后面的逻辑就交给WMS去处理了，WMS就会创建window，然后结合参数计算window的高度等等，最后使用viewRootImpl进行绘制。</p>
<blockquote>
<p>window的添加过程是通过PhoneWindow对应的WindowManagerImpl来添加window，内部会调用WindowManagerGlobal来实现。WindowManagerGlobal会使用viewRootImpl来进行跨进程通信让WMS执行创建window的业务。</p>
<p>每个应用都有一个windowSession，用于负责和WMS的通信，如ApplicationThread与AMS的通信。</p>
</blockquote>
<h2 id="Other-Window"><a href="#Other-Window" class="headerlink" title="Other Window"></a>Other Window</h2><p><strong>dialog和popupwindow</strong>的层级是1000<del>1999，在这个层级<strong>都属于子window</strong>而不是应用Window(1</del>99)，<strong>子Window需要附属于父Window</strong>（Activity，也就是应用Window）才能显示，dialog虽然创建了一个PhoneWindow，但是popupWindow最终也创建了一个Window，只是它不是PhoneWindow而已，popupWindow和dialog的显示都需要依赖父Window的Token，其实两者都需要依赖于Activiy</p>
<h3 id="PopupWindow"><a href="#PopupWindow" class="headerlink" title="PopupWindow"></a>PopupWindow</h3><p>那么，PopupWindow则是在构造器中时将入参的contentView直接执行  <code>setContentView(contentView);</code>，然后在<code>showAtLocation（）</code>中调用了<code>preparePopup()</code> 创建它的decorView（PopupDecorView）之后<code>invokePopup()</code>调用执行<code>mWindowManager.addView(decorView, p);</code></p>
<ul>
<li>根据参数构建popupDecorView</li>
<li>把popupDecorView添加到屏幕上</li>
</ul>
<p><code>dismiss()</code>中调用<code>mWindowManager.removeViewImmediate(decorView);</code></p>
<h3 id="Dialog"><a href="#Dialog" class="headerlink" title="Dialog"></a>Dialog</h3><p>dialog的创建过程Activity比较像：构造器创建PhoneWindow，setContentView初始化DecorView，show时候添加DecorView。</p>
<ul>
<li>构造函数中创建PhoneWindow，设置WindowManger（这里拿的是传入的context，实际上这context只能是actiivty，的WindowManager）</li>
<li>Dialog.setContentView时掉PhoneWindow.setContentView来初始化DecorView</li>
<li><code>show()</code>时候调用了<code>mWindowManager.addView(mDecor, l);</code></li>
<li><code>dismiss()</code>时候调用<code>mWindowManager.removeViewImmediate(mDecor);</code></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<ul>
<li>dialog和popupWindow不同，dialog创建了新的PhoneWindow，使用了PhoneWindow的DecorView模板。而popupWindow没有，popupWindow他也对应一个window，因为它也是通过windowManager添加上去的，不属于Activity的view树。</li>
<li>dialog的显示层级数更高，会直接显示在Activity上面，在dialog后添加的popUpWindow也会显示在dialog下</li>
<li>dialog的创建流程和activity非常像</li>
</ul>
</blockquote></div><a class="article-more button is-small is-size-7" href="/2022/02/16/Window/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-01-24T09:18:13.000Z" title="1/24/2022, 5:18:13 PM">2022-01-24</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.376Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">17 minutes read (About 2621 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/01/24/Linux/">Linux</a></h1><div class="content"><h1 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h1><h2 id="什么是-CPU-上下文"><a href="#什么是-CPU-上下文" class="headerlink" title="什么是 CPU 上下文"></a>什么是 CPU 上下文</h2><p>CPU 寄存器和程序计数器就是 CPU 上下文，因为它们都是 CPU 在运行任何任务前，必须的依赖环境。</p>
<ul>
<li>CPU 寄存器是 CPU 内置的容量小、但速度极快的内存。</li>
<li>程序计数器则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。</li>
</ul>
<h2 id="什么是-CPU-上下文切换"><a href="#什么是-CPU-上下文切换" class="headerlink" title="什么是 CPU 上下文切换"></a>什么是 CPU 上下文切换</h2><p>就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p>
<p>而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</p></div><a class="article-more button is-small is-size-7" href="/2022/01/24/Linux/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-01-24T09:14:28.000Z" title="1/24/2022, 5:14:28 PM">2022-01-24</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.231Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">33 minutes read (About 4946 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/01/24/HandlerEpoll/">HandlerEpoll</a></h1><div class="content"><h2 id="Looper的阻塞唤醒"><a href="#Looper的阻塞唤醒" class="headerlink" title="Looper的阻塞唤醒"></a>Looper的阻塞唤醒</h2><p><strong>简述：通过pipe/epoll机制，实现MessageQueue.next的无消息时阻塞，有消息时唤醒，pipe</strong></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>具体来说，当Looper在处理消息时，如果消息队列为空，那么它会调用MessageQueue的next方法来等待新的消息到来，通过Linux内核的epoll机制阻塞线程，等待新的消息到来。在阻塞期间，线程处于睡眠状态，不会占用CPU资源;当新的消息到来时，MessageQueue对象会将消息加入队列，并通知Looper对象，从而唤醒线程并继续执行消息的分发和处理。</p>
<p>epoll机制是Linux内核提供的一种高效的I/O多路复用机制，可以在多个文件描述符上等待，并在其中任何一个文件描述符有事件到达时立即返回，从而实现高效的I/O事件处理。</p>
<p>epoll机制主要分为以下三个步骤：</p>
<ol>
<li>创建epoll句柄：在使用epoll机制之前，首先需要创建一个epoll句柄。这可以通过调用epoll_create函数来完成，它会返回一个整型的文件描述符，可以用于后续的epoll操作。</li>
<li>添加文件描述符到epoll：将需要监听的文件描述符添加到epoll中，可以通过调用epoll_ctl函数来完成。在添加文件描述符时，需要指定文件描述符的类型（例如管道、socket等）、事件类型（例如读事件、写事件等）以及回调函数等信息。</li>
<li>等待事件到达：等待事件到达是epoll机制的核心。可以通过调用epoll_wait函数来等待文件描述符上的事件。该函数会阻塞，直到有文件描述符上有事件到达或者超时时间到达。当有事件到达时，函数会立即返回，返回值为就绪文件描述符的个数，同时将就绪文件描述符的信息填充到一个事件数组中。</li>
</ol>
<p>在处理就绪事件时，可以遍历事件数组，并根据每个事件的类型来进行相应的处理。例如，如果是读事件，可以使用read函数来读取文件描述符上的数据。</p>
<p>总之，通过使用epoll机制，可以高效地处理多个文件描述符上的I/O事件，并及时响应事件的到达。这种机制在Linux系统中得到了广泛的应用，包括网络编程、图形界面等领域。</p></div><a class="article-more button is-small is-size-7" href="/2022/01/24/HandlerEpoll/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-01-12T07:09:17.000Z" title="1/12/2022, 3:09:17 PM">2022-01-12</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.005Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">12 minutes read (About 1804 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/01/12/EventAndNestedScroll/">EventAndNestedScroll</a></h1><div class="content"><h1 id="原理-amp-流程"><a href="#原理-amp-流程" class="headerlink" title="原理&amp;流程"></a>原理&amp;流程</h1><p>一.  <code>ns child</code>会在收到<code>DOWN</code>事件时，找到自己祖上中最近的能与自己匹配的<code>ns parent</code>，与它进行绑定并关闭它的事件拦截机制</p>
<p>二. 然后<code>ns child</code>会在接下来的<code>MOVE</code>事件中判定出用户触发了滑动手势，并把事件流拦截下来给自己消费</p>
<p>三. 消费事件流时，对于每一次<code>MOVE</code>事件增加的滑动距离：</p>
<ol>
<li><code>ns child</code>并不是直接自己消费，而是先把它交给<code>ns parent</code>，让<code>ns parent</code>可以在<code>ns child</code>之前消费滑动<code>dispatch/onNestedPreScroll()</code></li>
<li>如果<code>ns parent</code>没有消费或是没有消费完，<code>ns child</code>再自己消费剩下的滑动<code>dispatchNestedScroll()</code></li>
<li>如果<code>ns child</code>自己还是没有消费完这个滑动，会再把剩下的滑动交给<code>ns parent</code>消费<code>onNestedScroll()</code></li>
<li>最后如果滑动还有剩余，<code>ns child</code>可以做最终的处理<code>dispatchNestedScroll()</code></li>
</ol>
<p>四. 同时在<code>ns child</code>的<code>computeScroll()</code>方法中，<code>ns child</code>也会把自己因为用户<code>fling</code>操作引发的滑动，与上一条中用户滑动屏幕触发的滑动一样，使用「parent -&gt; child -&gt; parent -&gt; child」的顺序进行消费</p></div><a class="article-more button is-small is-size-7" href="/2022/01/12/EventAndNestedScroll/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-01-10T06:35:59.000Z" title="1/10/2022, 2:35:59 PM">2022-01-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-04-22T06:20:58.600Z" title="4/22/2024, 2:20:58 PM">2024-04-22</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">an hour read (About 7080 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/01/10/Java/">Java</a></h1><div class="content"><h1 id="final-amp-finalize"><a href="#final-amp-finalize" class="headerlink" title="final &amp; finalize()"></a>final &amp; finalize()</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>final修饰的类不可被继承，方法不可被覆盖(或者叫重写)，对象不可被更改。</p>
<h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h2><p>finalize()是Object的protected方法，是用来给对象在Gc前<strong>一次</strong>行动的机会：首先，当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。</p>
<ul>
<li><p>System.gc()与System.runFinalization()方法增加了finalize方法执行的机会，但不可盲目依赖它们</p>
</li>
<li><p>Java语言规范并不保证finalize方法会被及时地执行、而且根本不会保证它们会被执行</p>
</li>
<li><p>finalize方法可能会带来性能问题。因为JVM通常在单独的低优先级线程中完成finalize的执行</p>
</li>
<li><p>对象再生问题：finalize方法中，可将待回收对象赋值给GC Roots可达的对象引用，从而达到对象再生的目的</p>
</li>
<li><p>finalize方法至多由GC执行一次(用户当然可以手动调用对象的finalize方法，但并不影响GC对finalize的行为)</p>
</li>
</ul>
<p>简述：finalize()方法会在对象回收前至多被调用一次，一般可以在这里做一次重新挂到GcRoot链上的保活操作，或者像Android6以前安卓在覆盖的finalize()方法中释放native内存一样。</p></div><a class="article-more button is-small is-size-7" href="/2022/01/10/Java/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-01-06T09:45:42.000Z" title="1/6/2022, 5:45:42 PM">2022-01-06</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.001Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">24 minutes read (About 3577 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/01/06/DNS/">DNS</a></h1><div class="content"><p>简述：</p>
<p>浏览器中访问一个<a target="_blank" rel="noopener" href="http://www.baidu.com,首先会访问浏览器缓存,如未命中则进一步访问操作系统缓存,如未命中则访问hosts文件.如未命中,则客户端想本地dns服务器发起递归查询(本地dns会将结果也就是ip直接返回),如本地dns解析服务器未命中,则由本地dns解析服务器向根域名服务器、顶级域名服务器、管理方域名服务器等依次进行迭代查询(每有一个未命中则返回下一个域名服务器地址给本地域名服务器,比如local/">www.baidu.com，首先会访问浏览器缓存，如未命中则进一步访问操作系统缓存，如未命中则访问hosts文件。如未命中，则客户端想本地DNS服务器发起递归查询（本地DNS会将结果也就是ip直接返回），如本地DNS解析服务器未命中，则由本地DNS解析服务器向根域名服务器、顶级域名服务器、管理方域名服务器等依次进行迭代查询（每有一个未命中则返回下一个域名服务器地址给本地域名服务器，比如local</a> dns server向根域名服务器查询未命中，则根域名服务器返回顶级域名服务器地址给local dns server，然后local dns server向收到的这个地址迭代发起查询）</p>
<p>迭代与递归查询区别：客户端向本地dns服务器发起的是递归查询，客户端拿到的ip是由本地dns服务器直接返回；本地dns服务器向外网查询时是用的迭代查询，即向根域名服务器查询未命中返回给本地dns服务器的是下一个域名服务器的地址而非根域名去访问下一个域名服务器返回结果ip。</p>
<p>这里还有一个权威性的问题：如果客户端向本地dns服务器发起递归查询时，本地dns存在缓存，并将结果返回客户端，则该结果不具权威性（即缓存可能已经失效）；反之如果由本地dns服务器解析命中后返回，则具有权威性</p></div><a class="article-more button is-small is-size-7" href="/2022/01/06/DNS/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-12-31T03:51:04.000Z" title="12/31/2021, 11:51:04 AM">2021-12-31</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-05-06T08:42:39.750Z" title="5/6/2024, 4:42:39 PM">2024-05-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">23 minutes read (About 3436 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/12/31/Generics/">Generics</a></h1><div class="content"><h1 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h1><p>简述：</p>
<p>理解的泛型，其实是这样的：假如没有泛型，出现在泛型类型位置的就会是Object类，而程序员在使用该类型的时候再手动将类型强转一下，不仅代码啰嗦、而且有类型不匹配的crash可能。</p>
<p>而java1.5提供泛型同时为了兼容旧版，本质上也是用了Object，只不过<strong>编译器将.java编译成.class时</strong>进行“泛型擦除”时会把泛型类型替代成<strong>Object</strong>或<strong>上限类型</strong>（字节码中就不存在泛型了），再自动地使用处前加上原始类型的强转，之后再加载到JVM中。而在编译期存在的泛型可以借由IDE有效的进行<strong>类型检测</strong>和<strong>可读的扩展</strong>，防止类型不匹配。</p>
<p>//<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28665443/answer/118148143">java伪泛型的设计原因主要为了兼容老版本的java。真泛型并非做不到，而是因为如果用真泛型（即类型保留），老程序都需要修改。</a></p>
<p>//另外泛型类中基础数据类型需要使用Integer、Long等封装类的原因也是因为“擦除后会把泛型类型替代成<strong>Object</strong>或<strong>上限类型</strong>”</p>
<p>而kotlin的泛型是跟java一样的，在编译时会被擦除。但是kotlin提供了新的特性可以保留类型，就是**内联函数+reified(ˈriːɪfʌɪ/)**，泛型实化，可以说是真泛型：内联函数(inline)会把方法体copy到调用处（即不会创建新的虚拟机栈帧），</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> C : Activity&gt;</span> Context.<span class="title">startActivityKtx</span><span class="params">()</span></span> &#123;</span><br><span class="line">    startActivity(Intent(<span class="keyword">this</span>, C::<span class="keyword">class</span>.java))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>协变：①<strong>协变</strong>：<strong>父子关系一致</strong>→<strong>子类也可以作为参数传进来</strong>→java<code>&lt;? extends Entity&gt;</code>→<strong>上界通配符</strong>→kotlin<code>&lt;out Entity&gt;</code></p>
<p>逆变：②<strong>逆变</strong>：<strong>父子关系颠倒</strong>→<strong>父类也可以作为参数传进来</strong>→java<code>&lt;? super Article&gt;</code>→<strong>下界通配符</strong>→kotlin<code>&lt;in Entiry&gt;</code></p>
<p>不变：③不变：只能</p>
<p>无限通配符<code>&lt;?&gt;</code> == java <code>&lt;? extend Object&gt;</code> == kotlin<code>&lt;*&gt;</code> == kotlin<code>&lt;out Any&gt;</code></p></div><a class="article-more button is-small is-size-7" href="/2021/12/31/Generics/#more">Read more</a></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/categories/Android/page/0/">Previous</a></div><div class="pagination-next"><a href="/categories/Android/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/categories/Android/">1</a></li><li><a class="pagination-link" href="/categories/Android/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatarPng.png" alt="White Crow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">White Crow</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">78</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">4</p></a></div></div></nav></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a><p class="is-size-7"><span>&copy; 2024 white crow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://github.com/WhileCrow"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>