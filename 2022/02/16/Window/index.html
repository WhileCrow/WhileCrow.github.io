<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Window - Crow&#039;s Sky</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Crow&#039;s Sky"><meta name="msapplication-TileImage" content="/img/avatarCircle.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Crow&#039;s Sky"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="https:&amp;#x2F;&amp;#x2F;www.cnblogs.com&amp;#x2F;huan89&amp;#x2F;p&amp;#x2F;14111360.html 从来都没什么Window，有的只是一个个View树，每个窗口(activity&amp;#x2F;dialog&amp;#x2F;popupWindow)都是一个view树（代码中都是叫addView，直到WMS中才叫addWindow），在需要显示时被添加进WMS中，最后通过surfalceFlinger合成后渲染到屏幕中。 每个窗口都对"><meta property="og:type" content="blog"><meta property="og:title" content="Window"><meta property="og:url" content="http://example.com/2022/02/16/Window/"><meta property="og:site_name" content="Crow&#039;s Sky"><meta property="og:description" content="https:&amp;#x2F;&amp;#x2F;www.cnblogs.com&amp;#x2F;huan89&amp;#x2F;p&amp;#x2F;14111360.html 从来都没什么Window，有的只是一个个View树，每个窗口(activity&amp;#x2F;dialog&amp;#x2F;popupWindow)都是一个view树（代码中都是叫addView，直到WMS中才叫addWindow），在需要显示时被添加进WMS中，最后通过surfalceFlinger合成后渲染到屏幕中。 每个窗口都对"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/2022/02/16/Window/7b50be9e59004b98b23781a7b25330cd~tplv-k3u1fbpfcp-zoom-1.png"><meta property="og:image" content="http://example.com/2022/02/16/Window/9dd8a0d062074e64bcaeb2725dc64ca8~tplv-k3u1fbpfcp-zoom-1.png"><meta property="og:image" content="http://example.com/2022/02/16/Window/12f7f052abef4e959e72f97c9972b327~tplv-k3u1fbpfcp-zoom-1-20231101160149493.png"><meta property="og:image" content="http://example.com/2022/02/16/Window/768cd62019764d129e24d432792e3638~tplv-k3u1fbpfcp-zoom-1-20231101160149500.png"><meta property="og:image" content="http://example.com/2022/02/16/Window/c5dcbb1f264646539f78652b08ce0fc6~tplv-k3u1fbpfcp-zoom-1-20231101160149494.png"><meta property="og:image" content="http://example.com/2022/02/16/Window/ce6e958a4d7049eea68425b4383052bf~tplv-k3u1fbpfcp-zoom-1-20231101160149508.png"><meta property="og:image" content="http://example.com/2022/02/16/Window/e7a78467a1264f5886e420892981c59c~tplv-k3u1fbpfcp-zoom-1.png"><meta property="og:image" content="https://staticcdn1-5.umiwi.com/epms_ebook/cb91e2b1769009c7192441573bbd902b.jpg?x-oss-process=image/resize,w_1792,m_lfit"><meta property="og:image" content="http://example.com/2022/02/16/Window/resize,w_1792,m_lfit.jpeg"><meta property="og:image" content="http://example.com/2022/02/16/Window/178bc0e274ca4b6c9fe052eb6b4357de~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"><meta property="article:published_time" content="2022-02-16T08:45:15.000Z"><meta property="article:modified_time" content="2024-03-25T07:35:03.427Z"><meta property="article:author" content="White Crow"><meta property="article:tag" content="SystemService"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2022/02/16/Window/7b50be9e59004b98b23781a7b25330cd~tplv-k3u1fbpfcp-zoom-1.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2022/02/16/Window/"},"headline":"Window","image":["http://example.com/2022/02/16/Window/7b50be9e59004b98b23781a7b25330cd~tplv-k3u1fbpfcp-zoom-1.png","http://example.com/2022/02/16/Window/9dd8a0d062074e64bcaeb2725dc64ca8~tplv-k3u1fbpfcp-zoom-1.png","http://example.com/2022/02/16/Window/12f7f052abef4e959e72f97c9972b327~tplv-k3u1fbpfcp-zoom-1-20231101160149493.png","http://example.com/2022/02/16/Window/768cd62019764d129e24d432792e3638~tplv-k3u1fbpfcp-zoom-1-20231101160149500.png","http://example.com/2022/02/16/Window/c5dcbb1f264646539f78652b08ce0fc6~tplv-k3u1fbpfcp-zoom-1-20231101160149494.png","http://example.com/2022/02/16/Window/ce6e958a4d7049eea68425b4383052bf~tplv-k3u1fbpfcp-zoom-1-20231101160149508.png","http://example.com/2022/02/16/Window/e7a78467a1264f5886e420892981c59c~tplv-k3u1fbpfcp-zoom-1.png"],"datePublished":"2022-02-16T08:45:15.000Z","dateModified":"2024-03-25T07:35:03.427Z","author":{"@type":"Person","name":"white crow"},"publisher":{"@type":"Organization","name":"Crow's Sky","logo":{"@type":"ImageObject","url":"http://example.com/img/avatarCircle.png"}},"description":"https:&#x2F;&#x2F;www.cnblogs.com&#x2F;huan89&#x2F;p&#x2F;14111360.html 从来都没什么Window，有的只是一个个View树，每个窗口(activity&#x2F;dialog&#x2F;popupWindow)都是一个view树（代码中都是叫addView，直到WMS中才叫addWindow），在需要显示时被添加进WMS中，最后通过surfalceFlinger合成后渲染到屏幕中。 每个窗口都对"}</script><link rel="canonical" href="http://example.com/2022/02/16/Window/"><link rel="icon" href="/img/avatarCircle.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/WhileCrow"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-10-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-02-16T08:45:15.000Z" title="2/16/2022, 4:45:15 PM">2022-02-16</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.427Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">an hour read (About 8958 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">Window</h1><div class="content"><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huan89/p/14111360.html">https://www.cnblogs.com/huan89/p/14111360.html</a></p>
<p>从来都没什么Window，有的只是一个个View树，每个窗口(activity/dialog/popupWindow)都是一个view树（代码中都是叫addView，直到WMS中才叫addWindow），在需要显示时被添加进WMS中，最后通过surfalceFlinger合成后渲染到屏幕中。</p>
<p>每个窗口都对应一个Token，一个应用只对应一个session。</p>
<h1 id="从Window视角看ActivityStart"><a href="#从Window视角看ActivityStart" class="headerlink" title="从Window视角看ActivityStart"></a>从Window视角看ActivityStart</h1><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><p>简述：首先回顾一下，activity是怎么显示出来的：</p>
<ol>
<li>为activity创建PhoneWindow和WindowManager(WindowManagerImpl)对象</li>
</ol>
<p>在handleLaunchActivity()被回调的时候，调用<code>WindowManagerGlobal.initialize();</code>初始化WindoWindowManagerGlobal，之后<code>       Application app = r.packageInfo.makeApplication(false, mInstrumentation);</code>创建Application（如果还没有创建过Application），然后调用<code>activity.attach()</code>，这里面<code>   mWindow = new PhoneWindow(this, window, activityConfigCallback);</code>初始化PhoneWindow并给它设置<strong>WindowManager</strong>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);        </span><br></pre></td></tr></table></figure>

<p>Window.setWindowManager()中通过<strong>WMS</strong>创建了WindowManagerImpl（其实就是个一百多行代码的壳）。</p>
<blockquote>
<p>从这里可以看到是利用系统服务的windowManager来创建新的windowManagerImpl，因而这个应用所有的WindowManagerImpl都是同个内核windowManager，而创建出来的仅仅是包了个壳。</p>
</blockquote>
<ol start="2">
<li>setContentView实际上掉的是getWindow()（也就是上面的<strong>PhoneWindow</strong>）的setContentView()，其中调用PhoneWindow.installDecor()，</li>
</ol>
<ul>
<li>首先看decorView创建了没有，没有的话创建DecorView</li>
<li>把布局加载到<strong>DecorView</strong>中（LayoutInflater加载预设模板布局，见下）</li>
</ul>
<blockquote>
<p>DecorView是在PhoneWindow中预设好的一个布局，这个布局长这样：</p>
<p><img src="/2022/02/16/Window/7b50be9e59004b98b23781a7b25330cd~tplv-k3u1fbpfcp-zoom-1.png" alt="decorView"></p>
<p>他是一个垂直排列的布局，上面是ActionBar，下面是ContentView，他是一个FrameLayout。我们的Activity布局就加载到ContentView里进行显示。所以Decorview是Activity布局最顶层的viewGroup。</p>
</blockquote>
<p>// DecorView创建完成了，但还缺少了最重要的一步：<strong>把DecorView</strong>作为window添加到屏幕上。</p>
<ol start="3">
<li><p>在handleResumeActivity中，执行了最后的  <code>wm.addView(mDecor, getWindow().getAttributes());</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest, <span class="keyword">boolean</span> isForward,</span></span></span><br><span class="line"><span class="function"><span class="params">        String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用Activity的onResume方法</span></span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 让decorView显示到屏幕上</span></span><br><span class="line">	<span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">        r.activity.makeVisible();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeVisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mWindowAdded) &#123;</span><br><span class="line">        ViewManager wm = getWindowManager();</span><br><span class="line">        wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">        mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接调用<strong>WindowManagerImpl</strong>的addView方法来吧decorView添加到屏幕上，至此，我们的Activity界面就会显示在屏幕上了。</p>
<p>进一步需要看WindowManagerImpl.addView之后是怎么将View（即Window）添加入屏幕的</p>
<ol start="4">
<li><code>wm.addView(mDecor, getWindow().getAttributes());</code>其中wm是<strong>WindowManagerImpl</strong>实例，<code>WindowManagerImpl.addView</code>其实是通过桥接，调用<strong>WindowManagerGlobal</strong>的全局单例的方法<code>WindowManagerGlobal.addView</code>，该方法中会新建一个<strong>ViewRootImpl</strong>，然后将入参的decorView、新建的ViewRootImp等加入自身维护的mViews、mRoots列表中，同时将DecorView注入ViewRootImpl<code>root.setView(view, wparams, panelParentView)</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">WindowMangerGlobal.clss</span><br><span class="line">维护着WMS实例sWindowManagerService和以下列表</span><br><span class="line"> </span><br><span class="line"><span class="comment">//应用所有的decorView</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;View&gt; mViews = <span class="keyword">new</span> ArrayList&lt;View&gt;();</span><br><span class="line"><span class="comment">//应用所有的ViewRootImpl</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;ViewRootImpl&gt; mRoots = <span class="keyword">new</span> ArrayList&lt;ViewRootImpl&gt;();</span><br><span class="line"><span class="comment">//应用所有的WindowManager.LayoutParams</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;WindowManager.LayoutParams&gt; mParams =</span><br><span class="line">        <span class="keyword">new</span> ArrayList&lt;WindowManager.LayoutParams&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//... 主要是校验参数和调整子窗口的参数</span></span><br><span class="line">	<span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 这里新建了一个viewRootImpl，并设置参数</span></span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加到windowManagerGlobal的三个重要list中，每一个window所对应的这三个对象都会保存在这里，之后对window的一些操作就可以直接来这里取对象了。当window被删除的时候，这些对象也会被从list中移除。</span></span><br><span class="line">        mViews.add(view);</span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后通过viewRootImpl来添加window</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            root.setView(view, wparams, panelParentView);</span><br><span class="line">        &#125; </span><br><span class="line">        ...</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​    5. ViewRootImpl.setView()将调用到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">        getHostVisibility(), mDisplay.getDisplayId(), mWinFrame,</span><br><span class="line">        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">        mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel);</span><br></pre></td></tr></table></figure>

<p>这个mWindowSession来自于构造器的入参，是由WindowManagerGlobal.getWindowSession中来的，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWindowSession <span class="title">getWindowSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">     <span class="keyword">if</span> (sWindowSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             ...</span><br><span class="line">             sWindowSession = windowManager.openSession(</span><br><span class="line">                     <span class="keyword">new</span> IWindowSessionCallback.Stub() &#123;</span><br><span class="line">                         ...</span><br><span class="line">                     &#125;);</span><br><span class="line">         &#125; </span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> sWindowSession;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，这个session是一个单例，也就是<strong>整个应用的所有viewRootImpl的windowSession都是同一个，也就是一个应用只有一个windowSession</strong>。</p>
<p><code>Session.addToDisplay</code>实际上走的是<strong>WMS</strong>的addWindow方法，后面的逻辑就交给WMS去处理了，WMS就会创建window，然后结合参数计算window的高度等等，最后使用viewRootImpl进行绘制。</p>
<blockquote>
<p>window的添加过程是通过PhoneWindow对应的WindowManagerImpl来添加window，内部会调用WindowManagerGlobal来实现。WindowManagerGlobal会使用viewRootImpl来进行跨进程通信让WMS执行创建window的业务。</p>
<p>每个应用都有一个windowSession，用于负责和WMS的通信，如ApplicationThread与AMS的通信。</p>
</blockquote>
<h2 id="Other-Window"><a href="#Other-Window" class="headerlink" title="Other Window"></a>Other Window</h2><p><strong>dialog和popupwindow</strong>的层级是1000<del>1999，在这个层级<strong>都属于子window</strong>而不是应用Window(1</del>99)，<strong>子Window需要附属于父Window</strong>（Activity，也就是应用Window）才能显示，dialog虽然创建了一个PhoneWindow，但是popupWindow最终也创建了一个Window，只是它不是PhoneWindow而已，popupWindow和dialog的显示都需要依赖父Window的Token，其实两者都需要依赖于Activiy</p>
<h3 id="PopupWindow"><a href="#PopupWindow" class="headerlink" title="PopupWindow"></a>PopupWindow</h3><p>那么，PopupWindow则是在构造器中时将入参的contentView直接执行  <code>setContentView(contentView);</code>，然后在<code>showAtLocation（）</code>中调用了<code>preparePopup()</code> 创建它的decorView（PopupDecorView）之后<code>invokePopup()</code>调用执行<code>mWindowManager.addView(decorView, p);</code></p>
<ul>
<li>根据参数构建popupDecorView</li>
<li>把popupDecorView添加到屏幕上</li>
</ul>
<p><code>dismiss()</code>中调用<code>mWindowManager.removeViewImmediate(decorView);</code></p>
<h3 id="Dialog"><a href="#Dialog" class="headerlink" title="Dialog"></a>Dialog</h3><p>dialog的创建过程Activity比较像：构造器创建PhoneWindow，setContentView初始化DecorView，show时候添加DecorView。</p>
<ul>
<li>构造函数中创建PhoneWindow，设置WindowManger（这里拿的是传入的context，实际上这context只能是actiivty，的WindowManager）</li>
<li>Dialog.setContentView时掉PhoneWindow.setContentView来初始化DecorView</li>
<li><code>show()</code>时候调用了<code>mWindowManager.addView(mDecor, l);</code></li>
<li><code>dismiss()</code>时候调用<code>mWindowManager.removeViewImmediate(mDecor);</code></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<ul>
<li>dialog和popupWindow不同，dialog创建了新的PhoneWindow，使用了PhoneWindow的DecorView模板。而popupWindow没有，popupWindow他也对应一个window，因为它也是通过windowManager添加上去的，不属于Activity的view树。</li>
<li>dialog的显示层级数更高，会直接显示在Activity上面，在dialog后添加的popUpWindow也会显示在dialog下</li>
<li>dialog的创建流程和activity非常像</li>
</ul>
</blockquote>
<span id="more"></span>





<h1 id="概念梳理-待整理"><a href="#概念梳理-待整理" class="headerlink" title="概念梳理//待整理"></a>概念梳理//待整理</h1><h2 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h2><p>前面的源码流程中涉及到很多的类，这里把相关的类统一分析一下。先看一张图：</p>
<p><img src="/2022/02/16/Window/9dd8a0d062074e64bcaeb2725dc64ca8~tplv-k3u1fbpfcp-zoom-1.png" alt="window内部关键类"></p>
<p>这基本上是我们这篇文章涉及到的所有关键类。</p>
<p>（图中绿色的window并不是一个类，而是表意上的window）</p>
<p>另外ViewRootImpl并不在PhoneWindow中，而是在View.attachInfo中，也被WindowManagerService中持有维护）</p>
<h3 id="window相关"><a href="#window相关" class="headerlink" title="window相关"></a>window相关</h3><p>window的实现类只有一个：PhoneWindow，他继承自Window抽象类。后面我会重点分析他。</p>
<h3 id="WindowManager相关"><a href="#WindowManager相关" class="headerlink" title="WindowManager相关"></a>WindowManager相关</h3><p>顾名思义，windowManager就是window管理类。这一部分的关键类有windowManager，viewManager，windowManagerImpl，windowManagerGlobal。windowManager是一个接口，继承自viewManager。viewManager中包含了我们非常熟悉的三个接口：<code>addView,removeView,updateView</code>。<br>windowManagerImpl和PhoneWindow是成对出现的，前者负责管理后者。WindowManagerImpl是windowManager的实现类，但是他本身并没有真正实现逻辑，而是交给了WindowManagerGlobal。WindowManagerGlobal是全局单例，windowManagerImpl内部使用桥接模式，他是windowManager接口逻辑的真正实现</p>
<h3 id="view相关"><a href="#view相关" class="headerlink" title="view相关"></a>view相关</h3><p>这里有个很关键的类：ViewRootImpl。每个view树都会有一个。当我使用windowManager的addView方法时，就会创建一个ViewRootImpl。ViewRootImpl的作用很关键：</p>
<ul>
<li>负责连接view和window的桥梁事务</li>
<li>负责和WindowManagerService的联系</li>
<li>负责管理和绘制view树</li>
<li>事件的中转站</li>
</ul>
<p>每个window都会有一个ViewRootImpl，viewRootImpl是负责绘制这个view树和window与view的桥梁，每个window都会有一个ViewRootImpl。</p>
<h3 id="WindowManagerService"><a href="#WindowManagerService" class="headerlink" title="WindowManagerService"></a>WindowManagerService</h3><p>这个是window的真正管理者，类似于AMS（ActivityManagerService）管理四大组件。所有的window创建最终都要经过windowManagerService。整个Android的window机制中，WMS绝对是核心，他决定了屏幕所有的window该如何显示如何分发点击事件等等。</p>
<h2 id="从Android架构角度看Window"><a href="#从Android架构角度看Window" class="headerlink" title="从Android架构角度看Window"></a>从Android架构角度看Window</h2><p>前面我们介绍过关于PhoneWindow和window之间的关系，了解到PhoneWindow其实不是Window，只是一个window容器。不知读者有没想过一个问题，为什么谷歌要建一个不是window但却名字是window的类？是故意要迷惑我们吗？要了解这个问题，我们先来回顾一下整个android的window机制结构。</p>
<p>首先从WindowManagerService开始，我们知道WMS是window的最终管理者，在WMS中为每一个应用持有一个session，关于session前面我们讲过，每个应用都是全局单例，负责和WMS通信的binder对象。WMS为每个window都建立了一个windowStatus对象，同一个应用的window使用同个session进行跨进程通信，结构大概如下：</p>
<p><img src="/2022/02/16/Window/12f7f052abef4e959e72f97c9972b327~tplv-k3u1fbpfcp-zoom-1-20231101160149493.png" alt="WMS结构"></p>
<p>而负责与WMS通信的，是viewRootImpl。前面我们讲过每个view树即为一个window，viewRootImpl负责和WMS进行通信，同时也负责view的绘制。如果把上面的图画仔细一点就是：</p>
<p><img src="/2022/02/16/Window/768cd62019764d129e24d432792e3638~tplv-k3u1fbpfcp-zoom-1-20231101160149500.png" alt="更详细的结构图"></p>
<p>图中每一个windowStatus对应一个viewRootImpl，WMS通过viewRootImpl来控制view。这也就是window机制的管理结构。当我们需要添加window的时候，最终的逻辑实现是WindowManagerGlobal，他的内部使用自己的session创建一个viewRootImpl，然后向WMS申请添加window，结构图大概如下：</p>
<p><img src="/2022/02/16/Window/c5dcbb1f264646539f78652b08ce0fc6~tplv-k3u1fbpfcp-zoom-1-20231101160149494.png" alt="window的添加结构"></p>
<p>windowManagerGlobal使用自己的IWindowSession创建viewRootImpl，这个IWindowSession是全局单例。viewRootImpl和WMS申请创建window，然后WMS允许之后，再通知viewRootImpl绘制view，同时WMS通过windowStatus存储了viewRootImpl的相关信息，这样如果WMS需要修改view，直接通过viewRootImpl就可以修改view了。</p>
<hr>
<p>从上面的描述中可以发现我全程没有提及到PhoneWindow和WindowManagerImpl。这是因为<strong>他们不属于window机制内的类，而是封装于window机制之上的框架</strong>。假设如果没有PhoneWindow和WindowManager我们该如何添加一个window？首先需要调用WindowGlobal获取session，再创建viewRootImpl，再访问wms，然后再利用viewRootImpl绘制view，是不是很复杂，而这仅仅只是整体的步骤。而WindowManagerImpl正是这个功能。他内部拥有WindowManagerGlobal的单例，然后帮助我们完成了这一系列的步骤。同时，<strong>windowManagerImpl也是只有一个实例，其他的windowManagerImpl都是建立在windowManagerImpl单例上</strong>。这一点在前面有通过源码介绍到。</p>
<p>另外，上面我讲到PhoneWindow并不是window而是一个辅助Activity管理的工具类，那为什么他不要命名为windowUtils呢？首先，PhoneWindow这个类是谷歌给window机制进行更上一层的封装。PhoneWindow内部拥有一个DecorView，我们的布局view都是添加到decorView中的，因为我们可以通过给decorView设置背景，宽高度，标题栏，按键反馈等等，来间接给我们的布局view设置。这样一来，PhoneWindow的存在，<strong>向开发者屏蔽真正的window，暴露给开发者一个“存在的”window</strong>。我们可以<strong>认为</strong>PhoneWindow就是一个window，window是view容器。当我们需要在屏幕上添加view的时候，只需要获得应用window对应的windowManagerImpl，然后直接调用addView方法添加view即可。这里也可以解释为什么windowManager的接口方法是addView而不是addWindow，一是window确实是以view的存在形式没错，二是为了向开发者屏蔽真正的window，让我们以为是在往window中添加view，window是真实存在的东西。他们的关系画个图如下：</p>
<p><img src="/2022/02/16/Window/ce6e958a4d7049eea68425b4383052bf~tplv-k3u1fbpfcp-zoom-1-20231101160149508.png" alt="window整体结构"></p>
<p>黄色部分输于谷歌提供给开发者的window框架，而绿色是真正的window机制结构。通过PhoneWindow我们可以很方便地进行window操作，而不须了解底层究竟是如何工作的。PhoneWindow的存在，更是让window的“可见性”得到了实现，让window变成了一个“view容器”。</p>
<p>好了最后来总结一下：</p>
<blockquote>
<ul>
<li>Android内部的window机制与谷歌暴露给我们的api是不一样的，谷歌封装的目的是为了让我们更好地使用window。</li>
<li>dialog、popupWindow等框架更是对具体场景进行更进一步的封装。</li>
<li>我们在了解window机制的时候，需要跳过应用层，看到window的本质，才能更好地帮助我们理解window。</li>
<li>在android的其他地方也是一样，利用封装向开发者屏蔽底层逻辑，让我们更好地运用。但如果我们需要了解他的机制的时候，就需要绕过这层封装，看到本质。</li>
</ul>
</blockquote>
<h2 id="window与PhoneWindow的关系"><a href="#window与PhoneWindow的关系" class="headerlink" title="window与PhoneWindow的关系"></a>window与PhoneWindow的关系</h2><blockquote>
<p>解释一下标题，window是指window机制中window这个概念，而PhoneWindow是指PhoneWindow这个类。后面我在讲的时候，如果是指类，我会在后面加个‘类’字。如window是指window概念，window类是指window这个抽象类。读者不要混淆。</p>
</blockquote>
<p>还记得我在讲window的概念的时候留了一个思考吗？</p>
<blockquote>
<p>思考：Android中不是有一个抽象类叫做window还有一个PhoneWindow实现类吗，他们不就是window的存在形式，为什么说window是抽象不存在的</p>
</blockquote>
<p>这里我再抛出几个问题：</p>
<ul>
<li>有一些资料认为PhoneWindow就是window，是view容器，负责管理容器内的view，windowManagerImpl可以往里面添加view，如上面我们讲过的addView方法。但是，同时它又说每个window对应一个viewRootImpl，但却没解释为什么每次addView都会新建一个viewRootImpl，前后发送矛盾。</li>
<li>有一些资料也是认为PhoneWindow是window，但是他说addView方法不是添加view而是添加window，同时拿这个方法的名字作为论据证明view就是window，但是他没解释为什么在使用addView方法创建window的过程却没有创建PhoneWindow对象。</li>
</ul>
<p>我们一步步来看。我们首先来看一下源码中对于window抽象类的注释：</p>
<p>复制代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> Abstract base <span class="class"><span class="keyword">class</span> <span class="title">for</span> <span class="title">a</span> <span class="title">top</span>-<span class="title">level</span> <span class="title">window</span> <span class="title">look</span> <span class="title">and</span> <span class="title">behavior</span> <span class="title">policy</span>.  <span class="title">An</span></span></span><br><span class="line"><span class="class"> <span class="title">instance</span> <span class="title">of</span> <span class="title">this</span> <span class="title">class</span> <span class="title">should</span> <span class="title">be</span> <span class="title">used</span> <span class="title">as</span> <span class="title">the</span> <span class="title">top</span>-<span class="title">level</span> <span class="title">view</span> <span class="title">added</span> <span class="title">to</span> <span class="title">the</span></span></span><br><span class="line"><span class="class"> <span class="title">window</span> <span class="title">manager</span>. <span class="title">It</span> <span class="title">provides</span> <span class="title">standard</span> <span class="title">UI</span> <span class="title">policies</span> <span class="title">such</span> <span class="title">as</span> <span class="title">a</span> <span class="title">background</span>, <span class="title">title</span></span></span><br><span class="line"><span class="class"> <span class="title">area</span>, <span class="title">default</span> <span class="title">key</span> <span class="title">processing</span>, <span class="title">etc</span>.</span></span><br><span class="line"><span class="class">     </span></span><br><span class="line"><span class="class">顶层窗口外观和行为策略的抽象基类。此类的实例应用作添加到窗口管理器的顶层视图。</span></span><br><span class="line"><span class="class">它提供标准的<span class="title">UI</span>策略，如背景、标题区域、默认键处理等。</span></span><br></pre></td></tr></table></figure>

<p>大概意思就是：这个类是顶级窗口的抽象基类，顶级窗口必须继承他，他负责窗口的外观如背景、标题、默认按键处理等。这个类的实例被添加到windowManager中，让windowManager对他进行管理。PhoneWindow是一个top-level window（顶级窗口），他被添加到顶级窗口管理器的顶层视图，其他的window，都需要添加到这个顶层视图中，所以更准确的来说，<strong>PhoneWindow并不是view容器，而是window容器。</strong></p>
<h3 id="PhoneWindow是Window吗？"><a href="#PhoneWindow是Window吗？" class="headerlink" title="PhoneWindow是Window吗？"></a>PhoneWindow是Window吗？</h3><p><strong>PhoneWindow并不是view容器，而是window容器。</strong></p>
<p>那PhoneWindow的存在意义是什么？</p>
<p>PhoneWindow只是提供了 token 机制来校验子window的合法性</p>
<h4 id="第一、提供DecorView模板。"><a href="#第一、提供DecorView模板。" class="headerlink" title="第一、提供DecorView模板。"></a>第一、提供DecorView模板。</h4><p>如下图：</p>
<p><img src="/2022/02/16/Window/e7a78467a1264f5886e420892981c59c~tplv-k3u1fbpfcp-zoom-1.png" alt="img"></p>
<p>我们的Activity是通过setContentView把布局设置到DecorView中，那么DecorView本身的布局，就成为了Activity界面的背景。同时DecorView是分为标题栏和内容两部分，所以也可以可界面设置标题栏。同时，由于我们的界面是添加在的DecorView中，属于DecorView的一部分。那么对于DecorView的window属性设置也会对我们的布局界面生效。还记得谷歌的官方给window类注释的最后一句话吗：<code>它提供标准的UI策略，如背景、标题区域、默认键处理等。</code>这些都可以通过DecorView实现，这是PhoneWindow的第一个作用。</p>
<h4 id="第二、抽离Activity中关于window的逻辑。"><a href="#第二、抽离Activity中关于window的逻辑。" class="headerlink" title="第二、抽离Activity中关于window的逻辑。"></a>第二、抽离Activity中关于window的逻辑。</h4><p>Activity的职责非常多，如果所有的事情都自己做，那么会造成本身代码极其臃肿。阅读过Activity启动的读者可能知道，AMS也通过ActivityStarter这个类来抽离启动Activity启动的逻辑。这样关于window相关的事情，就交给PhoneWindow去处理了。（事实上，Activity调用的是WindowManagerImpl，但因PhoneWindow和WindowManagerImpl两者是成对存在，他们共同处理window相关的事务，所以这里就简单写成交给PhoneWindow处理。）当Activity需要添加界面时，只需要一句setContentView，调用了PhoneWindow的setContentView方法，就把布局设置到屏幕上了。具体怎么完成，Activity不必管。</p>
<h4 id="第三、PhoneWindow提供了-token-机制来校验子window的合法性"><a href="#第三、PhoneWindow提供了-token-机制来校验子window的合法性" class="headerlink" title="第三、PhoneWindow提供了 token 机制来校验子window的合法性"></a>第三、PhoneWindow提供了 token 机制来校验子window的合法性</h4><p>添加window需要有token，而token只有PhoneWindow拥有；因此其他的window都必须直接或间接与Activity的PhoneWindow有联系</p>
<p>PhoneWindow内部有一个token属性，用于验证一个PhoneWindow是否允许添加window。在Activity创建PhoneWindow的时候，就会把从AMS传过来的token赋值给他，从而他也就有了添加token的权限。而其他的PhoneWindow则没有这个权限，因而也无法添加window。</p>
<p>校验 token 的过程主要发生在 WindowManagerService 中。当应用程序请求操作窗口时，比如添加、移动、更新或者移除窗口，系统会通过传递 token 来确定该操作是否合法。如果 token 是无效的，系统将拒绝该操作，校验条件包括</p>
<ol>
<li><strong>权限检查</strong>：系统会检查当前应用程序是否有权限执行特定的窗口操作。例如，如果一个应用程序没有 SYSTEM_ALERT_WINDOW 权限，它就无法显示悬浮窗口。</li>
<li><strong>安全性检查</strong>：系统可能会检查窗口的 token 是否有效、是否来自可信任的应用程序等。这可以防止恶意应用程序伪造窗口 token，尝试执行未经授权的窗口操作。</li>
<li><strong>焦点和层级检查</strong>：系统可能会检查窗口的焦点状态和层级关系，以确保窗口的显示不会干扰到其他窗口或系统功能的正常运行。</li>
</ol>
<h1 id="附录-常见type-amp-flag"><a href="#附录-常见type-amp-flag" class="headerlink" title="附录 常见type&amp;flag"></a>附录 常见type&amp;flag</h1><p><a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/view/WindowManager.LayoutParams">AndroidDeveloper.Window flag and type</a></p>
<h3 id="window的type属性"><a href="#window的type属性" class="headerlink" title="window的type属性"></a>window的type属性</h3><p>前面我们讲到window机制解决的一个问题就是view的显示次序问题，这个属性就决定了window的显示次序。window是有分类的，不同类别的显示高度范围不同，例如我把1-1000m高度称为低空，1001-2000m高度称为中空，2000以上称为高空。window也是一样按照高度范围进行分类，他也有一个变量Z-Order，决定了window的高度。window一共可分为三类：</p>
<ul>
<li>应用程序窗口：应用程序窗口一般位于最底层，Z-Order在1-99</li>
<li>子窗口：子窗口一般是显示在应用窗口之上，Z-Order在1000-1999</li>
<li>系统级窗口：系统级窗口一般位于最顶层，不会被其他的window遮住，如Toast，Z-Order在2000-2999。<strong>如果要弹出自定义系统级窗口需要动态申请权限</strong>。</li>
</ul>
<p>Z-Order越大，window越靠近用户，也就显示越高，高度高的window会覆盖高度低的window。</p>
<p>window的type属性就是Z-Order的值，我们可以给window的type属性赋值来决定window的高度。系统为我们三类window都预设了静态常量，如下（以下常用参数介绍转自参考文献第一篇文章）：</p>
<ul>
<li><p>应用级window</p>
<p>复制代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用程序 Window 的开始值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_APPLICATION_WINDOW = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用程序 Window 的基础值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_BASE_APPLICATION = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通的应用程序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊的应用程序窗口，当程序可以显示 Window 之前使用这个 Window 来显示一些东西</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_STARTING = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TYPE_APPLICATION 的变体，在应用程序显示之前，WindowManager 会等待这个 Window 绘制完毕</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_DRAWN_APPLICATION = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用程序 Window 的结束值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAST_APPLICATION_WINDOW = <span class="number">99</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>子window</p>
<p>复制代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子 Window 类型的开始值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_SUB_WINDOW = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用程序 Window 顶部的面板。这些 Window 出现在其附加 Window 的顶部。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_PANEL = FIRST_SUB_WINDOW;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于显示媒体(如视频)的 Window。这些 Window 出现在其附加 Window 的后面。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_MEDIA = FIRST_SUB_WINDOW + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用程序 Window 顶部的子面板。这些 Window 出现在其附加 Window 和任何Window的顶部</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_SUB_PANEL = FIRST_SUB_WINDOW + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前Window的布局和顶级Window布局相同时，不能作为子代的容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_ATTACHED_DIALOG = FIRST_SUB_WINDOW + <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用显示媒体 Window 覆盖顶部的 Window， 这是系统隐藏的 API</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_MEDIA_OVERLAY  = FIRST_SUB_WINDOW + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子面板在应用程序Window的顶部，这些Window显示在其附加Window的顶部， 这是系统隐藏的 API</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_ABOVE_SUB_PANEL = FIRST_SUB_WINDOW + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子 Window 类型的结束值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAST_SUB_WINDOW = <span class="number">1999</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>系统级window</p>
<p>复制代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统Window类型的开始值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_SYSTEM_WINDOW = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统状态栏，只能有一个状态栏，它被放置在屏幕的顶部，所有其他窗口都向下移动</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_STATUS_BAR = FIRST_SYSTEM_WINDOW;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统搜索窗口，只能有一个搜索栏，它被放置在屏幕的顶部</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_SEARCH_BAR = FIRST_SYSTEM_WINDOW+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已经从系统中被移除，可以使用 TYPE_KEYGUARD_DIALOG 代替</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_KEYGUARD = FIRST_SYSTEM_WINDOW+<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统对话框窗口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_SYSTEM_DIALOG = FIRST_SYSTEM_WINDOW+<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁屏时显示的对话框</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_KEYGUARD_DIALOG = FIRST_SYSTEM_WINDOW+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入法窗口，位于普通 UI 之上，应用程序可重新布局以免被此窗口覆盖</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_INPUT_METHOD = FIRST_SYSTEM_WINDOW+<span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入法对话框，显示于当前输入法窗口之上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_INPUT_METHOD_DIALOG= FIRST_SYSTEM_WINDOW+<span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 墙纸</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_WALLPAPER = FIRST_SYSTEM_WINDOW+<span class="number">13</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态栏的滑动面板</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_STATUS_BAR_PANEL = FIRST_SYSTEM_WINDOW+<span class="number">14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用程序叠加窗口显示在所有窗口之上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_OVERLAY = FIRST_SYSTEM_WINDOW + <span class="number">38</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统Window类型的结束值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAST_SYSTEM_WINDOW = <span class="number">2999</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Window的flags参数"><a href="#Window的flags参数" class="headerlink" title="Window的flags参数"></a>Window的flags参数</h3><p>flag标志控制window的东西比较多，很多资料的描述是“控制window的显示”，但我觉得不够准确。flag控制的范围包括了：各种情景下的显示逻辑（锁屏，游戏等）还有触控事件的处理逻辑。控制显示确实是他的很大部分功能，但是并不是全部。下面看一下一些常用的flag，就知道flag的功能了（以下常用参数介绍转自参考文献第一篇文章）：</p>
<p>复制代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当 Window 可见时允许锁屏</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_ALLOW_LOCK_WHILE_SCREEN_ON = <span class="number">0x00000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Window 后面的内容都变暗</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_DIM_BEHIND = <span class="number">0x00000002</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Window 不能获得输入焦点，即不接受任何按键或按钮事件，例如该 Window 上 有 EditView，点击 EditView 是 不会弹出软键盘的</span></span><br><span class="line"><span class="comment">// Window 范围外的事件依旧为原窗口处理；例如点击该窗口外的view，依然会有响应。另外只要设置了此Flag，都将会启用FLAG_NOT_TOUCH_MODAL</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_NOT_FOCUSABLE = <span class="number">0x00000008</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置了该 Flag,将 Window 之外的按键事件发送给后面的 Window 处理, 而自己只会处理 Window 区域内的触摸事件</span></span><br><span class="line"><span class="comment">// Window 之外的 view 也是可以响应 touch 事件。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_NOT_TOUCH_MODAL  = <span class="number">0x00000020</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置了该Flag，表示该 Window 将不会接受任何 touch 事件，例如点击该 Window 不会有响应，只会传给下面有聚焦的窗口。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_NOT_TOUCHABLE      = <span class="number">0x00000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要 Window 可见时屏幕就会一直亮着</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_KEEP_SCREEN_ON     = <span class="number">0x00000080</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许 Window 占满整个屏幕</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_LAYOUT_IN_SCREEN   = <span class="number">0x00000100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许 Window 超过屏幕之外</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_LAYOUT_NO_LIMITS   = <span class="number">0x00000200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全屏显示，隐藏所有的 Window 装饰，比如在游戏、播放器中的全屏显示</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_FULLSCREEN      = <span class="number">0x00000400</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示比FLAG_FULLSCREEN低一级，会显示状态栏</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_FORCE_NOT_FULLSCREEN   = <span class="number">0x00000800</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当用户的脸贴近屏幕时（比如打电话），不会去响应此事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_IGNORE_CHEEK_PRESSES    = <span class="number">0x00008000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 则当按键动作发生在 Window 之外时，将接收到一个MotionEvent.ACTION_OUTSIDE事件。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_WATCH_OUTSIDE_TOUCH = <span class="number">0x00040000</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="comment">// 窗口可以在锁屏的 Window 之上显示, 使用 Activity#setShowWhenLocked(boolean) 方法代替</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_SHOW_WHEN_LOCKED = <span class="number">0x00080000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示负责绘制系统栏背景。如果设置，系统栏将以透明背景绘制，</span></span><br><span class="line"><span class="comment">// 此 Window 中的相应区域将填充 Window＃getStatusBarColor（）和 Window＃getNavigationBarColor（）中指定的颜色。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS = <span class="number">0x80000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示要求系统壁纸显示在该 Window 后面，Window 表面必须是半透明的，才能真正看到它背后的壁纸</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_SHOW_WALLPAPER = <span class="number">0x00100000</span>;</span><br></pre></td></tr></table></figure>

<h3 id="window的solfInputMode属性"><a href="#window的solfInputMode属性" class="headerlink" title="window的solfInputMode属性"></a>window的solfInputMode属性</h3><p>这一部分就是当软件盘弹起来的时候，window的处理逻辑，这在日常中也经常遇到，如：我们在微信聊天的时候，点击输入框，当软键盘弹起来的时候输入框也会被顶上去。如果你不想被顶上去，也可以设置为被软键盘覆盖。下面介绍一下常见的属性（以下常见属性介绍选自参考文献第一篇文章）：</p>
<p>复制代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有指定状态，系统会选择一个合适的状态或者依赖于主题的配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SOFT_INPUT_STATE_UNCHANGED = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当用户进入该窗口时，隐藏软键盘</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SOFT_INPUT_STATE_HIDDEN = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当窗口获取焦点时，隐藏软键盘</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SOFT_INPUT_STATE_ALWAYS_HIDDEN = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当用户进入窗口时，显示软键盘</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SOFT_INPUT_STATE_VISIBLE = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当窗口获取焦点时，显示软键盘</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SOFT_INPUT_STATE_ALWAYS_VISIBLE = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// window会调整大小以适应软键盘窗口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SOFT_INPUT_MASK_ADJUST = <span class="number">0xf0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有指定状态,系统会选择一个合适的状态或依赖于主题的设置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SOFT_INPUT_ADJUST_UNSPECIFIED = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当软键盘弹出时，窗口会调整大小,例如点击一个EditView，整个layout都将平移可见且处于软件盘的上方</span></span><br><span class="line"><span class="comment">// 同样的该模式不能与SOFT_INPUT_ADJUST_PAN结合使用；</span></span><br><span class="line"><span class="comment">// 如果窗口的布局参数标志包含FLAG_FULLSCREEN，则将忽略这个值，窗口不会调整大小，但会保持全屏。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SOFT_INPUT_ADJUST_RESIZE = <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当软键盘弹出时，窗口不需要调整大小, 要确保输入焦点是可见的,</span></span><br><span class="line"><span class="comment">// 例如有两个EditView的输入框，一个为Ev1，一个为Ev2，当你点击Ev1想要输入数据时，当前的Ev1的输入框会移到软键盘上方</span></span><br><span class="line"><span class="comment">// 该模式不能与SOFT_INPUT_ADJUST_RESIZE结合使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SOFT_INPUT_ADJUST_PAN = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将不会调整大小，直接覆盖在window上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SOFT_INPUT_ADJUST_NOTHING = <span class="number">0x30</span>;</span><br></pre></td></tr></table></figure>

<h3 id="window的其他属性"><a href="#window的其他属性" class="headerlink" title="window的其他属性"></a>window的其他属性</h3><p>上面的三个属性是window比较重要也是比较复杂 的三个，除此之外还有几个日常经常使用的属性：</p>
<ul>
<li>x与y属性：指定window的位置</li>
<li>alpha：window的透明度</li>
<li>gravity：window在屏幕中的位置，使用的是Gravity类的常量</li>
<li>format：window的像素点格式，值定义在PixelFormat中</li>
</ul>
<hr>
<h3 id="如何给window属性赋值"><a href="#如何给window属性赋值" class="headerlink" title="如何给window属性赋值"></a>如何给window属性赋值</h3><p>window属性的常量值大部分存储在WindowManager.LayoutParams类中，我们可以通过这个类来获得这些常量。当然还有Gravity类和PixelFormat类等。</p>
<p>一般情况下我们会通过以下方式来往屏幕中添加一个window：</p>
<p>复制代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Activity中调用</span></span><br><span class="line">WindowManager.LayoutParams windowParams = <span class="keyword">new</span> WindowManager.LayoutParams();</span><br><span class="line">windParams.flags = WindowManager.LayoutParams.FLAG_FULLSCREEN;</span><br><span class="line">TextView view = <span class="keyword">new</span> TextView(<span class="keyword">this</span>);</span><br><span class="line">getWindowManager.addview(view,windowParams);</span><br></pre></td></tr></table></figure>

<p>我们可以直接给WindowManager.LayoutParams对象设置属性。</p>
<p>第二种赋值方法是直接给window赋值，如</p>
<p>复制代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getWindow().flags = WindowManager.LayoutParams.FLAG_FULLSCREEN;</span><br></pre></td></tr></table></figure>

<p>除此之外，window的solfInputMode属性比较特殊，他可以直接在AndroidManifest中指定，如下：</p>
<p>复制代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:windowSoftInputMode=<span class="string">&quot;adjustNothing&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p>最后总结一下：</p>
<blockquote>
<ul>
<li>window的重要属性有type、flags、solfInputMode、gravity等</li>
<li>我们可以通过不同的方式给window属性赋值</li>
<li>没必要去全部记下来，等遇到需求再去寻找对应的常量即可</li>
</ul>
</blockquote>
<h1 id="未整理"><a href="#未整理" class="headerlink" title="未整理"></a>未整理</h1><p><a target="_blank" rel="noopener" href="http://3dobe.com/archives/89/">http://3dobe.com/archives/89/</a></p>
<p>一个Activity或一个Dialog对应一个PhoneWindow，一个PhoneWindow对应一个WindowManger，对应一个WindowManagerImpl</p>
<p>所以得</p>
<p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/cb91e2b1769009c7192441573bbd902b.jpg?x-oss-process=image/resize,w_1792,m_lfit" alt="img"></p>
<p><img src="/2022/02/16/Window/resize,w_1792,m_lfit.jpeg" alt="img"></p>
<ul>
<li>mChoreographer，Choreographer的实例，在SampleWindow的例子中已经见过了。Choreographer的意思是编舞指导。它拥有从显示子系统获取VSYNC同步事件的能力，从而可以在合适的时机通知渲染动作，避免在渲染的过程中因为发生屏幕重绘而导致的画面撕裂。从这个意义上讲，Choreographer的确是指导Android翩翩起舞的大师。WMS使用Choreographer负责驱动所有的窗口动画、屏幕旋转动画、墙纸动画的渲染。</li>
<li>mAnimator，WindowAnimator的实例。它是所有窗口动画的总管（窗口动画是一个WindowStateAnimator对象）。在Choreographer的驱动下，逐个渲染所有的动画。</li>
<li>mPolicy，WindowPolicyManager的一个实现。目前它只有PhoneWindowManager一个实现类。mPolicy定义了很多窗口相关的策略，可以说是WMS的首席顾问！每当WMS要做什么事情的时候，都需要向这个顾问请教应当如何做。例如，告诉WMS某一个类型的Window的ZOrder的值是多少，帮助WMS矫正不合理的窗口属性，会为WMS监听屏幕旋转的状态，还会预处理一些系统按键事件（例如HOME、BACK键等的默认行为就是在这里实现的），等等。所以，mPolicy可谓是WMS中最重要的一个成员了。</li>
<li>mDisplayContents，一个DisplayContent类型的列表。Android 4.2支持基于Wi-Fi Display的多屏幕输出，而一个DisplayContent描述了一块可以绘制窗口的屏幕。每个DisplayContent都用一个整型变量作为其ID，其中手机默认屏幕的ID由Display.DEFAULT_DISPLAY常量指定。DisplayContent的管理是由DisplayManagerService完成的，在本章不会去探讨DisplayContent的实现细节，而是关注DisplayContent对窗口管理与布局的影响</li>
<li>mTokenMap，一个HashMap，保存了所有的显示令牌（类型为WindowToken），用于窗口管理。在SampleWindow例子中曾经提到过，一个窗口必须隶属于某一个显示令牌。在那个例子中所添加的令牌就被放进了这个HashMap中。从这个成员中还衍生出几个辅助的显示令牌的子集，例如mAppTokens保存了所有属于Activity的显示令牌（WindowToken的子类AppWindowToken），mExitingTokens则保存了正在退出过程中的显示令牌等。其中mAppTokens列表是有序的，它与AMS中的mHistory列表的顺序保持一致，反映了系统中Activity的顺序。</li>
<li>mWindowMap，也是一个HashMap，保存了所有窗口的状态信息（类型为WindowState），用于窗口管理。在SampleWindow例子中，使用IWindowSession.add（）所添加的窗口的状态将会被保存在mWindowMap中。与mTokenMap一样，mWindowMap一样有衍生出的子集。例如mPendingRemove保存了那些退出动画播放完成并即将被移除的窗口，mLosingFocus则保存了那些失去了输入焦点的窗口。在DisplayContent中，也有一个windows列表，这个列表存储了显示在此Display-Content中的窗口，并且它是有序的。窗口在这个列表中的位置决定了其最终显示时的Z序。</li>
<li>mSessions，一个List，元素类型为Session。Session其实是SampleWindow例子中的IWindowSession的Bn端。也就是说，mSessions这个列表保存了当前所有想向WMS寻求窗口管理服务的客户端。注意Session是进程唯一的。</li>
<li>mRotation，只是一个int型变量。它保存了当前手机的旋转状态</li>
</ul>
<p><code>Android</code> 系统采用一种称为 <code>Surface</code> 的图形架构，简而言之，每一个 <code>Activity</code> 都关联有至少一个 <code>Window</code>（窗口），每一个 <code>Window</code> 都对应有一个 <code>Surface</code>。</p>
<p><code>Surface</code> 这里直译过来叫做 <strong>绘图表面</strong> ，顾名思义，其可在内存中生成一个图形缓冲区队列，用于描述 <code>UI</code>，经与系统服务的<code>WindowServiceManager</code> 通信后、通过 <code>SurfaceFlinger</code> 服务持续合成并送显到显示屏。</p>
<p><img src="/2022/02/16/Window/178bc0e274ca4b6c9fe052eb6b4357de~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="2.png"></p>
<p>由此可见，通常情况下，一个 <code>Activity</code> 的 <code>UI</code> 渲染本质是 <strong>系统提供一块内存，并创建一个图形缓冲区进行维护</strong>；这块内存就是 <code>Surface</code>，最终页面所有 <code>View</code> 的 <code>UI</code> 状态数据，都会被填充到同一个 <code>Surface</code> 中。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Window</p><p><a href="http://example.com/2022/02/16/Window/">http://example.com/2022/02/16/Window/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>white crow</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2022-02-16</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-03-25</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/SystemService/">SystemService</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/02/16/PackageManager/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">PackageManager</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/01/24/Linux/"><span class="level-item">Linux</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#从Window视角看ActivityStart"><span class="level-left"><span class="level-item">1</span><span class="level-item">从Window视角看ActivityStart</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Activity"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Activity</span></span></a></li><li><a class="level is-mobile" href="#Other-Window"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">Other Window</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#PopupWindow"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">PopupWindow</span></span></a></li><li><a class="level is-mobile" href="#Dialog"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">Dialog</span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">1.2.3</span><span class="level-item">总结</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#概念梳理-待整理"><span class="level-left"><span class="level-item">2</span><span class="level-item">概念梳理//待整理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#关键类"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">关键类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#window相关"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">window相关</span></span></a></li><li><a class="level is-mobile" href="#WindowManager相关"><span class="level-left"><span class="level-item">2.1.2</span><span class="level-item">WindowManager相关</span></span></a></li><li><a class="level is-mobile" href="#view相关"><span class="level-left"><span class="level-item">2.1.3</span><span class="level-item">view相关</span></span></a></li><li><a class="level is-mobile" href="#WindowManagerService"><span class="level-left"><span class="level-item">2.1.4</span><span class="level-item">WindowManagerService</span></span></a></li></ul></li><li><a class="level is-mobile" href="#从Android架构角度看Window"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">从Android架构角度看Window</span></span></a></li><li><a class="level is-mobile" href="#window与PhoneWindow的关系"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">window与PhoneWindow的关系</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#PhoneWindow是Window吗？"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">PhoneWindow是Window吗？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#第一、提供DecorView模板。"><span class="level-left"><span class="level-item">2.3.1.1</span><span class="level-item">第一、提供DecorView模板。</span></span></a></li><li><a class="level is-mobile" href="#第二、抽离Activity中关于window的逻辑。"><span class="level-left"><span class="level-item">2.3.1.2</span><span class="level-item">第二、抽离Activity中关于window的逻辑。</span></span></a></li><li><a class="level is-mobile" href="#第三、PhoneWindow提供了-token-机制来校验子window的合法性"><span class="level-left"><span class="level-item">2.3.1.3</span><span class="level-item">第三、PhoneWindow提供了 token 机制来校验子window的合法性</span></span></a></li></ul></li></ul></li></ul></li><li><a class="level is-mobile" href="#附录-常见type-amp-flag"><span class="level-left"><span class="level-item">3</span><span class="level-item">附录 常见type&amp;flag</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#window的type属性"><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">window的type属性</span></span></a></li><li><a class="level is-mobile" href="#Window的flags参数"><span class="level-left"><span class="level-item">3.1.2</span><span class="level-item">Window的flags参数</span></span></a></li><li><a class="level is-mobile" href="#window的solfInputMode属性"><span class="level-left"><span class="level-item">3.1.3</span><span class="level-item">window的solfInputMode属性</span></span></a></li><li><a class="level is-mobile" href="#window的其他属性"><span class="level-left"><span class="level-item">3.1.4</span><span class="level-item">window的其他属性</span></span></a></li><li><a class="level is-mobile" href="#如何给window属性赋值"><span class="level-left"><span class="level-item">3.1.5</span><span class="level-item">如何给window属性赋值</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#未整理"><span class="level-left"><span class="level-item">4</span><span class="level-item">未整理</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatarPng.png" alt="White Crow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">White Crow</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">80</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">4</p></a></div></div></nav></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a><p class="is-size-7"><span>&copy; 2025 white crow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://github.com/WhileCrow"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>