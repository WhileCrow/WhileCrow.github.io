<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java - Crow&#039;s Sky</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Crow&#039;s Sky"><meta name="msapplication-TileImage" content="/img/avatarCircle.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Crow&#039;s Sky"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="final &amp;amp; finalize()finalfinal修饰的类不可被继承，方法不可被覆盖(或者叫重写)，对象不可被更改。 finalize()finalize()是Object的protected方法，是用来给对象在Gc前一次行动的机会：首先，当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finali"><meta property="og:type" content="blog"><meta property="og:title" content="Java"><meta property="og:url" content="http://example.com/2022/01/10/Java/"><meta property="og:site_name" content="Crow&#039;s Sky"><meta property="og:description" content="final &amp;amp; finalize()finalfinal修饰的类不可被继承，方法不可被覆盖(或者叫重写)，对象不可被更改。 finalize()finalize()是Object的protected方法，是用来给对象在Gc前一次行动的机会：首先，当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finali"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/2022/01/10/Java/u=3137389296,1222888772&amp;fm=26&amp;gp=0.jpg"><meta property="og:image" content="http://example.com/2022/01/10/Java/bd1a8299be0041f086449e1f105842b1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"><meta property="og:image" content="http://example.com/2022/01/10/Java/008eGmZEly1goe17hajvzj316d0lhju3.jpg"><meta property="og:image" content="http://example.com/2022/01/10/Java/CgpOIF5rDYmATP43AAB3coc0R64799.png"><meta property="og:image" content="http://example.com/2022/01/10/Java/u=1035283471,1167301443&amp;fm=26&amp;gp=0.jpg"><meta property="og:image" content="http://example.com/2022/01/10/Java/008eGmZEly1goe1gq2yipj318s0ruwj4.jpg"><meta property="article:published_time" content="2022-01-10T06:35:59.000Z"><meta property="article:modified_time" content="2024-04-22T06:20:58.600Z"><meta property="article:author" content="White Crow"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2022/01/10/Java/u=3137389296,1222888772&amp;fm=26&amp;gp=0.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2022/01/10/Java/"},"headline":"Java","image":["http://example.com/2022/01/10/Java/u=3137389296,1222888772&fm=26&gp=0.jpg","http://example.com/2022/01/10/Java/008eGmZEly1goe17hajvzj316d0lhju3.jpg","http://example.com/2022/01/10/Java/CgpOIF5rDYmATP43AAB3coc0R64799.png","http://example.com/2022/01/10/Java/u=1035283471,1167301443&fm=26&gp=0.jpg","http://example.com/2022/01/10/Java/008eGmZEly1goe1gq2yipj318s0ruwj4.jpg"],"datePublished":"2022-01-10T06:35:59.000Z","dateModified":"2024-04-22T06:20:58.600Z","author":{"@type":"Person","name":"white crow"},"publisher":{"@type":"Organization","name":"Crow's Sky","logo":{"@type":"ImageObject","url":"http://example.com/img/avatarCircle.png"}},"description":"final &amp; finalize()finalfinal修饰的类不可被继承，方法不可被覆盖(或者叫重写)，对象不可被更改。 finalize()finalize()是Object的protected方法，是用来给对象在Gc前一次行动的机会：首先，当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finali"}</script><link rel="canonical" href="http://example.com/2022/01/10/Java/"><link rel="icon" href="/img/avatarCircle.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/WhileCrow"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-10-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-01-10T06:35:59.000Z" title="1/10/2022, 2:35:59 PM">2022-01-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-04-22T06:20:58.600Z" title="4/22/2024, 2:20:58 PM">2024-04-22</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">an hour read (About 7080 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">Java</h1><div class="content"><h1 id="final-amp-finalize"><a href="#final-amp-finalize" class="headerlink" title="final &amp; finalize()"></a>final &amp; finalize()</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>final修饰的类不可被继承，方法不可被覆盖(或者叫重写)，对象不可被更改。</p>
<h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h2><p>finalize()是Object的protected方法，是用来给对象在Gc前<strong>一次</strong>行动的机会：首先，当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。</p>
<ul>
<li><p>System.gc()与System.runFinalization()方法增加了finalize方法执行的机会，但不可盲目依赖它们</p>
</li>
<li><p>Java语言规范并不保证finalize方法会被及时地执行、而且根本不会保证它们会被执行</p>
</li>
<li><p>finalize方法可能会带来性能问题。因为JVM通常在单独的低优先级线程中完成finalize的执行</p>
</li>
<li><p>对象再生问题：finalize方法中，可将待回收对象赋值给GC Roots可达的对象引用，从而达到对象再生的目的</p>
</li>
<li><p>finalize方法至多由GC执行一次(用户当然可以手动调用对象的finalize方法，但并不影响GC对finalize的行为)</p>
</li>
</ul>
<p>简述：finalize()方法会在对象回收前至多被调用一次，一般可以在这里做一次重新挂到GcRoot链上的保活操作，或者像Android6以前安卓在覆盖的finalize()方法中释放native内存一样。</p>
<span id="more"></span>



<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title=".toString"></a>.toString</h2><p><strong>toString</strong> 默认是个指针，一般需要重写，未重写情况下，返回 </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getClass().getName() + &#39;@&#39; + Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure>



<h2 id="equal-amp-hashcode"><a href="#equal-amp-hashcode" class="headerlink" title="equal &amp; hashcode"></a>equal &amp; hashcode</h2><ul>
<li>If <code>o1.equals(o2)</code>, then <code>o1.hashCode() == o2.hashCode()</code> should always be <code>true</code>.</li>
<li>If <code>o1.hashCode() == o2.hashCode</code> is true, it doesn’t mean that <code>o1.equals(o2)</code> will be <code>true</code>.</li>
</ul>
<p>也就是equals 是 hashcode的<strong>充分不必要条件</strong></p>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><p>比较对象是否<strong>内容</strong>相同，默认和==功能一致</p>
<h3 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h3><p>该对象哈希。hashcode有多种实现，不一定与内存地址相关。目前版本是”当前线程有关的一个随机数+三个确定值，运用xorshift随机数算法得到的一个随机数“</p>
<p><strong>重写equal 的同时为什么必须重写hashcode？</strong></p>
<p>注意：当equals方法被重写时，通常有必要重写 <code>hashCode</code> 方法，以维护 <code>hashCode</code> 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p>
<p>hashCode是编译器为不同对象产生的不同整数，根据equal方法的定义：如果两个对象是相等（equal）的，那么两个对象调用hashCode必须产生相同的整数结果，即：equal为true，hashCode必须为true，equal为false，hashCode也必须为false，所以必须重写hashCode来保证与equal同步。</p>
<h2 id="finalize-1"><a href="#finalize-1" class="headerlink" title="finalize()"></a>finalize()</h2><h2 id="wait-amp-notify"><a href="#wait-amp-notify" class="headerlink" title="wait() &amp; notify()"></a>wait() &amp; notify()</h2><h2 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h2><h2 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h2><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p><strong>封装：</strong>对抽象的事物抽象化成一个对象，并对其对象的属性私有化，同时提供一些能被外界访问属性的方法；</p>
<p><strong>继承</strong>：子类扩展新的数据域或功能，并复用父类的属性与功能，单继承，多实现；</p>
<p><strong>多态：</strong>通过继承（多个⼦类对同⼀⽅法的重写）、也可以通过接⼝（实现接⼝并覆盖接⼝）</p>
<h2 id="静态绑定与动态绑定，重载Overload与重写Override："><a href="#静态绑定与动态绑定，重载Overload与重写Override：" class="headerlink" title="静态绑定与动态绑定，重载Overload与重写Override："></a>静态绑定与动态绑定，重载Overload与重写Override：</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p> 一种是在编译期确定，被称为静态分派，比如方法的重载Overload；</p>
<p>重载指在同一个类中定义多个方法，这些方法名称相同，签名不同。**(参数列表必须改，其他无要求)**</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p> 一种是在运行时确定，被称为动态分派，比如方法的覆盖Override（重写）和接口的实现。</p>
<p>重写指在子类中的方法的名称和签名都和父类相同，使用override注解。**(参数和返回不能改，其他不能升级)**</p>
<h4 id="多态实现"><a href="#多态实现" class="headerlink" title="多态实现"></a>多态实现</h4><p>多态的底层实现是动态绑定，即在运行时才把方法调用与方法实现关联起来。在Java中有两种形式可以实现多态：<strong>方法的覆盖Override（重写）和接口的实现。</strong></p>
<p><strong>多态的实现原理</strong></p>
<p> 虚拟机栈中会存放当前方法调用的栈帧（局部变量表、操作栈、动态连接 、返回地址）。多态的实现过程，就是方法调用动态分派的过程，如果子类覆盖了父类的方法，则在多态调用中，动态绑定过程会首先确定实际类型是子类，从而先搜索到子类中的方法。这个过程便是方法覆盖的本质。</p>
<h3 id="附录：重写Override和重载Overload的区别"><a href="#附录：重写Override和重载Overload的区别" class="headerlink" title="附录：重写Override和重载Overload的区别"></a>附录：重写Override和重载Overload的区别</h3><p><strong>Overload 在同一个类中</strong>，重载指在同一个类中定义多个方法，这些方法名称相同，签名不同。**(参数列表必须改，其他无要求)**</p>
<p><strong>Overwirte 集成于父类的子类中</strong>，重写指在子类中的方法的名称和签名都和父类相同，使用override注解。**(参数和返回不能改，其他不能升级)**</p>
<table>
<thead>
<tr>
<th align="left">区别点</th>
<th align="left">重载方法</th>
<th align="left">重写方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">参数列表</td>
<td align="left">必须修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">返回类型</td>
<td align="left">可以修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">异常</td>
<td align="left">可以修改</td>
<td align="left">可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td align="left">访问</td>
<td align="left">可以修改</td>
<td align="left">一定不能做更严格的限制（可以降低限制）</td>
</tr>
</tbody></table>
<h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h3><p><strong>特性：</strong>封装、继承、多态</p>
<p> <strong>封装：</strong>对抽象的事物抽象化成一个对象，并对其对象的属性私有化，同时提供一些能被外界访问属性的方法；</p>
<p> <strong>继承</strong>：子类扩展新的数据域或功能，并复用父类的属性与功能，单继承，多实现；</p>
<p> <strong>多态：</strong>通过继承（多个⼦类对同⼀⽅法的重写）、也可以通过接⼝（实现接⼝并覆盖接⼝）</p>
<h4 id="1、Java与C-区别"><a href="#1、Java与C-区别" class="headerlink" title="1、Java与C++区别"></a><strong>1、Java与C++区别</strong></h4><p> 不同点：c++支持多继承，并且有指针的概念，由程序员自己管理内存；Java是单继承，可以用接口实现多继承，Java 不提供指针来直接访问内存，程序内存更加安全，并且Java有JVM⾃动内存管理机制，不需要程序员⼿动释放⽆⽤内存</p>
<h4 id="2、多态实现原理"><a href="#2、多态实现原理" class="headerlink" title="2、多态实现原理"></a><strong>2、多态实现原理</strong></h4><p>多态的底层实现是动态绑定，即在运行时才把方法调用与方法实现关联起来。</p>
<p><strong>静态绑定与动态绑定：</strong></p>
<p> 一种是在编译期确定，被称为静态分派，比如方法的重载；</p>
<p> 一种是在运行时确定，被称为动态分派，比如方法的覆盖（重写）和接口的实现。</p>
<p><strong>多态的实现</strong></p>
<p> 虚拟机栈中会存放当前方法调用的栈帧（局部变量表、操作栈、动态连接 、返回地址）。多态的实现过程，就是方法调用动态分派的过程，如果子类覆盖了父类的方法，则在多态调用中，动态绑定过程会首先确定实际类型是子类，从而先搜索到子类中的方法。这个过程便是方法覆盖的本质。</p>
<h4 id="3、static和final关键字"><a href="#3、static和final关键字" class="headerlink" title="3、static和final关键字"></a>3、static和final关键字</h4><p><strong>static：</strong>可以修饰属性、方法</p>
<p> <strong>static修饰属性：</strong></p>
<p> 类级别属性，所有对象共享一份，随着类的加载而加载（只加载一次），先于对象的创建；可以使用类名直接调用。</p>
<p> <strong>static修饰方法：</strong></p>
<p> 随着类的加载而加载；可以使用类名直接调用；静态方法中，只能调用静态的成员，不可用this；</p>
<p><strong>final：</strong>关键字主要⽤在三个地⽅：变量、⽅法、类。</p>
<p> <strong>final修饰变量：</strong></p>
<p> 如果是基本数据类型的变量，则其数值⼀旦在初始化之后便不能更改；</p>
<p> 如果是引⽤类型的变量，则在对其初始化之后便不能再让其指向另⼀个对象。</p>
<p> <strong>final修饰方法：</strong></p>
<p> 把⽅法锁定，以防任何继承类修改它的含义（重写）；类中所有的 private ⽅法都隐式地指定为 final。</p>
<p> <strong>final修饰类：</strong></p>
<p> final 修饰类时，表明这个类不能被继承。final 类中的所有成员⽅法都会被隐式地指定为 final ⽅法。</p>
<p>一个类不能被继承，除了final关键字之外，还有可以私有化构造器。（内部类无效）</p>
<h4 id="4、抽象类和接口"><a href="#4、抽象类和接口" class="headerlink" title="4、抽象类和接口"></a>4、抽象类和接口</h4><p><strong>抽象类：</strong>包含抽象方法的类，即使用abstract修饰的类；抽象类只能被继承，所以不能使用final修饰，抽象类不能被实例化，</p>
<p><strong>接口：</strong>接口是一个抽象类型，是抽象方法的集合，接口支持多继承，接口中定义的方法，默认是public abstract修饰的抽象方法</p>
<p><strong>相同点：</strong></p>
<p> ① 抽象类和接口都不能被实例化</p>
<p> ② 抽象类和接口都可以定义抽象方法，子类/实现类必须覆写这些抽象方法</p>
<p><strong>不同点：</strong></p>
<p> ① 抽象类有构造方法，接口没有构造方法</p>
<p> ③抽象类可以包含普通方法，接口中只能是public abstract修饰抽象方法（Java8之后可以）</p>
<p> ③ 抽象类只能单继承，接口可以多继承</p>
<p> ④ 抽象类可以定义各种类型的成员变量，接口中只能是public static final修饰的静态常量</p>
<p><strong>抽象类的使用场景：</strong></p>
<p> 既想约束子类具有共同的行为（但不再乎其如何实现），又想拥有缺省的方法，又能拥有实例变量</p>
<p><strong>接口的应用场景：</strong></p>
<p> 约束多个实现类具有统一的行为，但是不在乎每个实现类如何具体实现；实现类中各个功能之间可能没有任何联系</p>
<h4 id="5、泛型以及泛型擦除"><a href="#5、泛型以及泛型擦除" class="headerlink" title="5、泛型以及泛型擦除"></a>5、泛型以及泛型擦除</h4><p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/baoyinwang/article/details/107341997">https://blog.csdn.net/baoyinwang/article/details/107341997</a></p>
<p><strong>泛型：</strong></p>
<p> 泛型的本质是参数化类型。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。</p>
<p><strong>泛型擦除：</strong></p>
<p> Java的泛型是伪泛型，使用泛型的时候加上类型参数，在编译器编译生成的字节码的时候会去掉，这个过程成为类型擦除。</p>
<p> 如List等类型，在编译之后都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。</p>
<p>可以通过反射添加其它类型元素</p>
<h4 id="6、反射原理以及使用场景"><a href="#6、反射原理以及使用场景" class="headerlink" title="6、反射原理以及使用场景"></a><strong>6、反射原理以及使用场景</strong></h4><p><strong>Java反射：</strong></p>
<p> 是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且都能够调用它的任意一个方法；</p>
<p><strong>反射原理：</strong></p>
<p> 反射首先是能够获取到Java中的反射类的字节码，然后将字节码中的方法，变量，构造函数等映射成 相应的 Method、Filed、Constructor 等类</p>
<p> <strong>如何得到Class的实例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.类名.class(就是一份字节码)</span><br><span class="line">2.Class.forName(String className);根据一个类的全限定名来构建Class对象</span><br><span class="line">3.每一个对象多有getClass()方法:obj.getClass();返回对象的真实类型</span><br></pre></td></tr></table></figure>

<p><strong>使用场景：</strong></p>
<ul>
<li><p><strong>开发通用框架 -</strong> 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，需要根据配置文件运行时动态加载不同的对象或类，调用不同的方法。</p>
</li>
<li><p><strong>动态代理</strong> - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。</p>
<p>JDK：spring默认动态代理，需要实现接口</p>
<p>CGLIB：通过asm框架序列化字节流，可配置，性能差</p>
</li>
<li><p><strong>自定义注解</strong> - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。</p>
</li>
</ul>
<h4 id="7、Java异常体系"><a href="#7、Java异常体系" class="headerlink" title="7、Java异常体系"></a><strong>7、Java异常体系</strong></h4><p><img src="/2022/01/10/Java/u=3137389296,1222888772&fm=26&gp=0.jpg" alt="img"></p>
<p><img src="/2022/01/10/Java/bd1a8299be0041f086449e1f105842b1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception</p>
<p><strong>Error ：</strong></p>
<p> 是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。</p>
<p><strong>Exception 包含：RuntimeException 、CheckedException</strong></p>
<p>编程错误可以分成三类：语法错误、逻辑错误和运行错误。</p>
<p><strong>语法错误</strong>（也称编译错误）是在编译过程中出现的错误，由编译器检查发现语法错误</p>
<p><strong>逻辑错误</strong>指程序的执行结果与预期不符，可以通过调试定位并发现错误的原因</p>
<p><strong>运行错误</strong>是引起程序非正常终端的错误，需要通过异常处理的方式处理运行错误</p>
<p><strong>RuntimeException：</strong> 运行时异常，程序应该从逻辑角度尽可能避免这类异常的发生。</p>
<p> 如 NullPointerException 、 ClassCastException ；</p>
<p><strong>CheckedException：</strong>受检异常，程序使用trycatch进行捕捉处理</p>
<p> 如IOException、SQLException、NotFoundException；</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="/2022/01/10/Java/008eGmZEly1goe17hajvzj316d0lhju3.jpg" alt="JavaCollection"></p>
<h4 id="1、ArrayList和LinkedList"><a href="#1、ArrayList和LinkedList" class="headerlink" title="1、ArrayList和LinkedList"></a><strong>1、ArrayList和LinkedList</strong></h4><p><strong>ArrayList：</strong></p>
<p> 底层基于数组实现，支持对元素进行快速随机访问，适合随机查找和遍历，不适合插入和删除。（提一句实际上）<br>​ 默认初始大小为10，当数组容量不够时，会触发扩容机制（扩大到当前的1.5倍），需要将原来数组的数据复制到新的数组中；当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。</p>
<p><strong>LinkedList：</strong></p>
<p> 底层基于双向链表实现，适合数据的动态插入和删除；<br>​ 内部提供了 List 接口中没有定义的方法，用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。（比如jdk官方推荐使用基于linkedList的Deque进行堆栈操作）</p>
<p><strong>ArrayList与LinkedList区别：</strong></p>
<p> 都是线程不安全的，ArrayList 适用于查找的场景，LinkedList 适用于增加、删除多的场景</p>
<p><strong>实现线程安全：</strong></p>
<p> 可以使用原生的Vector，或者是Collections.synchronizedList(List list)函数返回一个线程安全的ArrayList集合。<br>​ 建议使用concurrent并发包下的<strong>CopyOnWriteArrayList</strong>的。</p>
<p> ①<strong>Vector:</strong> 底层通过synchronize修饰保证线程安全，效率较差</p>
<p> ②<strong>CopyOnWriteArrayList：</strong>写时加锁，使用了一种叫<strong>写时复制</strong>的方法；读操作是可以不用加锁的</p>
<h4 id="2、List遍历快速和安全失败"><a href="#2、List遍历快速和安全失败" class="headerlink" title="2、List遍历快速和安全失败"></a><strong>2、List遍历快速和安全失败</strong></h4><p><strong>①普通for循环遍历List删除指定元素</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(list.get(i) == <span class="number">5</span>) </span><br><span class="line">       list.remove(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>② 迭代遍历,用list.remove(i)方法删除元素</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Integer value = it.next();</span><br><span class="line">    <span class="keyword">if</span>(value == <span class="number">5</span>)&#123;</span><br><span class="line">        list.remove(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>③foreach遍历List删除元素</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integer i:list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">3</span>) list.remove(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>fail—fast：</strong>快速失败</p>
<p> 当异常产生时，直接抛出异常，程序终止;</p>
<p> fail-fast主要是体现在当我们在遍历集合元素的时候，经常会使用迭代器，但在迭代器遍历元素的过程中，如果集合的结构（modCount）被改变的话，就会抛出异常ConcurrentModificationException，防止继续遍历。这就是所谓的快速失败机制。</p>
<p><strong>fail—safe：</strong>安全失败</p>
<p>    采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发ConcurrentModificationException。</p>
<p>    缺点：基于拷贝内容的优点是避免了ConcurrentModificationException，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p>
<p>    场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p>
<h4 id="3、详细介绍HashMap"><a href="#3、详细介绍HashMap" class="headerlink" title="3、详细介绍HashMap"></a><strong>3、详细介绍HashMap</strong></h4><p>角度：数据结构+扩容情况+put查找的详细过程+哈希函数+容量为什么始终都是2^N，JDK1.7与1.8的区别。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9fe4cb316c05">https://www.jianshu.com/p/9fe4cb316c05</a></p>
<p><strong>数据结构：</strong></p>
<p> HashMap在底层数据结构上采用了数组＋链表＋红黑树，通过散列映射来存储键值对数据</p>
<p><strong>扩容情况：</strong></p>
<p> 默认的负载因子是0.75，如果数组中已经存储的元素个数大于数组长度的75%，将会引发扩容操作。</p>
<p> 【1】创建一个长度为原来数组长度<strong>两倍的新数组</strong>。</p>
<p> 【2】1.7采用Entry的重新hash运算，1.8采用高于与运算。</p>
<p><strong>put操作步骤：</strong></p>
<p><img src="/2022/01/10/Java/CgpOIF5rDYmATP43AAB3coc0R64799.png" alt="img"></p>
<p> 1、判断数组是否为空，为空进行初始化;</p>
<p> 2、不为空，则计算 key 的 hash 值，通过(n - 1) &amp; hash计算应当存放在数组中的下标 index;</p>
<p> 3、查看 table[index] 是否存在数据，没有数据就构造一个Node节点存放在 table[index] 中；</p>
<p> 4、存在数据，说明发生了hash冲突(存在二个节点key的hash值一样), 继续判断key是否相等，相等，用新的value替换原数据；</p>
<p> 5、若不相等，判断当前节点类型是不是树型节点，如果是树型节点，创造树型节点插入红黑树中；</p>
<p> 6、若不是红黑树，创建普通Node加入链表中；判断链表长度是否大于 8，大于则将链表转换为红黑树；</p>
<p> 7、插入完成之后判断当前节点数是否大于阈值，若大于，则扩容为原数组的二倍</p>
<p><strong>哈希函数：</strong></p>
<p> 通过hash函数（优质因子31循环累加）先拿到 key 的hashcode，是一个32位的值，然后让hashcode的高16位和低16位进行<strong>异或</strong>操作。该函数也称为扰动函数，做到尽可能降低hash碰撞，通过尾插法进行插入。</p>
<p><strong>容量为什么始终都是2^N：</strong></p>
<p> 先做对数组的⻓度取模运算，得到的余数才能⽤来要存放的位置也就是对应的数组下标。这个数组下标的计算⽅法是“ (n - 1) &amp; hash ”。（n代表数组⻓度）。方便数组的扩容和增删改时的取模。</p>
<p><strong>JDK1.7与1.8的区别：</strong></p>
<p><strong>JDK1.7 HashMap：</strong></p>
<p> 底层是 <strong>数组和链表</strong> 结合在⼀起使⽤也就是链表散列。如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。扩容翻转时顺序不一致使用头插法会产生死循环，导致cpu100%</p>
<p><strong>JDK1.8 HashMap：</strong></p>
<p> 底层数据结构上采用了<strong>数组＋链表＋红黑树</strong>；当链表⻓度⼤于阈值（默认为 8-泊松分布），数组的⻓度大于 64时，链表将转化为红⿊树，以减少搜索时间。（解决了tomcat臭名昭著的url参数dos攻击问题）</p>
<h4 id="4、ConcurrentHashMap"><a href="#4、ConcurrentHashMap" class="headerlink" title="**4、ConcurrentHashMap **"></a>**4、ConcurrentHashMap **</h4><p> 可以通过<strong>ConcurrentHashMap</strong> 和 <strong>Hashtable</strong>来实现线程安全；Hashtable 是原始API类，通过synchronize同步修饰，效率低下；ConcurrentHashMap 通过分段锁实现，效率较比Hashtable要好；</p>
<p><strong>ConcurrentHashMap的底层实现：</strong></p>
<p> <strong>JDK1.7的 ConcurrentHashMap</strong> 底层采⽤ 分段的数组+链表 实现；采用 <strong>分段锁</strong>（Sagment） 对整个桶数组进⾏了分割分段(Segment默认16个)，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数据段的数据，就不会存在锁竞争，提⾼并发访问率。</p>
<p><img src="/2022/01/10/Java/u=1035283471,1167301443&fm=26&gp=0.jpg" alt="img"></p>
<p> <strong>JDK1.8的 ConcurrentHashMap</strong> 采⽤的数据结构跟HashMap1.8的结构⼀样，数组+链表/红⿊树；摒弃了Segment的概念，⽽是直接⽤ Node 数组+链表+红⿊树的数据结构来实现，通过并发控制 <strong>synchronized 和CAS</strong>来操作保证线程的安全。</p>
<h4 id="5、序列化和反序列化"><a href="#5、序列化和反序列化" class="headerlink" title="5、序列化和反序列化"></a><strong>5、序列化和反序列化</strong></h4><p> 序列化的意思就是将对象的状态转化成字节流，以后可以通过这些值再生成相同状态的对象。对象序列化是对象持久化的一种实现方法，它是将对象的属性和方法转化为一种序列化的形式用于存储和传输。反序列化就是根据这些保存的信息重建对象的过程。</p>
<p><strong>序列化：</strong>将java对象转化为字节序列的过程。</p>
<p><strong>反序列化：</strong>将字节序列转化为java对象的过程。</p>
<p><strong>优点：</strong></p>
<p> a、实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里）Redis的RDB</p>
<p> b、利用序列化实现远程通信，即在网络上传送对象的字节序列。 Google的protoBuf</p>
<p><strong>反序列化失败的场景：</strong></p>
<p> 序列化ID：serialVersionUID不一致的时候，导致反序列化失败</p>
<h4 id="6、String"><a href="#6、String" class="headerlink" title="6、String"></a><strong>6、String</strong></h4><p>String 使用<strong>数组</strong>存储内容，数组使用 <strong>final</strong> 修饰，因此 String 定义的字符串的值也是<strong>不可变的</strong></p>
<p>StringBuffer 对方法加了同步锁，线程安全，效率略低于 StringBuilder</p>
<h3 id="设计模式与原则"><a href="#设计模式与原则" class="headerlink" title="设计模式与原则"></a>设计模式与原则</h3><h4 id="1、单例模式"><a href="#1、单例模式" class="headerlink" title="1、单例模式"></a>1、单例模式</h4><p> 某个类只能生成一个实例，该实例全局访问，例如Spring容器里一级缓存里的单例池。</p>
<p><strong>优点</strong>：</p>
<p> <strong>唯一访问</strong>：如生成唯一序列化的场景、或者spring默认的bean类型。</p>
<p> <strong>提高性能</strong>：频繁实例化创建销毁或者耗时耗资源的场景，如连接池、线程池。</p>
<p><strong>缺点</strong>：</p>
<p> 不适合有状态且需变更的</p>
<p><strong>实现方式</strong>：</p>
<p> <strong>饿汉式</strong>：线程安全速度快</p>
<p> <strong>懒汉式</strong>：双重检测锁，第一次减少锁的开销、第二次防止重复、volatile防止重排序导致实例化未完成</p>
<p> <strong>静态内部类</strong>：线程安全利用率高</p>
<p> <strong>枚举</strong>：effictiveJAVA推荐，反射也无法破坏</p>
<h4 id="2、工厂模式"><a href="#2、工厂模式" class="headerlink" title="2、工厂模式"></a>2、工厂模式</h4><p> 定义一个用于创建产品的接口，由子类决定生产何种产品。</p>
<p><strong>优点：</strong>解耦：提供参数即可获取产品，通过配置文件可以不修改代码增加具体产品。</p>
<p><strong>缺点：</strong>每增加一个产品就得新增一个产品类</p>
<h4 id="3、抽象工厂模式"><a href="#3、抽象工厂模式" class="headerlink" title="3、抽象工厂模式"></a>3、抽象工厂模式</h4><p> 提供一个接口，用于创建相关或者依赖对象的家族，并由此进行约束。</p>
<p><strong>优点：</strong>可以在类的内部对产品族进行约束</p>
<p><strong>缺点</strong>：假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。</p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法可以被重载，只有当类中没有显性声明任何构造方法时，才会有默认构造方法。</p>
<p>构造方法没有返回值，构造方法的作用是创建新对象。</p>
<h3 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h3><p>静态初始化块的优先级最高，会最先执行，在非静态初始化块之前执行。</p>
<p>静态初始化块会在类第一次被加载时最先执行，因此在 main 方法之前。</p>
<h3 id="This"><a href="#This" class="headerlink" title="This"></a>This</h3><p>关键字 <code>this</code> 代表当前对象的引用。当前对象指的是调用类中的属性或方法的对象</p>
<p>关键字 <code>this</code> 不可以在静态方法中使用。静态方法不依赖于类的具体对象的引用</p>
<h3 id="重写Override和重载Overload的区别"><a href="#重写Override和重载Overload的区别" class="headerlink" title="重写Override和重载Overload的区别"></a><strong>重写Override和重载Overload的区别</strong></h3><p>重载指在同一个类中定义多个方法，这些方法名称相同，签名不同。**(参数列表必须改，其他无要求)**</p>
<p>重写指在子类中的方法的名称和签名都和父类相同，使用override注解。**(参数和返回不能改，其他不能升级)**</p>
<table>
<thead>
<tr>
<th align="left">区别点</th>
<th align="left">重载方法</th>
<th align="left">重写方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">参数列表</td>
<td align="left">必须修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">返回类型</td>
<td align="left">可以修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">异常</td>
<td align="left">可以修改</td>
<td align="left">可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td align="left">访问</td>
<td align="left">可以修改</td>
<td align="left">一定不能做更严格的限制（可以降低限制）</td>
</tr>
</tbody></table>
<h3 id="Object类方法"><a href="#Object类方法" class="headerlink" title="Object类方法"></a>Object类方法</h3><p><strong>toString</strong> 默认是个指针，一般需要重写</p>
<p><strong>equals</strong> 比较对象是否相同，默认和==功能一致</p>
<p><strong>hashCode</strong> 散列码，equals则hashCode相同，所以重写equals必须重写hashCode</p>
<p>**finalize ** 用于垃圾回收之前做的遗嘱，默认空，子类需重写</p>
<p><strong>clone</strong> 深拷贝，类需实现cloneable的接口</p>
<p><strong>getClass</strong> 反射获取对象元数据，包括类名、方法、</p>
<p><strong>notify、wait</strong> 用于线程通知和唤醒</p>
<h3 id="基本数据类型和包装类"><a href="#基本数据类型和包装类" class="headerlink" title="基本数据类型和包装类"></a>基本数据类型和包装类</h3><p><img src="/2022/01/10/Java/008eGmZEly1goe1gq2yipj318s0ruwj4.jpg" alt="image-20210309224910999"></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>缓存范围</th>
</tr>
</thead>
<tbody><tr>
<td>Byte,Short,Integer,Long</td>
<td>[-128, 127]</td>
</tr>
<tr>
<td>Character</td>
<td>[0, 127]</td>
</tr>
<tr>
<td>Boolean</td>
<td>[false, true]</td>
</tr>
</tbody></table>
<h1 id="JVM-DOC-DataType"><a href="#JVM-DOC-DataType" class="headerlink" title="JVM-DOC-DataType"></a><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.2">JVM-DOC-DataType</a></h1><p> <em>primitive values</em> and <em>reference values</em>.</p>
<h2 id="2-3-Primitive-Types-and-Values"><a href="#2-3-Primitive-Types-and-Values" class="headerlink" title="2.3. Primitive Types and Values"></a>2.3. Primitive Types and Values</h2><p>The primitive data types supported by the Java Virtual Machine are the <em>numeric types</em>, the <code>boolean</code> type (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3.4">§2.3.4</a>), and the <code>returnAddress</code> type (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3.3">§2.3.3</a>).</p>
<p>The numeric types consist of the <em>integral types</em> (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3.1">§2.3.1</a>) and the <em>floating-point types</em> (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3.2">§2.3.2</a>).</p>
<p>The integral types are:</p>
<ul>
<li><code>byte</code>, whose values are 8-bit signed two’s-complement integers, and whose default value is zero</li>
<li><code>short</code>, whose values are 16-bit signed two’s-complement integers, and whose default value is zero</li>
<li><code>int</code>, whose values are 32-bit signed two’s-complement integers, and whose default value is zero</li>
<li><code>long</code>, whose values are 64-bit signed two’s-complement integers, and whose default value is zero</li>
<li><code>char</code>, whose values are 16-bit unsigned integers representing Unicode code points in the Basic Multilingual Plane, encoded with UTF-16, and whose default value is the null code point (<code>&#39;\u0000&#39;</code>)</li>
</ul>
<p>The floating-point types are:</p>
<ul>
<li><code>float</code>, whose values are elements of the float value set or, where supported, the float-extended-exponent value set, and whose default value is positive zero</li>
<li><code>double</code>, whose values are elements of the double value set or, where supported, the double-extended-exponent value set, and whose default value is positive zero</li>
</ul>
<h2 id="2-4-Reference-Types-and-Values"><a href="#2-4-Reference-Types-and-Values" class="headerlink" title="2.4. Reference Types and Values"></a>2.4. Reference Types and Values</h2><p>There are three kinds of <code>reference</code> types: <strong>class types, array types, and interface types</strong>. Their values are references to dynamically created class instances, arrays, or class instances or arrays that implement interfaces, respectively.</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Java</p><p><a href="http://example.com/2022/01/10/Java/">http://example.com/2022/01/10/Java/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>white crow</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2022-01-10</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-04-22</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/01/12/EventAndNestedScroll/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">EventAndNestedScroll</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/01/06/DNS/"><span class="level-item">DNS</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#final-amp-finalize"><span class="level-left"><span class="level-item">1</span><span class="level-item">final &amp; finalize()</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#final"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">final</span></span></a></li><li><a class="level is-mobile" href="#finalize"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">finalize()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Object"><span class="level-left"><span class="level-item">2</span><span class="level-item">Object</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#toString-NaN"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">.toString</span></span></a></li><li><a class="level is-mobile" href="#equal-amp-hashcode"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">equal &amp; hashcode</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#equals"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">equals</span></span></a></li><li><a class="level is-mobile" href="#hashcode"><span class="level-left"><span class="level-item">2.2.2</span><span class="level-item">hashcode</span></span></a></li></ul></li><li><a class="level is-mobile" href="#finalize-1"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">finalize()</span></span></a></li><li><a class="level is-mobile" href="#wait-amp-notify"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">wait() &amp; notify()</span></span></a></li><li><a class="level is-mobile" href="#getClass"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">getClass()</span></span></a></li><li><a class="level is-mobile" href="#clone"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">clone()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#面向对象"><span class="level-left"><span class="level-item">3</span><span class="level-item">面向对象</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#静态绑定与动态绑定，重载Overload与重写Override："><span class="level-left"><span class="level-item">3.1</span><span class="level-item">静态绑定与动态绑定，重载Overload与重写Override：</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#重载"><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">重载</span></span></a></li><li><a class="level is-mobile" href="#多态"><span class="level-left"><span class="level-item">3.1.2</span><span class="level-item">多态</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#多态实现"><span class="level-left"><span class="level-item">3.1.2.1</span><span class="level-item">多态实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#附录：重写Override和重载Overload的区别"><span class="level-left"><span class="level-item">3.1.3</span><span class="level-item">附录：重写Override和重载Overload的区别</span></span></a></li><li><a class="level is-mobile" href="#面向对象三大特性"><span class="level-left"><span class="level-item">3.1.4</span><span class="level-item">面向对象三大特性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、Java与C-区别"><span class="level-left"><span class="level-item">3.1.4.1</span><span class="level-item">1、Java与C++区别</span></span></a></li><li><a class="level is-mobile" href="#2、多态实现原理"><span class="level-left"><span class="level-item">3.1.4.2</span><span class="level-item">2、多态实现原理</span></span></a></li><li><a class="level is-mobile" href="#3、static和final关键字"><span class="level-left"><span class="level-item">3.1.4.3</span><span class="level-item">3、static和final关键字</span></span></a></li><li><a class="level is-mobile" href="#4、抽象类和接口"><span class="level-left"><span class="level-item">3.1.4.4</span><span class="level-item">4、抽象类和接口</span></span></a></li><li><a class="level is-mobile" href="#5、泛型以及泛型擦除"><span class="level-left"><span class="level-item">3.1.4.5</span><span class="level-item">5、泛型以及泛型擦除</span></span></a></li><li><a class="level is-mobile" href="#6、反射原理以及使用场景"><span class="level-left"><span class="level-item">3.1.4.6</span><span class="level-item">6、反射原理以及使用场景</span></span></a></li><li><a class="level is-mobile" href="#7、Java异常体系"><span class="level-left"><span class="level-item">3.1.4.7</span><span class="level-item">7、Java异常体系</span></span></a></li></ul></li><li><a class="level is-mobile" href="#数据结构"><span class="level-left"><span class="level-item">3.1.5</span><span class="level-item">数据结构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、ArrayList和LinkedList"><span class="level-left"><span class="level-item">3.1.5.1</span><span class="level-item">1、ArrayList和LinkedList</span></span></a></li><li><a class="level is-mobile" href="#2、List遍历快速和安全失败"><span class="level-left"><span class="level-item">3.1.5.2</span><span class="level-item">2、List遍历快速和安全失败</span></span></a></li><li><a class="level is-mobile" href="#3、详细介绍HashMap"><span class="level-left"><span class="level-item">3.1.5.3</span><span class="level-item">3、详细介绍HashMap</span></span></a></li><li><a class="level is-mobile" href="#4、ConcurrentHashMap"><span class="level-left"><span class="level-item">3.1.5.4</span><span class="level-item">**4、ConcurrentHashMap **</span></span></a></li><li><a class="level is-mobile" href="#5、序列化和反序列化"><span class="level-left"><span class="level-item">3.1.5.5</span><span class="level-item">5、序列化和反序列化</span></span></a></li><li><a class="level is-mobile" href="#6、String"><span class="level-left"><span class="level-item">3.1.5.6</span><span class="level-item">6、String</span></span></a></li></ul></li><li><a class="level is-mobile" href="#设计模式与原则"><span class="level-left"><span class="level-item">3.1.6</span><span class="level-item">设计模式与原则</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、单例模式"><span class="level-left"><span class="level-item">3.1.6.1</span><span class="level-item">1、单例模式</span></span></a></li><li><a class="level is-mobile" href="#2、工厂模式"><span class="level-left"><span class="level-item">3.1.6.2</span><span class="level-item">2、工厂模式</span></span></a></li><li><a class="level is-mobile" href="#3、抽象工厂模式"><span class="level-left"><span class="level-item">3.1.6.3</span><span class="level-item">3、抽象工厂模式</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#面试题"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">面试题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#构造方法"><span class="level-left"><span class="level-item">3.2.1</span><span class="level-item">构造方法</span></span></a></li><li><a class="level is-mobile" href="#初始化块"><span class="level-left"><span class="level-item">3.2.2</span><span class="level-item">初始化块</span></span></a></li><li><a class="level is-mobile" href="#This"><span class="level-left"><span class="level-item">3.2.3</span><span class="level-item">This</span></span></a></li><li><a class="level is-mobile" href="#重写Override和重载Overload的区别"><span class="level-left"><span class="level-item">3.2.4</span><span class="level-item">重写Override和重载Overload的区别</span></span></a></li><li><a class="level is-mobile" href="#Object类方法"><span class="level-left"><span class="level-item">3.2.5</span><span class="level-item">Object类方法</span></span></a></li><li><a class="level is-mobile" href="#基本数据类型和包装类"><span class="level-left"><span class="level-item">3.2.6</span><span class="level-item">基本数据类型和包装类</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#JVM-DOC-DataType"><span class="level-left"><span class="level-item">4</span><span class="level-item">JVM-DOC-DataType</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-3-Primitive-Types-and-Values"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">2.3. Primitive Types and Values</span></span></a></li><li><a class="level is-mobile" href="#2-4-Reference-Types-and-Values"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">2.4. Reference Types and Values</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatarPng.png" alt="White Crow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">White Crow</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">80</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">4</p></a></div></div></nav></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a><p class="is-size-7"><span>&copy; 2025 white crow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://github.com/WhileCrow"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>