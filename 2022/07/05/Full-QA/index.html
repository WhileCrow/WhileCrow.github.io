<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Full-QA - Crow&#039;s Sky</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Crow&#039;s Sky"><meta name="msapplication-TileImage" content="/img/avatarCircle.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Crow&#039;s Sky"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="一、基础篇网络基础TCP三次握手 三次握手过程：  客户端——发送带有SYN标志的数据包——服务端 一次握手 Client进入syn_sent状态  服务端——发送带有SYN&amp;#x2F;ACK标志的数据包——客户端 二次握手 服务端进入syn_rcvd  客户端——发送带有ACK标志的数据包——服务端 三次握手 连接就进入Established状态"><meta property="og:type" content="blog"><meta property="og:title" content="Full-QA"><meta property="og:url" content="http://example.com/2022/07/05/Full-QA/"><meta property="og:site_name" content="Crow&#039;s Sky"><meta property="og:description" content="一、基础篇网络基础TCP三次握手 三次握手过程：  客户端——发送带有SYN标志的数据包——服务端 一次握手 Client进入syn_sent状态  服务端——发送带有SYN&amp;#x2F;ACK标志的数据包——客户端 二次握手 服务端进入syn_rcvd  客户端——发送带有ACK标志的数据包——服务端 三次握手 连接就进入Established状态"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/2022/07/05/Full-QA/27194088468_4cb0141fc8_b.jpg"><meta property="og:image" content="https://appwk.baidu.com/naapi/doc/view?ih=482&amp;o=png_6_0_0_176_917_504_247_892.979_1262.879&amp;iw=986&amp;ix=0&amp;iy=0&amp;aimw=986&amp;rn=1&amp;doc_id=182d935c3186bceb18e8bb77&amp;pn=1&amp;sign=b88bda03b9954e506622f97b8b2ae438&amp;type=1&amp;app_ver=2.9.8.2&amp;ua=bd_800_800_IncredibleS_2.9.8.2_2.3.7&amp;bid=1&amp;app_ua=IncredibleS&amp;uid=&amp;cuid=&amp;fr=3&amp;Bdi_bear=WIFI&amp;from=3_10000&amp;bduss=&amp;pid=1&amp;screen=800_800&amp;sys_ver=2.3.7"><meta property="og:image" content="http://example.com/2022/07/05/Full-QA/u=1614312792,1954581760&amp;fm=26&amp;gp=0.jpg"><meta property="og:image" content="http://example.com/2022/07/05/Full-QA/u=2733576797,55677727&amp;fm=26&amp;gp=0.jpg"><meta property="og:image" content="http://example.com/2022/07/05/Full-QA/u=3137389296,1222888772&amp;fm=26&amp;gp=0-20220705192915222.jpg"><meta property="og:image" content="http://example.com/2022/07/05/Full-QA/008eGmZEly1goe17hajvzj316d0lhju3-20220705192915153.jpg"><meta property="og:image" content="http://example.com/2022/07/05/Full-QA/CgpOIF5rDYmATP43AAB3coc0R64799-20220705192915222.png"><meta property="og:image" content="http://example.com/2022/07/05/Full-QA/u=1035283471,1167301443&amp;fm=26&amp;gp=0-20220705192915250.jpg"><meta property="og:image" content="http://example.com/2022/07/05/Full-QA/008eGmZEly1goe1gq2yipj318s0ruwj4-20220705192915250.jpg"><meta property="og:image" content="http://example.com/2022/07/05/Full-QA/008eGmZEly1gobgnw8m8uj30l10bejs4.jpg"><meta property="og:image" content="http://example.com/2022/07/05/Full-QA/008eGmZEly1gobnjl5glvj30l10h9jrt.jpg"><meta property="og:image" content="http://example.com/2022/07/05/Full-QA/008eGmZEly1gobnnbem87j30eq0cogmj.jpg"><meta property="og:image" content="http://example.com/2022/07/05/Full-QA/008eGmZEly1gobn5lh4f6j30hk08rjso.jpg"><meta property="og:image" content="http://example.com/2022/07/05/Full-QA/008eGmZEly1gobnmip32vj30l109q0t3.jpg"><meta property="og:image" content="http://example.com/2022/07/05/Full-QA/008eGmZEly1gobnjx3zcej30l10ctaat.jpg"><meta property="og:image" content="http://example.com/2022/07/05/Full-QA/Cgq2xl5xxGKAKBpeAAEw9Ifr07Y662.png"><meta property="og:image" content="http://example.com/2022/07/05/Full-QA/Ciqc1F_Qfy2ACkrLAAD2DLkc2qw212.png"><meta property="og:image" content="http://example.com/2022/07/05/Full-QA/Cgq2xl5zjxGAXOA-AABF0Dv8GMI518.png"><meta property="og:image" content="http://example.com/2022/07/05/Full-QA/CgpOIF4z1EiAFjNQAAAtVe5xjgQ999.png"><meta property="og:image" content="http://example.com/2022/07/05/Full-QA/CgoB5l3kzomAckv5AAAxf6FCPco696.png"><meta property="og:image" content="http://example.com/2022/07/05/Full-QA/Ciqah157DAiAK_DJAAC0JawhGp4730.png"><meta property="og:image" content="http://example.com/2022/07/05/Full-QA/Cgq2xl5Pld-AHFhJAADLtGXmSxc833.png"><meta property="og:image" content="http://example.com/2022/07/05/Full-QA/Cgq2xl54fTKALhevAAB_l3axT_o532.png"><meta property="article:published_time" content="2022-07-05T11:28:18.000Z"><meta property="article:modified_time" content="2024-03-25T07:35:03.056Z"><meta property="article:author" content="White Crow"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2022/07/05/Full-QA/27194088468_4cb0141fc8_b.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2022/07/05/Full-QA/"},"headline":"Full-QA","image":["http://example.com/2022/07/05/Full-QA/27194088468_4cb0141fc8_b.jpg","http://example.com/2022/07/05/Full-QA/u=1614312792,1954581760&fm=26&gp=0.jpg","http://example.com/2022/07/05/Full-QA/u=2733576797,55677727&fm=26&gp=0.jpg","http://example.com/2022/07/05/Full-QA/u=3137389296,1222888772&fm=26&gp=0-20220705192915222.jpg","http://example.com/2022/07/05/Full-QA/008eGmZEly1goe17hajvzj316d0lhju3-20220705192915153.jpg","http://example.com/2022/07/05/Full-QA/CgpOIF5rDYmATP43AAB3coc0R64799-20220705192915222.png","http://example.com/2022/07/05/Full-QA/u=1035283471,1167301443&fm=26&gp=0-20220705192915250.jpg","http://example.com/2022/07/05/Full-QA/008eGmZEly1goe1gq2yipj318s0ruwj4-20220705192915250.jpg","http://example.com/2022/07/05/Full-QA/008eGmZEly1gobgnw8m8uj30l10bejs4.jpg","http://example.com/2022/07/05/Full-QA/008eGmZEly1gobnjl5glvj30l10h9jrt.jpg","http://example.com/2022/07/05/Full-QA/008eGmZEly1gobnnbem87j30eq0cogmj.jpg","http://example.com/2022/07/05/Full-QA/008eGmZEly1gobn5lh4f6j30hk08rjso.jpg","http://example.com/2022/07/05/Full-QA/008eGmZEly1gobnmip32vj30l109q0t3.jpg","http://example.com/2022/07/05/Full-QA/008eGmZEly1gobnjx3zcej30l10ctaat.jpg","http://example.com/2022/07/05/Full-QA/Cgq2xl5xxGKAKBpeAAEw9Ifr07Y662.png","http://example.com/2022/07/05/Full-QA/Ciqc1F_Qfy2ACkrLAAD2DLkc2qw212.png","http://example.com/2022/07/05/Full-QA/Cgq2xl5zjxGAXOA-AABF0Dv8GMI518.png","http://example.com/2022/07/05/Full-QA/CgpOIF4z1EiAFjNQAAAtVe5xjgQ999.png","http://example.com/2022/07/05/Full-QA/CgoB5l3kzomAckv5AAAxf6FCPco696.png","http://example.com/2022/07/05/Full-QA/Ciqah157DAiAK_DJAAC0JawhGp4730.png","http://example.com/2022/07/05/Full-QA/Cgq2xl5Pld-AHFhJAADLtGXmSxc833.png","http://example.com/2022/07/05/Full-QA/Cgq2xl54fTKALhevAAB_l3axT_o532.png"],"datePublished":"2022-07-05T11:28:18.000Z","dateModified":"2024-03-25T07:35:03.056Z","author":{"@type":"Person","name":"white crow"},"publisher":{"@type":"Organization","name":"Crow's Sky","logo":{"@type":"ImageObject","url":"http://example.com/img/avatarCircle.png"}},"description":"一、基础篇网络基础TCP三次握手 三次握手过程：  客户端——发送带有SYN标志的数据包——服务端 一次握手 Client进入syn_sent状态  服务端——发送带有SYN&#x2F;ACK标志的数据包——客户端 二次握手 服务端进入syn_rcvd  客户端——发送带有ACK标志的数据包——服务端 三次握手 连接就进入Established状态"}</script><link rel="canonical" href="http://example.com/2022/07/05/Full-QA/"><link rel="icon" href="/img/avatarCircle.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/WhileCrow"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-10-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-07-05T11:28:18.000Z" title="7/5/2022, 7:28:18 PM">2022-07-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-25T07:35:03.056Z" title="3/25/2024, 3:35:03 PM">2024-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">3 hours read (About 27678 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">Full-QA</h1><div class="content"><h1 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h1><h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a><strong>TCP三次握手</strong></h3><p> <strong>三次握手过程：</strong></p>
<p> 客户端——发送带有SYN标志的数据包——服务端 <strong>一次握手</strong> Client进入syn_sent状态</p>
<p> 服务端——发送带有SYN/ACK标志的数据包——客户端 <strong>二次握手</strong> 服务端进入syn_rcvd</p>
<p> 客户端——发送带有ACK标志的数据包——服务端 <strong>三次握手</strong> 连接就进入Established状态</p>
<span id="more"></span>

<p> <strong>为什么三次：</strong></p>
<p> 主要是为了建立可靠的通信信道，保证客户端与服务端同时具备发送、接收数据的能力</p>
<p> <strong>为什么两次不行？</strong></p>
<p> 1、防止已失效的请求报文又传送到了服务端，建立了多余的链接，浪费资源</p>
<p> 2、 两次握手只能保证单向连接是畅通的。（为了实现可靠数据传输， TCP 协议的通信双方， 都必须维 护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方 相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤；如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认）</p>
<p>**TCP四次挥手过程 **</p>
<p><strong>四次挥手过程：</strong></p>
<p> 客户端——发送带有FIN标志的数据包——服务端，关闭与服务端的连接 ，客户端进入FIN-WAIT-1状态</p>
<p> 服务端收到这个 FIN，它发回⼀ 个 ACK，确认序号为收到的序号加1，服务端就进入了CLOSE-WAIT状态</p>
<p> 服务端——发送⼀个FIN数据包——客户端，关闭与客户端的连接，客户端就进入FIN-WAIT-2状态</p>
<p> 客户端收到这个 FIN，发回 ACK 报⽂确认，并将确认序号设置为收到序号加1，TIME-WAIT状态</p>
<p><strong>为什么四次：</strong></p>
<p> 因为需要确保客户端与服务端的数据能够完成传输。</p>
<p><strong>CLOSE-WAIT：</strong></p>
<p> 这种状态的含义其实是表示在等待关闭</p>
<p><strong>TIME-WAIT：</strong></p>
<p> 为了解决网络的丢包和网络不稳定所带来的其他问题，确保连接方能在时间范围内，关闭自己的连接</p>
<p><strong>如何查看TIME-WAIT状态的链接数量？</strong></p>
<p> netstat -an |grep TIME_WAIT|wc -l 查看连接数等待time_wait状态连接数</p>
<p><strong>为什么会TIME-WAIT过多？解决方法是怎样的？</strong></p>
<p> <strong>可能原因：</strong> 高并发短连接的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接</p>
<p> <strong>解决：</strong>负载均衡服务器；Web服务器首先关闭来自负载均衡服务器的连接</p>
<h4 id="1、OSI与TCP-IP-模型"><a href="#1、OSI与TCP-IP-模型" class="headerlink" title="1、OSI与TCP/IP 模型"></a><strong>1、OSI与TCP/IP 模型</strong></h4><p> OSI七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
<p> TCP/IP五层：物理层、数据链路层、网络层、传输层、应用层</p>
<h4 id="2、常见网络服务分层"><a href="#2、常见网络服务分层" class="headerlink" title="2、常见网络服务分层"></a><strong>2、常见网络服务分层</strong></h4><p> 应用层：HTTP、SMTP、DNS、FTP</p>
<p> 传输层：TCP 、UDP</p>
<p> 网络层：ICMP 、IP、路由器、防火墙</p>
<p> 数据链路层：网卡、网桥、交换机</p>
<p> 物理层：中继器、集线器</p>
<h4 id="3、TCP与UDP区别及场景"><a href="#3、TCP与UDP区别及场景" class="headerlink" title="3、TCP与UDP区别及场景"></a><strong>3、TCP与UDP区别及场景</strong></h4><table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>性能</th>
<th>应用过场景</th>
<th>首部字节</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>TCP</td>
<td>面向连接、可靠、字节流</td>
<td>传输效率慢、所需资源多</td>
<td>文件、邮件传输</td>
<td>20-60</td>
<td></td>
</tr>
<tr>
<td>UDP</td>
<td>无连接、不可靠、数据报文段</td>
<td>传输效率快、所需资源少</td>
<td>语音、视频、直播</td>
<td>8个字节</td>
<td></td>
</tr>
</tbody></table>
<p> <strong>基于TCP的协议：</strong>HTTP、FTP、SMTP</p>
<p> <strong>基于UDP的协议：</strong>RIP、DNS、SNMP</p>
<h4 id="4、TCP滑动窗口，拥塞控制"><a href="#4、TCP滑动窗口，拥塞控制" class="headerlink" title="4、TCP滑动窗口，拥塞控制"></a><strong>4、TCP滑动窗口，拥塞控制</strong></h4><p> <strong>TCP通过：</strong>应用数据分割、对数据包进行编号、校验和、流量控制、拥塞控制、超时重传等措施保证数据的可靠传输；</p>
<p> <strong>拥塞控制目的：</strong>为了防止过多的数据注入到网络中，避免网络中的路由器、链路过载</p>
<p> <strong>拥塞控制过程：</strong>TCP维护一个拥塞窗口，该窗口随着网络拥塞程度动态变化，通过慢开始、拥塞避免等算法减少网络拥塞的发生。</p>
<h4 id="5、TCP粘包原因和解决方法"><a href="#5、TCP粘包原因和解决方法" class="headerlink" title="5、TCP粘包原因和解决方法"></a><strong>5、TCP粘包原因和解决方法</strong></h4><p> <strong>TCP粘包是指</strong>：发送方发送的若干包数据到接收方接收时粘成一包</p>
<p> <strong>发送方原因：</strong></p>
<p> TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量）：</p>
<p> 收集多个小分组，在一个确认到来时一起发送、导致发送方可能会出现粘包问题</p>
<p> <strong>接收方原因：</strong></p>
<p> TCP将接收到的数据包保存在接收缓存里，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</p>
<p> <strong>解决粘包问题：</strong></p>
<p> 最本质原因在与接收对等方无法分辨消息与消息之间的边界在哪，通过使用某种方案给出边界，例如：</p>
<ul>
<li>发送定长包。每个消息的大小都是一样的，接收方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。</li>
<li>包尾加上\r\n标记。FTP协议正是这么做的。但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界。</li>
<li>包头加上包体长度。包头是定长的4个字节，说明了包体的长度。接收对等方先接收包体长度，依据包体长度来接收包体。</li>
</ul>
<h4 id="6、TCP、UDP报文格式"><a href="#6、TCP、UDP报文格式" class="headerlink" title="6、TCP、UDP报文格式"></a><strong>6、TCP、UDP报文格式</strong></h4><p> <strong>TCP报文格式：</strong></p>
<p><img src="/2022/07/05/Full-QA/27194088468_4cb0141fc8_b.jpg" alt="img"></p>
<p> <strong>源端口号和目的端口号</strong>：</p>
<p> 用于寻找发端和收端应用进程。这两个值加上ip首部源端ip地址和目的端ip地址唯一确定一个tcp连接。</p>
<p> <strong>序号字段：</strong></p>
<p> 序号用来标识从T C P发端向T C P收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节。如果将字节流看作在两个应用程序间的单向流动，则 T C P用序号对每个字节进行计数。序号是32 bit的无符号数，序号到达 2^32-1后又从0开始。</p>
<p>　　当建立一个新的连接时，SYN标志变1。序号字段包含由这个主机选择的该连接的初始序号ISN（Initial Sequence Number）。该主机要发送数据的第一个字节序号为这个ISN加1，因为SYN标志消耗了一个序号</p>
<p> <strong>确认序号</strong>：</p>
<p> 既然每个传输的字节都被计数，确认序号包含发送确认的一端所期望收到的下一个序号。因此，确认序号应当是上次已成功收到数据字节序号加 1。只有ACK标志为 1时确认序号字段才有效。发送ACK无需任何代价，因为 32 bit的确认序号字段和A C K标志一样，总是T C P首部的一部分。因此，我们看到一旦一个连接建立起来，这个字段总是被设置， ACK标志也总是被设置为1。TCP为应用层提供全双工服务。这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号。</p>
<p> <strong>首都长度</strong>：</p>
<p> 首部长度给出首部中 32 bit字的数目。需要这个值是因为任选字段的长度是可变的。这个字段占4 bit，因此T C P最多有6 0字节的首部。然而，没有任选字段，正常的长度是 2 0字节。</p>
<p> <strong>标志字段</strong>：在T C P首部中有 6个标志比特。它们中的多个可同时被设置为1.<br>　　URG紧急指针（u rgent pointer）有效<br>　　ACK确认序号有效。<br>　　PSH接收方应该尽快将这个报文段交给应用层。<br>　　RST重建连接。<br>　　SYN同步序号用来发起一个连接。这个标志和下一个标志将在第 1 8章介绍。<br>　　FIN发端完成发送任务。</p>
<p> <strong>窗口大小</strong>：</p>
<p> T C P的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端期望接收的字节。窗口大小是一个 16 bit字段，因而窗口大小最大为 65535字节。</p>
<p> <strong>检验和：</strong></p>
<p> 检验和覆盖了整个的 T C P报文段：T C P首部和T C P数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。</p>
<p> <strong>紧急指针</strong>：</p>
<p> 只有当URG标志置1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。 T C P的紧急方式是发送端向另一端发送紧急数据的一种方式。</p>
<p> <strong>选项</strong>：</p>
<p> 最常见的可选字段是最长报文大小，又称为 MSS (Maximum Segment Size)。每个连接方通常都在通信的第一个报文段（为建立连接而设置 S Y N标志的那个段）中指明这个选项。它指明本端所能接收的最大长度的报文段。</p>
<p> <strong>UDP报文格式：</strong></p>
<p><img src="https://appwk.baidu.com/naapi/doc/view?ih=482&o=png_6_0_0_176_917_504_247_892.979_1262.879&iw=986&ix=0&iy=0&aimw=986&rn=1&doc_id=182d935c3186bceb18e8bb77&pn=1&sign=b88bda03b9954e506622f97b8b2ae438&type=1&app_ver=2.9.8.2&ua=bd_800_800_IncredibleS_2.9.8.2_2.3.7&bid=1&app_ua=IncredibleS&uid=&cuid=&fr=3&Bdi_bear=WIFI&from=3_10000&bduss=&pid=1&screen=800_800&sys_ver=2.3.7" alt="img"></p>
<p> <strong>端口号</strong>：</p>
<p> 用来表示发送和接受进程。由于 I P层已经把I P数据报分配给T C P或U D P（根据I P首部中协议字段值），因此T C P端口号由T C P来查看，而 U D P端口号由UDP来查看。T C P端口号与UDP端口号是相互独立的。</p>
<p> <strong>长度</strong>：</p>
<p> UDP长度字段指的是UDP首部和UDP数据的字节长度。该字段的最小值为 8字节（发送一份0字节的UDP数据报是 O K）。</p>
<p> <strong>检验和</strong>：</p>
<p> UDP检验和是一个端到端的检验和。它由发送端计算，然后由接收端验证。其目的是为了发现UDP首部和数据在发送端到接收端之间发生的任何改动。</p>
<p> <strong>IP报文格式：</strong>普通的IP首部长为20个字节，除非含有可选项字段。</p>
<p><img src="/2022/07/05/Full-QA/u=1614312792,1954581760&fm=26&gp=0.jpg" alt="img"></p>
<p> <strong>4位版本</strong>：</p>
<p> 目前协议版本号是4，因此IP有时也称作IPV4.</p>
<p> <strong>4位首部长度</strong>：</p>
<p> 首部长度指的是首部占32bit字的数目，包括任何选项。由于它是一个4比特字段，因此首部长度最长为60个字节。</p>
<p> <strong>服务类型（TOS）</strong>：</p>
<p> 服务类型字段包括一个3bit的优先权字段（现在已经被忽略），4bit的TOS子字段和1bit未用位必须置0。4bit的TOS分别代表：最小时延，最大吞吐量，最高可靠性和最小费用。4bit中只能置其中1比特。如果所有4bit均为0，那么就意味着是一般服务。</p>
<p> <strong>总长度</strong>：</p>
<p> 总长度字段是指整个IP数据报的长度，以字节为单位。利用首部长度和总长度字段，就可以知道IP数据报中数据内容的起始位置和长度。由于该字段长16bit，所以IP数据报最长可达65535字节。当数据报被分片时，该字段的值也随着变化。</p>
<p> <strong>标识字段</strong>：</p>
<p> 标识字段唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。</p>
<p> <strong>生存时间</strong>：</p>
<p> TTL（time-to-live）生存时间字段设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。TTL的初始值由源主机设置（通常为 3 2或6 4），一旦经过一个处理它的路由器，它的值就减去 1。当该字段的值为 0时，数据报就被丢弃，并发送 ICMP 报文通知源主机。</p>
<p> <strong>首部检验和</strong>：</p>
<p> 首部检验和字段是根据 I P首部计算的检验和码。它不对首部后面的数据进行计算。 ICMP、IGMP、UDP和TCP在它们各自的首部中均含有同时覆盖首部和数据检验和码。</p>
<p> <strong>以太网报文格式：</strong></p>
<p><img src="/2022/07/05/Full-QA/u=2733576797,55677727&fm=26&gp=0.jpg" alt="img"></p>
<p> <strong>目的地址和源地址：</strong></p>
<p> 是指网卡的硬件地址（也叫MAC 地址），长度是48 位，是在网卡出厂时固化的。</p>
<p> <strong>数据：</strong></p>
<p> 以太网帧中的数据长度规定最小46 字节，最大1500 字节，ARP 和RARP 数据包的长度不够46 字节，要在后面补填充位。最大值1500 称为以太网的最大传输单元（MTU），不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包度大于拨号链路的MTU了，则需要对数据包进行分片fragmentation）。ifconfig 命令的输出中也有“MTU:1500”。注意，MTU 个概念指数据帧中有效载荷的最大长度，不包括帧首部的长度。</p>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a><strong>HTTP协议</strong></h3><h4 id="1、HTTP协议1-0-1-1-2-0"><a href="#1、HTTP协议1-0-1-1-2-0" class="headerlink" title="1、HTTP协议1.0_1.1_2.0"></a>1、HTTP协议1.0_1.1_2.0</h4><p> <strong>HTTP1.0：</strong>服务器处理完成后立即断开TCP连接（<strong>无连接</strong>），服务器不跟踪每个客户端也不记录过去的请求（<strong>无状态</strong>）</p>
<p> <strong>HTTP1.1：</strong>KeepAlived<strong>长连接</strong>避免了连接建立和释放的开销；通过Content-Length来判断当前请求数据是否已经全部接受（<strong>有状态</strong>）</p>
<p> <strong>HTTP2.0：</strong>引入二进制数据帧和流的概念，其中帧对数据进行顺序标识；因为有了序列，服务器可以<strong>并行</strong>的传输数据。</p>
<p> <strong>http1.0和http1.1的主要区别如下：</strong><br>​ 1、缓存处理：1.1添加更多的缓存控制策略（如：Entity tag，If-Match）<br>​ 2、网络连接的优化：1.1支持断点续传<br>​ 3、错误状态码的增多：1.1新增了24个错误状态响应码，丰富的错误码更加明确各个状态<br>​ 4、Host头处理：支持Host头域，不在以IP为请求方标志<br>​ 5、长连接：减少了建立和关闭连接的消耗和延迟。</p>
<p> <strong>http1.1和http2.0的主要区别：</strong><br>​ 1、新的传输格式：2.0使用二进制格式，1.0依然使用基于文本格式<br>​ 2、多路复用：连接共享，不同的request可以使用同一个连接传输（最后根据每个request上的id号组合成正常的请求）<br>​ 3、header压缩：由于1.X中header带有大量的信息，并且得重复传输，2.0使用encoder来减少需要传输的hearder大小<br>​ 4、服务端推送：同google的SPDUY（1.0的一种升级）一样</p>
<h4 id="2、HTTP与HTTPS之间的区别"><a href="#2、HTTP与HTTPS之间的区别" class="headerlink" title="2、HTTP与HTTPS之间的区别"></a>2、HTTP与HTTPS之间的区别</h4><p> <strong>HTTP与HTTPS之间的区别：</strong></p>
<table>
<thead>
<tr>
<th>HTTP</th>
<th>HTTPS</th>
</tr>
</thead>
<tbody><tr>
<td>默认端口80</td>
<td>HTTPS默认使用端口443</td>
</tr>
<tr>
<td>明文传输、数据未加密、安全性差</td>
<td>传输过程ssl加密、安全性较好</td>
</tr>
<tr>
<td>响应速度快、消耗资源少</td>
<td>响应速度较慢、消耗资源多、需要用到CA证书</td>
</tr>
</tbody></table>
<p> <strong>HTTPS链接建立的过程：</strong></p>
<p> 1.首先客户端先给服务器发送一个请求</p>
<p> 2.服务器发送一个SSL证书给客户端，内容包括：证书的发布机构、有效期、所有者、签名以及公钥</p>
<p> 3.客户端对发来的公钥进行真伪校验，校验为真则使用公钥对对称加密算法以及对称密钥进行加密</p>
<p> 4.服务器端使用私钥进行解密并使用对称密钥加密确认信息发送给客户端</p>
<p> 5.随后客户端和服务端就使用对称密钥进行信息传输</p>
<p> <strong>对称加密算法：</strong></p>
<p> 双方持有相同的密钥，且加密速度快，典型对称加密算法：DES、AES</p>
<p> <strong>非对称加密算法：</strong></p>
<p> 密钥成对出现（私钥、公钥），私钥只有自己知道，不在网络中传输；而公钥可以公开。相比对称加密速度较慢，典型的非对称加密算法有：RSA、DSA</p>
<h4 id="3、Get和Post请求区别"><a href="#3、Get和Post请求区别" class="headerlink" title="3、Get和Post请求区别"></a><strong>3、Get和Post请求区别</strong></h4><p><strong>HTTP请求：</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>向特定资源发送请求，查询数据，并返回实体</td>
</tr>
<tr>
<td>POST</td>
<td>向指定资源提交数据进行处理请求，可能会导致新的资源建立、已有资源修改</td>
</tr>
<tr>
<td>PUT</td>
<td>向服务器上传新的内容</td>
</tr>
<tr>
<td>HEAD</td>
<td>类似GET请求，返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除指定标识的资源</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>可以用来向服务器发送请求来测试服务器的功能性</td>
</tr>
<tr>
<td>TRACE</td>
<td>回显服务器收到的请求，用于测试或诊断</td>
</tr>
<tr>
<td>CONNECT</td>
<td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</td>
</tr>
</tbody></table>
<p><strong>get和Post区别：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>GET</th>
<th>POST</th>
</tr>
</thead>
<tbody><tr>
<td>可见性</td>
<td>数据在URL中对所有人可见</td>
<td>数据不会显示在URL中</td>
</tr>
<tr>
<td>安全性</td>
<td>与post相比，get的安全性较差，因为所 发送的数据是URL的一部分</td>
<td>安全，因为参数不会被保存在浏览器 历史或web服务器日志中</td>
</tr>
<tr>
<td>数据长度</td>
<td>受限制，最长2kb</td>
<td>无限制</td>
</tr>
<tr>
<td>编码类型</td>
<td>application/x-www-form-urlencoded</td>
<td>multipart/form-data</td>
</tr>
<tr>
<td>缓存</td>
<td>能被缓存</td>
<td>不能被缓存</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="4、HTTP常见响应状态码"><a href="#4、HTTP常见响应状态码" class="headerlink" title="4、HTTP常见响应状态码"></a><strong>4、HTTP常见响应状态码</strong></h4><p> 100：Continue — 继续。客户端应继续其请求。</p>
<p> 200：OK — 请求成功。一般用于GET与POST请求。</p>
<p> 301：Moved Permanently — 永久重定向。</p>
<p> 302：Found — 暂时重定向。</p>
<p> 400：Bad Request — 客户端请求的语法错误，服务器无法理解。</p>
<p> 403：Forbideen — 服务器理解请求客户端的请求，但是拒绝执行此请求。</p>
<p> 404：Not Found — 服务器无法根据客户端的请求找到资源（网页）。</p>
<p> 500：Internal Server Error — 服务器内部错误，无法完成请求。</p>
<p> 502：Bad Gateway — 作为网关或者代理服务器尝试执行请求时，从远程服务器接收到了无效的响应。</p>
<h4 id="5、重定向和转发区别"><a href="#5、重定向和转发区别" class="headerlink" title="5、重定向和转发区别"></a><strong>5、重定向和转发区别</strong></h4><p> <strong>重定向：redirect：</strong></p>
<p> 地址栏发生变化</p>
<p> 重定向可以访问其他站点（服务器）的资源</p>
<p> 重定向是两次请求。不能使用request对象来共享数据</p>
<p> <strong>转发：forward：</strong></p>
<p> 转发地址栏路径不变</p>
<p> 转发只能访问当前服务器下的资源</p>
<p> 转发是一次请求，可以使用request对象共享数据</p>
<h4 id="6、Cookie和Session区别。"><a href="#6、Cookie和Session区别。" class="headerlink" title="6、Cookie和Session区别。"></a><strong>6、Cookie和Session区别。</strong></h4><p> Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但两者有所区别：</p>
<p> Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<p> cookie不是很安全，别人可以分析存放在本地的COOKIE并进行欺骗,考虑到安全应当使用session。</p>
<p> Cookie ⼀般⽤来保存⽤户信息，Session 的主要作⽤就是通过服务端记录⽤户的状态</p>
<h3 id="浏览器输入URL过程"><a href="#浏览器输入URL过程" class="headerlink" title="浏览器输入URL过程"></a><strong>浏览器输入URL过程</strong></h3><p> <strong>过程：</strong>DNS解析、TCP连接、发送HTTP请求、服务器处理请求并返回HTTP报文、浏览器渲染、结束</p>
<table>
<thead>
<tr>
<th>过程</th>
<th>使用的协议</th>
</tr>
</thead>
<tbody><tr>
<td>1、浏览器查找域名DNS的IP地址 DNS查找过程（浏览器缓存、路由器缓存、DNS缓存）</td>
<td>DNS：获取域名对应的ip</td>
</tr>
<tr>
<td>2、根据ip建立TCP连接</td>
<td>TCP：与服务器建立连接</td>
</tr>
<tr>
<td>3、浏览器向服务器发送HTTP请求</td>
<td>HTTP：发送请求</td>
</tr>
<tr>
<td>4、服务器响应HTTP响应</td>
<td>HTTP</td>
</tr>
<tr>
<td>5、浏览器进行渲染</td>
<td></td>
</tr>
</tbody></table>
<h2 id="操作系统基础"><a href="#操作系统基础" class="headerlink" title="操作系统基础"></a><strong>操作系统基础</strong></h2><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a><strong>进程和线程的区别</strong></h3><p> <strong>进程：</strong>是资源分配的最小单位，一个进程可以有多个线程，多个线程共享进程的堆和方法区资源，不共享栈、程序计数器</p>
<p> <strong>线程：</strong>是任务调度和执行的最小单位，线程并行执行存在资源竞争和上下文切换的问题</p>
<p> <strong>协程：</strong>是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。</p>
<h4 id="1、进程间通信方式IPC"><a href="#1、进程间通信方式IPC" class="headerlink" title="1、进程间通信方式IPC"></a><strong>1、进程间通信方式IPC</strong></h4><p><strong>管道pipe：</strong></p>
<p> 亲缘关系使用匿名管道，非亲缘关系使用命名管道，管道遵循FIFO，半双工，数据只能单向通信；</p>
<p><strong>信号：</strong></p>
<p> 信号是一种比较复杂的通信方式，用户调用kill命令将信号发送给其他进程。</p>
<p><strong>消息队列：</strong></p>
<p> 消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点。</p>
<p><strong>共享内存(share memory)：</strong></p>
<ul>
<li>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</li>
<li>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</li>
</ul>
<p><strong>信号量(Semaphores) ：</strong></p>
<p> 信号量是⼀个计数器，⽤于多进程对共享数据的访问，这种通信⽅式主要⽤于解决与同步相关的问题并避免竞争条件。</p>
<p><strong>套接字(Sockets) :</strong></p>
<p> 简单的说就是通信的两⽅的⼀种约定，⽤套接字中的相关函数来完成通信过程。</p>
<h4 id="2、用户态和核心态"><a href="#2、用户态和核心态" class="headerlink" title="2、用户态和核心态"></a><strong>2、用户态和核心态</strong></h4><p><strong>用户态：</strong>只能受限的访问内存，运行所有的应用程序</p>
<p><strong>核心态：</strong>运行操作系统程序，cpu可以访问内存的所有数据，包括外围设备</p>
<p><strong>为什么要有用户态和内核态：</strong></p>
<p> 由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络</p>
<p><strong>用户态切换到内核态的3种方式：</strong></p>
<p> <strong>a. 系统调用</strong></p>
<p> 主动调用，系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p>
<p> <strong>b. 异常</strong></p>
<p> 当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，比如缺页异常，这时会触发切换内核态处理异常。</p>
<p> <strong>c. 外围设备的中断</strong></p>
<p> 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会由用户态到内核态的切换。</p>
<h4 id="3、操作系统的进程空间"><a href="#3、操作系统的进程空间" class="headerlink" title="3、操作系统的进程空间"></a><strong>3、操作系统的进程空间</strong></h4><p> 栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。</p>
<p> 堆区（heap）— 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。</p>
<p> 静态区（static）—存放全局变量和静态变量的存储</p>
<p> 代码区(text)—存放函数体的二进制代码。</p>
<p> <strong>线程共享堆区、静态区</strong></p>
<h3 id="操作系统内存管理"><a href="#操作系统内存管理" class="headerlink" title="操作系统内存管理"></a>操作系统内存管理</h3><p><strong>存管理方式：</strong>页式管理、段式管理、段页式管理</p>
<p><strong>分段管理：</strong></p>
<p> 将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）</p>
<p><strong>分页管理：</strong></p>
<p> 在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的页框，程序加载时，可以将任意一页放入内存中任意一个页框，这些页框不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）</p>
<p><strong>段页式管理：</strong></p>
<p> 段⻚式管理机制结合了段式管理和⻚式管理的优点。简单来说段⻚式管理机制就是把主存先分成若⼲段，每个段⼜分成若⼲⻚，也就是说 段⻚式管理机制 中段与段之间以及段的内部的都是离散的</p>
<h4 id="1、页面置换算法FIFO、LRU"><a href="#1、页面置换算法FIFO、LRU" class="headerlink" title="1、页面置换算法FIFO、LRU"></a><strong>1、页面置换算法FIFO、LRU</strong></h4><p><strong>置换算法：</strong>先进先出FIFO、最近最久未使用LRU、最佳置换算法OPT</p>
<p><strong>先进先出FIFO:</strong></p>
<p> 缺点：没有考虑到实际的页面使用频率，性能差、与通常页面使用的规则不符合，实际应用较少</p>
<p><strong>最近最久未使用LRU:</strong></p>
<p> 原理：选择最近且最久未使用的页面进行淘汰</p>
<p> 优点：考虑到了程序访问的时间局部性，有较好的性能，实际应用也比较多</p>
<p> 缺点：没有合适的算法，只有适合的算法，lFU、random都可以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: Java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: LRU最近最久未使用置换算法，通过LinkedHashMap实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Li</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-07-17 10:29</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;Integer,Integer&gt; cache;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;   <span class="comment">//容量大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *初始化构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        cache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(capacity);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//缓存中不存在此key，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(!cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = cache.get(key);</span><br><span class="line">        cache.remove(key);   <span class="comment">//先从链表中删除</span></span><br><span class="line">        cache.put(key,res);  <span class="comment">//再把该节点放到链表末尾处</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cache.containsKey(key)) &#123;</span><br><span class="line">            cache.remove(key); <span class="comment">//已经存在，在当前链表移除</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(capacity == cache.size()) &#123;</span><br><span class="line">            <span class="comment">//cache已满，删除链表头位置</span></span><br><span class="line">            Set&lt;Integer&gt; keySet = cache.keySet();</span><br><span class="line">            Iterator&lt;Integer&gt; iterator = keySet.iterator();</span><br><span class="line">            cache.remove(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        cache.put(key,value);  <span class="comment">//插入到链表末尾</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: Java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: LRU最近最久未使用置换算法，通过LinkedHashMap内部removeEldestEntry方法实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Li</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-07-17 10:59</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *初始化构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;Integer, Integer&gt;(capacity, <span class="number">0.75f</span>, <span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> size() &gt; capacity;  <span class="comment">// 容量大于capacity 时就删除</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回key对应的value值，若不存在，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> map.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最佳置换算法OPT:</strong></p>
<p> 原理：每次选择当前物理块中的页面在未来长时间不被访问的或未来不再使用的页面进行淘汰</p>
<p> 优点：具有较好的性能，可以保证获得最低的缺页率</p>
<p> 缺点：过于理想化，但是实际上无法实现（没办法预知未来的页面）</p>
<h4 id="2、死锁条件、解决方式。"><a href="#2、死锁条件、解决方式。" class="headerlink" title="2、死锁条件、解决方式。"></a><strong>2、死锁条件、解决方式。</strong></h4><p> 死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象；</p>
<p> <strong>死锁的条件：</strong></p>
<p> 互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待至占有该资源的进程释放该资源；</p>
<p> 请求与保持条件：进程获得一定的资源后，又对其他资源发出请求，阻塞过程中不会释放自己已经占有的资源</p>
<p> 非剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放</p>
<p> 循环等待条件：系统中若干进程组成环路，环路中每个进程都在等待相邻进程占用的资源</p>
<p> <strong>解决方法：</strong>破坏死锁的任意一条件</p>
<p> 乐观锁，破坏资源互斥条件，<strong>CAS</strong></p>
<p> 资源一次性分配，从而剥夺请求和保持条件、<strong>tryLock</strong></p>
<p> 可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件，<strong>数据库deadlock超时</strong></p>
<p> 资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，从而破坏环路等待的条件，<strong>转账场景</strong></p>
<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a><strong>Java基础</strong></h2><h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h3><p><strong>特性：</strong>封装、继承、多态</p>
<p> <strong>封装：</strong>对抽象的事物抽象化成一个对象，并对其对象的属性私有化，同时提供一些能被外界访问属性的方法；</p>
<p> <strong>继承</strong>：子类扩展新的数据域或功能，并复用父类的属性与功能，单继承，多实现；</p>
<p> <strong>多态：</strong>通过继承（多个⼦类对同⼀⽅法的重写）、也可以通过接⼝（实现接⼝并覆盖接⼝）</p>
<h4 id="1、Java与C-区别"><a href="#1、Java与C-区别" class="headerlink" title="1、Java与C++区别"></a><strong>1、Java与C++区别</strong></h4><p> 不同点：c++支持多继承，并且有指针的概念，由程序员自己管理内存；Java是单继承，可以用接口实现多继承，Java 不提供指针来直接访问内存，程序内存更加安全，并且Java有JVM⾃动内存管理机制，不需要程序员⼿动释放⽆⽤内存</p>
<h4 id="2、多态实现原理"><a href="#2、多态实现原理" class="headerlink" title="2、多态实现原理"></a><strong>2、多态实现原理</strong></h4><p>多态的底层实现是动态绑定，即在运行时才把方法调用与方法实现关联起来。</p>
<p><strong>静态绑定与动态绑定：</strong></p>
<p> 一种是在编译期确定，被称为静态分派，比如方法的重载；</p>
<p> 一种是在运行时确定，被称为动态分派，比如方法的覆盖（重写）和接口的实现。</p>
<p><strong>多态的实现</strong></p>
<p> 虚拟机栈中会存放当前方法调用的栈帧（局部变量表、操作栈、动态连接 、返回地址）。多态的实现过程，就是方法调用动态分派的过程，如果子类覆盖了父类的方法，则在多态调用中，动态绑定过程会首先确定实际类型是子类，从而先搜索到子类中的方法。这个过程便是方法覆盖的本质。</p>
<h4 id="3、static和final关键字"><a href="#3、static和final关键字" class="headerlink" title="3、static和final关键字"></a>3、static和final关键字</h4><p><strong>static：</strong>可以修饰属性、方法</p>
<p> <strong>static修饰属性：</strong></p>
<p> 类级别属性，所有对象共享一份，随着类的加载而加载（只加载一次），先于对象的创建；可以使用类名直接调用。</p>
<p> <strong>static修饰方法：</strong></p>
<p> 随着类的加载而加载；可以使用类名直接调用；静态方法中，只能调用静态的成员，不可用this；</p>
<p><strong>final：</strong>关键字主要⽤在三个地⽅：变量、⽅法、类。</p>
<p> <strong>final修饰变量：</strong></p>
<p> 如果是基本数据类型的变量，则其数值⼀旦在初始化之后便不能更改；</p>
<p> 如果是引⽤类型的变量，则在对其初始化之后便不能再让其指向另⼀个对象。</p>
<p> <strong>final修饰方法：</strong></p>
<p> 把⽅法锁定，以防任何继承类修改它的含义（重写）；类中所有的 private ⽅法都隐式地指定为 final。</p>
<p> <strong>final修饰类：</strong></p>
<p> final 修饰类时，表明这个类不能被继承。final 类中的所有成员⽅法都会被隐式地指定为 final ⽅法。</p>
<p>一个类不能被继承，除了final关键字之外，还有可以私有化构造器。（内部类无效）</p>
<h4 id="4、抽象类和接口"><a href="#4、抽象类和接口" class="headerlink" title="4、抽象类和接口"></a>4、抽象类和接口</h4><p><strong>抽象类：</strong>包含抽象方法的类，即使用abstract修饰的类；抽象类只能被继承，所以不能使用final修饰，抽象类不能被实例化，</p>
<p><strong>接口：</strong>接口是一个抽象类型，是抽象方法的集合，接口支持多继承，接口中定义的方法，默认是public abstract修饰的抽象方法</p>
<p><strong>相同点：</strong></p>
<p> ① 抽象类和接口都不能被实例化</p>
<p> ② 抽象类和接口都可以定义抽象方法，子类/实现类必须覆写这些抽象方法</p>
<p><strong>不同点：</strong></p>
<p> ① 抽象类有构造方法，接口没有构造方法</p>
<p> ③抽象类可以包含普通方法，接口中只能是public abstract修饰抽象方法（Java8之后可以）</p>
<p> ③ 抽象类只能单继承，接口可以多继承</p>
<p> ④ 抽象类可以定义各种类型的成员变量，接口中只能是public static final修饰的静态常量</p>
<p><strong>抽象类的使用场景：</strong></p>
<p> 既想约束子类具有共同的行为（但不再乎其如何实现），又想拥有缺省的方法，又能拥有实例变量</p>
<p><strong>接口的应用场景：</strong></p>
<p> 约束多个实现类具有统一的行为，但是不在乎每个实现类如何具体实现；实现类中各个功能之间可能没有任何联系</p>
<h4 id="5、泛型以及泛型擦除"><a href="#5、泛型以及泛型擦除" class="headerlink" title="5、泛型以及泛型擦除"></a>5、泛型以及泛型擦除</h4><p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/baoyinwang/article/details/107341997">https://blog.csdn.net/baoyinwang/article/details/107341997</a></p>
<p><strong>泛型：</strong></p>
<p> 泛型的本质是参数化类型。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。</p>
<p><strong>泛型擦除：</strong></p>
<p> Java的泛型是伪泛型，使用泛型的时候加上类型参数，在编译器编译生成的字节码的时候会去掉，这个过程成为类型擦除。</p>
<p> 如List等类型，在编译之后都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。</p>
<p>可以通过反射添加其它类型元素</p>
<h4 id="6、反射原理以及使用场景"><a href="#6、反射原理以及使用场景" class="headerlink" title="6、反射原理以及使用场景"></a><strong>6、反射原理以及使用场景</strong></h4><p><strong>Java反射：</strong></p>
<p> 是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且都能够调用它的任意一个方法；</p>
<p><strong>反射原理：</strong></p>
<p> 反射首先是能够获取到Java中的反射类的字节码，然后将字节码中的方法，变量，构造函数等映射成 相应的 Method、Filed、Constructor 等类</p>
<p> <strong>如何得到Class的实例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.类名.class(就是一份字节码)</span><br><span class="line">2.Class.forName(String className);根据一个类的全限定名来构建Class对象</span><br><span class="line">3.每一个对象多有getClass()方法:obj.getClass();返回对象的真实类型</span><br></pre></td></tr></table></figure>

<p><strong>使用场景：</strong></p>
<ul>
<li><p><strong>开发通用框架 -</strong> 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，需要根据配置文件运行时动态加载不同的对象或类，调用不同的方法。</p>
</li>
<li><p><strong>动态代理</strong> - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。</p>
<p>JDK：spring默认动态代理，需要实现接口</p>
<p>CGLIB：通过asm框架序列化字节流，可配置，性能差</p>
</li>
<li><p><strong>自定义注解</strong> - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。</p>
</li>
</ul>
<h4 id="7、Java异常体系"><a href="#7、Java异常体系" class="headerlink" title="7、Java异常体系"></a><strong>7、Java异常体系</strong></h4><p><img src="/2022/07/05/Full-QA/u=3137389296,1222888772&fm=26&gp=0-20220705192915222.jpg" alt="img"></p>
<p>Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception</p>
<p><strong>Error ：</strong></p>
<p> 是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。</p>
<p><strong>Exception 包含：RuntimeException 、CheckedException</strong></p>
<p>编程错误可以分成三类：语法错误、逻辑错误和运行错误。</p>
<p><strong>语法错误</strong>（也称编译错误）是在编译过程中出现的错误，由编译器检查发现语法错误</p>
<p><strong>逻辑错误</strong>指程序的执行结果与预期不符，可以通过调试定位并发现错误的原因</p>
<p><strong>运行错误</strong>是引起程序非正常终端的错误，需要通过异常处理的方式处理运行错误</p>
<p><strong>RuntimeException：</strong> 运行时异常，程序应该从逻辑角度尽可能避免这类异常的发生。</p>
<p> 如 NullPointerException 、 ClassCastException ；</p>
<p><strong>CheckedException：</strong>受检异常，程序使用trycatch进行捕捉处理</p>
<p> 如IOException、SQLException、NotFoundException；</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="/2022/07/05/Full-QA/008eGmZEly1goe17hajvzj316d0lhju3-20220705192915153.jpg" alt="JavaCollection"></p>
<h4 id="1、ArrayList和LinkedList"><a href="#1、ArrayList和LinkedList" class="headerlink" title="1、ArrayList和LinkedList"></a><strong>1、ArrayList和LinkedList</strong></h4><p><strong>ArrayList：</strong></p>
<p> 底层基于数组实现，支持对元素进行快速随机访问，适合随机查找和遍历，不适合插入和删除。（提一句实际上）<br>​ 默认初始大小为10，当数组容量不够时，会触发扩容机制（扩大到当前的1.5倍），需要将原来数组的数据复制到新的数组中；当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。</p>
<p><strong>LinkedList：</strong></p>
<p> 底层基于双向链表实现，适合数据的动态插入和删除；<br>​ 内部提供了 List 接口中没有定义的方法，用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。（比如jdk官方推荐使用基于linkedList的Deque进行堆栈操作）</p>
<p><strong>ArrayList与LinkedList区别：</strong></p>
<p> 都是线程不安全的，ArrayList 适用于查找的场景，LinkedList 适用于增加、删除多的场景</p>
<p><strong>实现线程安全：</strong></p>
<p> 可以使用原生的Vector，或者是Collections.synchronizedList(List list)函数返回一个线程安全的ArrayList集合。<br>​ 建议使用concurrent并发包下的<strong>CopyOnWriteArrayList</strong>的。</p>
<p> ①<strong>Vector:</strong> 底层通过synchronize修饰保证线程安全，效率较差</p>
<p> ②<strong>CopyOnWriteArrayList：</strong>写时加锁，使用了一种叫<strong>写时复制</strong>的方法；读操作是可以不用加锁的</p>
<h4 id="2、List遍历快速和安全失败"><a href="#2、List遍历快速和安全失败" class="headerlink" title="2、List遍历快速和安全失败"></a><strong>2、List遍历快速和安全失败</strong></h4><p><strong>①普通for循环遍历List删除指定元素</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(list.get(i) == <span class="number">5</span>) </span><br><span class="line">       list.remove(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>② 迭代遍历,用list.remove(i)方法删除元素</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Integer value = it.next();</span><br><span class="line">    <span class="keyword">if</span>(value == <span class="number">5</span>)&#123;</span><br><span class="line">        list.remove(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>③foreach遍历List删除元素</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integer i:list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">3</span>) list.remove(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>fail—fast：</strong>快速失败</p>
<p> 当异常产生时，直接抛出异常，程序终止;</p>
<p> fail-fast主要是体现在当我们在遍历集合元素的时候，经常会使用迭代器，但在迭代器遍历元素的过程中，如果集合的结构（modCount）被改变的话，就会抛出异常ConcurrentModificationException，防止继续遍历。这就是所谓的快速失败机制。</p>
<p><strong>fail—safe：</strong>安全失败</p>
<p>    采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发ConcurrentModificationException。</p>
<p>    缺点：基于拷贝内容的优点是避免了ConcurrentModificationException，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p>
<p>    场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p>
<h4 id="3、详细介绍HashMap"><a href="#3、详细介绍HashMap" class="headerlink" title="3、详细介绍HashMap"></a><strong>3、详细介绍HashMap</strong></h4><p>角度：数据结构+扩容情况+put查找的详细过程+哈希函数+容量为什么始终都是2^N，JDK1.7与1.8的区别。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9fe4cb316c05">https://www.jianshu.com/p/9fe4cb316c05</a></p>
<p><strong>数据结构：</strong></p>
<p> HashMap在底层数据结构上采用了数组＋链表＋红黑树，通过散列映射来存储键值对数据</p>
<p><strong>扩容情况：</strong></p>
<p> 默认的负载因子是0.75，如果数组中已经存储的元素个数大于数组长度的75%，将会引发扩容操作。</p>
<p> 【1】创建一个长度为原来数组长度<strong>两倍的新数组</strong>。</p>
<p> 【2】1.7采用Entry的重新hash运算，1.8采用高于与运算。</p>
<p><strong>put操作步骤：</strong></p>
<p><img src="/2022/07/05/Full-QA/CgpOIF5rDYmATP43AAB3coc0R64799-20220705192915222.png" alt="img"></p>
<p> 1、判断数组是否为空，为空进行初始化;</p>
<p> 2、不为空，则计算 key 的 hash 值，通过(n - 1) &amp; hash计算应当存放在数组中的下标 index;</p>
<p> 3、查看 table[index] 是否存在数据，没有数据就构造一个Node节点存放在 table[index] 中；</p>
<p> 4、存在数据，说明发生了hash冲突(存在二个节点key的hash值一样), 继续判断key是否相等，相等，用新的value替换原数据；</p>
<p> 5、若不相等，判断当前节点类型是不是树型节点，如果是树型节点，创造树型节点插入红黑树中；</p>
<p> 6、若不是红黑树，创建普通Node加入链表中；判断链表长度是否大于 8，大于则将链表转换为红黑树；</p>
<p> 7、插入完成之后判断当前节点数是否大于阈值，若大于，则扩容为原数组的二倍</p>
<p><strong>哈希函数：</strong></p>
<p> 通过hash函数（优质因子31循环累加）先拿到 key 的hashcode，是一个32位的值，然后让hashcode的高16位和低16位进行<strong>异或</strong>操作。该函数也称为扰动函数，做到尽可能降低hash碰撞，通过尾插法进行插入。</p>
<p><strong>容量为什么始终都是2^N：</strong></p>
<p> 先做对数组的⻓度取模运算，得到的余数才能⽤来要存放的位置也就是对应的数组下标。这个数组下标的计算⽅法是“ (n - 1) &amp; hash ”。（n代表数组⻓度）。方便数组的扩容和增删改时的取模。</p>
<p><strong>JDK1.7与1.8的区别：</strong></p>
<p><strong>JDK1.7 HashMap：</strong></p>
<p> 底层是 <strong>数组和链表</strong> 结合在⼀起使⽤也就是链表散列。如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。扩容翻转时顺序不一致使用头插法会产生死循环，导致cpu100%</p>
<p><strong>JDK1.8 HashMap：</strong></p>
<p> 底层数据结构上采用了<strong>数组＋链表＋红黑树</strong>；当链表⻓度⼤于阈值（默认为 8-泊松分布），数组的⻓度大于 64时，链表将转化为红⿊树，以减少搜索时间。（解决了tomcat臭名昭著的url参数dos攻击问题）</p>
<h4 id="4、ConcurrentHashMap"><a href="#4、ConcurrentHashMap" class="headerlink" title="**4、ConcurrentHashMap **"></a>**4、ConcurrentHashMap **</h4><p> 可以通过<strong>ConcurrentHashMap</strong> 和 <strong>Hashtable</strong>来实现线程安全；Hashtable 是原始API类，通过synchronize同步修饰，效率低下；ConcurrentHashMap 通过分段锁实现，效率较比Hashtable要好；</p>
<p><strong>ConcurrentHashMap的底层实现：</strong></p>
<p> <strong>JDK1.7的 ConcurrentHashMap</strong> 底层采⽤ 分段的数组+链表 实现；采用 <strong>分段锁</strong>（Sagment） 对整个桶数组进⾏了分割分段(Segment默认16个)，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数据段的数据，就不会存在锁竞争，提⾼并发访问率。</p>
<p><img src="/2022/07/05/Full-QA/u=1035283471,1167301443&fm=26&gp=0-20220705192915250.jpg" alt="img"></p>
<p> <strong>JDK1.8的 ConcurrentHashMap</strong> 采⽤的数据结构跟HashMap1.8的结构⼀样，数组+链表/红⿊树；摒弃了Segment的概念，⽽是直接⽤ Node 数组+链表+红⿊树的数据结构来实现，通过并发控制 <strong>synchronized 和CAS</strong>来操作保证线程的安全。</p>
<h4 id="5、序列化和反序列化"><a href="#5、序列化和反序列化" class="headerlink" title="5、序列化和反序列化"></a><strong>5、序列化和反序列化</strong></h4><p> 序列化的意思就是将对象的状态转化成字节流，以后可以通过这些值再生成相同状态的对象。对象序列化是对象持久化的一种实现方法，它是将对象的属性和方法转化为一种序列化的形式用于存储和传输。反序列化就是根据这些保存的信息重建对象的过程。</p>
<p><strong>序列化：</strong>将java对象转化为字节序列的过程。</p>
<p><strong>反序列化：</strong>将字节序列转化为java对象的过程。</p>
<p><strong>优点：</strong></p>
<p> a、实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里）Redis的RDB</p>
<p> b、利用序列化实现远程通信，即在网络上传送对象的字节序列。 Google的protoBuf</p>
<p><strong>反序列化失败的场景：</strong></p>
<p> 序列化ID：serialVersionUID不一致的时候，导致反序列化失败</p>
<h4 id="6、String"><a href="#6、String" class="headerlink" title="6、String"></a><strong>6、String</strong></h4><p>String 使用<strong>数组</strong>存储内容，数组使用 <strong>final</strong> 修饰，因此 String 定义的字符串的值也是<strong>不可变的</strong></p>
<p>StringBuffer 对方法加了同步锁，线程安全，效率略低于 StringBuilder</p>
<h3 id="设计模式与原则"><a href="#设计模式与原则" class="headerlink" title="设计模式与原则"></a>设计模式与原则</h3><h4 id="1、单例模式"><a href="#1、单例模式" class="headerlink" title="1、单例模式"></a>1、单例模式</h4><p> 某个类只能生成一个实例，该实例全局访问，例如Spring容器里一级缓存里的单例池。</p>
<p><strong>优点</strong>：</p>
<p> <strong>唯一访问</strong>：如生成唯一序列化的场景、或者spring默认的bean类型。</p>
<p> <strong>提高性能</strong>：频繁实例化创建销毁或者耗时耗资源的场景，如连接池、线程池。</p>
<p><strong>缺点</strong>：</p>
<p> 不适合有状态且需变更的</p>
<p><strong>实现方式</strong>：</p>
<p> <strong>饿汉式</strong>：线程安全速度快</p>
<p> <strong>懒汉式</strong>：双重检测锁，第一次减少锁的开销、第二次防止重复、volatile防止重排序导致实例化未完成</p>
<p> <strong>静态内部类</strong>：线程安全利用率高</p>
<p> <strong>枚举</strong>：effictiveJAVA推荐，反射也无法破坏</p>
<h4 id="2、工厂模式"><a href="#2、工厂模式" class="headerlink" title="2、工厂模式"></a>2、工厂模式</h4><p> 定义一个用于创建产品的接口，由子类决定生产何种产品。</p>
<p><strong>优点：</strong>解耦：提供参数即可获取产品，通过配置文件可以不修改代码增加具体产品。</p>
<p><strong>缺点：</strong>每增加一个产品就得新增一个产品类</p>
<h4 id="3、抽象工厂模式"><a href="#3、抽象工厂模式" class="headerlink" title="3、抽象工厂模式"></a>3、抽象工厂模式</h4><p> 提供一个接口，用于创建相关或者依赖对象的家族，并由此进行约束。</p>
<p><strong>优点：</strong>可以在类的内部对产品族进行约束</p>
<p><strong>缺点</strong>：假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。</p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法可以被重载，只有当类中没有显性声明任何构造方法时，才会有默认构造方法。</p>
<p>构造方法没有返回值，构造方法的作用是创建新对象。</p>
<h3 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h3><p>静态初始化块的优先级最高，会最先执行，在非静态初始化块之前执行。</p>
<p>静态初始化块会在类第一次被加载时最先执行，因此在 main 方法之前。</p>
<h3 id="This"><a href="#This" class="headerlink" title="This"></a>This</h3><p>关键字 <code>this</code> 代表当前对象的引用。当前对象指的是调用类中的属性或方法的对象</p>
<p>关键字 <code>this</code> 不可以在静态方法中使用。静态方法不依赖于类的具体对象的引用</p>
<h3 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a><strong>重写和重载的区别</strong></h3><p>重载指在同一个类中定义多个方法，这些方法名称相同，签名不同。</p>
<p>重写指在子类中的方法的名称和签名都和父类相同，使用override注解</p>
<h3 id="Object类方法"><a href="#Object类方法" class="headerlink" title="Object类方法"></a>Object类方法</h3><p><strong>toString</strong> 默认是个指针，一般需要重写，未重写情况下，返回 </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getClass().getName() + &#39;@&#39; + Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure>

<p><strong>equals</strong> 比较对象是否相同，默认和==功能一致</p>
<p><strong>hashCode</strong> 散列码，equals则hashCode相同，所以重写equals必须重写hashCode</p>
<p>**finalize ** 用于垃圾回收之前做的遗嘱，默认空，子类需重写</p>
<p><strong>clone</strong> 深拷贝，类需实现cloneable的接口</p>
<p><strong>getClass</strong> 反射获取对象元数据，包括类名、方法、</p>
<p><strong>notify、wait</strong> 用于线程通知和唤醒</p>
<h3 id="基本数据类型和包装类"><a href="#基本数据类型和包装类" class="headerlink" title="基本数据类型和包装类"></a>基本数据类型和包装类</h3><p><img src="/2022/07/05/Full-QA/008eGmZEly1goe1gq2yipj318s0ruwj4-20220705192915250.jpg" alt="image-20210309224910999"></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>缓存范围</th>
</tr>
</thead>
<tbody><tr>
<td>Byte,Short,Integer,Long</td>
<td>[-128, 127]</td>
</tr>
<tr>
<td>Character</td>
<td>[0, 127]</td>
</tr>
<tr>
<td>Boolean</td>
<td>[false, true]</td>
</tr>
</tbody></table>
<h1 id="二、JVM篇"><a href="#二、JVM篇" class="headerlink" title="二、JVM篇"></a>二、JVM篇</h1><h3 id="JVM内存划分"><a href="#JVM内存划分" class="headerlink" title="JVM内存划分"></a><strong>JVM内存划分</strong></h3><h4 id="1、JVM运行时数据区域"><a href="#1、JVM运行时数据区域" class="headerlink" title="1、JVM运行时数据区域"></a><strong>1、JVM运行时数据区域</strong></h4><p> 堆、方法区（元空间）、虚拟机栈、本地方法栈、程序计数器</p>
<p><img src="/2022/07/05/Full-QA/008eGmZEly1gobgnw8m8uj30l10bejs4.jpg" alt="xxx"></p>
<p><strong>Heap(堆)：</strong></p>
<p> 对象的实例以及数组的内存都是要在堆上进行分配的，堆是线程共享的一块区域，用来存放对象实例，也是垃圾回收（GC）的主要区域；开启逃逸分析后，某些未逃逸的对象可以通过标量替换的方式在栈中分配</p>
<p> 堆细分：新生代、老年代，对于新生代又分为：<strong>Eden区</strong>和<strong>Surviver1</strong>和<strong>Surviver2</strong>区；</p>
<p><strong>方法区：</strong></p>
<p> 对于JVM的方法区也可以称之为永久区，它储存的是已经被java虚拟机加载的类信息、常量、静态变量；Jdk1.8以后取消了方法区这个概念，称之为元空间（MetaSpace）；</p>
<p> 当应用中的 Java 类过多时，比如 <strong>Spring 等一些使用动态代理的框架生成了很多类</strong>，如果占用空间超出了我们的设定值，就会发生<strong>元空间溢出</strong></p>
<p><strong>虚拟机栈：</strong></p>
<p> 虚拟机栈<strong>是线程私有的</strong>，他的生命周期和线程的生命周期是一致的。里面装的是一个一个的<strong>栈帧</strong>，每一个方法在执行的时候都会创建一个栈帧，栈帧中用来存放（<strong>局部变量表</strong>、<strong>操作数栈</strong> 、<strong>动态链接</strong> 、<strong>返回地址</strong>）；在Java虚拟机规范中，对此区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出<strong>StackOverflowError</strong>异常；如果虚拟机栈动态扩展时无法申请到足够的内存，就会抛出<strong>OutOfMemoryError</strong>异常。</p>
<ul>
<li><p><strong>局部变量表：</strong>局部变量表是一组变量值存储空间，用来存放<strong>方法参数</strong>、方法内部定义的<strong>局部变量</strong>。底层是变量槽（variable slot）</p>
</li>
<li><p><strong>操作数栈：</strong>是用来记录一个方法在执行的过程中，<strong>字节码指令向操作数栈中进行入栈和出栈的过程</strong>。大小在编译的时候已经确定了，当一个方法刚开始执行的时候，操作数栈中是空发的，在方法执行的过程中会有各种<strong>字节码指令</strong>往操作数栈中<strong>入栈和出栈</strong>。</p>
</li>
<li><p><strong>动态链接：</strong>因为字节码文件中有很多符号的引用，这些符号引用一部分会在<strong>类加载的解析阶段</strong>或<strong>第一次使用</strong>的时候转化成<strong>直接引用</strong>，这种称为<strong>静态解析</strong>；另一部分会<strong>在运行期间</strong>转化为直接引用，称为<strong>动态链接</strong>。</p>
</li>
<li><p><strong>返回地址（returnAddress）：</strong>类型（指向了一条字节码指令的地址）</p>
<p><strong>JIT即时编译器（Just In Time Compiler），简称 JIT 编译器</strong>:</p>
<p>为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，比如锁粗化等</p>
</li>
</ul>
<p><strong>本地方法栈：</strong></p>
<p> 本地方法栈和虚拟机栈类似，不同的是虚拟机栈服务的是Java方法，而<strong>本地方法栈服务的是Native方法</strong>。在HotSpot虚拟机实现中是把本地方法栈和虚拟机栈合二为一的，同理它也会抛出<strong>StackOverflowError</strong>和<strong>OOM</strong>异常。</p>
<p><strong>PC程序计数器：</strong></p>
<p> PC，指的是存放下一条指令的位置的一个指针。它是一块较小的内存空间，且是<strong>线程私有</strong>的。由于线程的切换，CPU在执行的过程中，需要记住原线程的下一条指令的位置，所以每一个线程都需要有自己的PC。</p>
<h4 id="2、堆内存分配策略"><a href="#2、堆内存分配策略" class="headerlink" title="2、堆内存分配策略"></a><strong>2、堆内存分配策略</strong></h4><p><img src="/2022/07/05/Full-QA/008eGmZEly1gobnjl5glvj30l10h9jrt.jpg" alt="img"></p>
<ul>
<li><p>对象优先分配在Eden区，如果Eden区没有足够的空间进行分配时，虚拟机执行一次MinorGC。而那些无需回收的存活对象，将会进到 Survivor 的 From 区（From 区内存不足时，直接进入 Old 区）。</p>
</li>
<li><p>大对象直接进入老年代（需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</p>
</li>
<li><p>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄（Age Count）计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，直到达到阀值（默认15次），对象进入老年区。</p>
<p>（<strong>动态对象年龄判定</strong>：程序从年龄最小的对象开始累加，如果累加的对象大小，大于幸存区的一半，则将当前的对象 age 作为新的阈值，年龄大于此阈值的对象则直接进入老年代）</p>
</li>
<li><p>每次进行Minor GC或者大对象直接进入老年区时，JVM会计算所需空间大小如小于老年区的剩余值大小，则进行一次<strong>Full GC</strong>。</p>
</li>
</ul>
<h4 id="3、创建一个对象的步骤"><a href="#3、创建一个对象的步骤" class="headerlink" title="3、创建一个对象的步骤"></a><strong>3、创建一个对象的步骤</strong></h4><p><strong>步骤：类加载检查、分配内存、初始化零值、设置对象头、执行init方法</strong></p>
<p><strong>①类加载检查：</strong></p>
<p> 虚拟机遇到 new 指令时，⾸先去检查是否能在常量池中定位到这个类的符号引⽤，并且检查这个符号引⽤代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执⾏相应的类加载过程。</p>
<p><strong>②分配内存：</strong></p>
<p> 在类加载检查通过后，接下来虚拟机将为新⽣对象分配内存，分配⽅式有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，选择那种分配⽅式由 Java 堆是否规整决定，⽽Java堆是否规整⼜由所采⽤的垃圾收集器是否带有压缩整理功能决定。</p>
<p><strong>③初始化零值：</strong></p>
<p> 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值，这⼀步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使⽤，程序能访问到这些字段的数据类型所对应的零值。</p>
<p><strong>④设置对象头：</strong></p>
<p> 初始化零值完成之后，虚拟机要对对象进⾏必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运⾏状态的不同，如是否启⽤偏向锁等，对象头会有不同的设置⽅式。</p>
<p><strong>⑤执⾏ init ⽅法：</strong></p>
<p> 从虚拟机的视⻆来看，⼀个新的对象已经产⽣了，但从Java 程序的视⻆来看， ⽅法还没有执⾏，所有的字段都还为零。所以⼀般来说（除循环依赖），执⾏ new 指令之后会接着执⾏ ⽅法，这样⼀个真正可⽤的对象才算产⽣出来。</p>
<h4 id="4、对象引用"><a href="#4、对象引用" class="headerlink" title="4、对象引用"></a>4、<strong>对象引用</strong></h4><p>普通的对象引用关系就是<strong>强引用</strong>。</p>
<p><strong>软引用</strong>用于维护一些可有可无的对象。只有在<strong>内存不足时，系统则会回收软引用对象</strong>，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。</p>
<p><strong>弱引用</strong>对象相比软引用来说，要更加无用一些，它拥有更短的生命周期，当 JVM 进行垃圾回收时，<strong>无论内存是否充足</strong>，都会回收被弱引用关联的对象。</p>
<p><strong>虚引用</strong>是一种形同虚设的引用，在现实场景中用的不是很多，它主要用来<strong>跟踪对象被垃圾回收</strong>的活动。</p>
<h3 id="JVM类加载过程"><a href="#JVM类加载过程" class="headerlink" title="JVM类加载过程"></a><strong>JVM类加载过程</strong></h3><p><strong>过程：加载、验证、准备、解析、初始化</strong></p>
<p><img src="/2022/07/05/Full-QA/008eGmZEly1gobnnbem87j30eq0cogmj.jpg" alt="img"></p>
<p><strong>加载阶段：</strong></p>
<p> 1.通过一个类的全限定名来获取定义此类的二进制字节流。</p>
<p> 2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p>
<p> 3.在Java堆中生成一个代表这个类的java.lang.class对象，作为方法区这些数据的访问入口。</p>
<p><strong>验证阶段：</strong></p>
<p> 1.文件格式验证（是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理）</p>
<p> 2.元数据验证（对字节码描述的信息进行语意分析，以保证其描述的信息符合Java语言规范要求）</p>
<p> 3.字节码验证（保证被校验类的方法在运行时不会做出危害虚拟机安全的行为）</p>
<p> 4.符号引用验证（虚拟机将符号引用转化为直接引用时，解析阶段中发生）</p>
<p><strong>准备阶段：</strong></p>
<p> 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。将对象初始化为“零”值</p>
<p><strong>解析阶段：</strong></p>
<p> 解析阶段时虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p> <strong>字符串常量池</strong>：堆上，默认class文件的静态常量池</p>
<p> <strong>运行时常量池</strong>：在方法区，属于元空间</p>
<p><strong>初始化阶段：</strong></p>
<p> 初始化阶段时加载过程的最后一步，而这一阶段也是真正意义上开始执行类中定义的Java程序代码。</p>
<h4 id="1、双亲委派机制"><a href="#1、双亲委派机制" class="headerlink" title="1、双亲委派机制"></a><strong>1、双亲委派机制</strong></h4><p> 每⼀个类都有⼀个对应它的类加载器。系统中的 ClassLoder 在协同⼯作的时候会默认使⽤ 双亲委派模型 。即在类加载的时候，系统会⾸先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，⾸先会把该请求委派该⽗类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当⽗类加载器⽆法处理时，才由⾃⼰来处理。当⽗类加载器为null时，会使⽤启动类加载器 BootstrapClassLoader 作为⽗类加载器。</p>
<p><img src="/2022/07/05/Full-QA/008eGmZEly1gobn5lh4f6j30hk08rjso.jpg" alt="img"></p>
<p><strong>使用好处：</strong></p>
<p> 此机制保证JDK核心类的优先加载；使得Java程序的稳定运⾏，可以避免类的重复加载，也保证了 Java 的核⼼ API 不被篡改。如果不⽤没有使⽤双亲委派模型，⽽是每个类加载器加载⾃⼰的话就会出现⼀些问题，⽐如我们编写⼀个称为 java.lang.Object 类的话，那么程序运⾏的时候，系统就会出现多个不同的Object 类。</p>
<p><strong>破坏双亲委派机制：</strong></p>
<ul>
<li>可以⾃⼰定义⼀个类加载器，重写loadClass方法；</li>
<li>Tomcat 可以加载自己目录下的 class 文件，并不会传递给父类的加载器；</li>
<li>Java 的 SPI，发起者 BootstrapClassLoader 已经是最上层了，它直接获取了 AppClassLoader 进行驱动加载，和双亲委派是相反的。</li>
</ul>
<h4 id="2、tomcat的类加载机制"><a href="#2、tomcat的类加载机制" class="headerlink" title="2、tomcat的类加载机制"></a><strong>2、tomcat的类加载机制</strong></h4><p><strong>步骤：</strong></p>
<ol>
<li>先在本地cache查找该类是否已经加载过，看看 Tomcat 有没有加载过这个类。</li>
<li>如果Tomcat 没有加载过这个类，则从系统类加载器的cache中查找是否加载过。</li>
<li>如果没有加载过这个类，尝试用ExtClassLoader类加载器类加载，重点来了，这里并没有首先使用 AppClassLoader 来加载类。这个Tomcat 的 WebAPPClassLoader 违背了双亲委派机制，直接使用了 ExtClassLoader来加载类。这里注意 ExtClassLoader 双亲委派依然有效，ExtClassLoader 就会使用 Bootstrap ClassLoader 来对类进行加载，保证了 Jre 里面的核心类不会被重复加载。 比如在 Web 中加载一个 Object 类。WebAppClassLoader → ExtClassLoader → Bootstrap ClassLoader，这个加载链，就保证了 Object 不会被重复加载。</li>
<li>如果 BoostrapClassLoader，没有加载成功，就会调用自己的 findClass 方法由自己来对类进行加载，findClass 加载类的地址是自己本 web 应用下的 class。</li>
<li>加载依然失败，才使用 AppClassLoader 继续加载。</li>
<li>都没有加载成功的话，抛出异常。</li>
</ol>
<p>总结一下以上步骤，WebAppClassLoader 加载类的时候，故意打破了JVM 双亲委派机制，绕开了 AppClassLoader，直接先使用 ExtClassLoader 来加载类。</p>
<h3 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h3><h4 id="1、存活算法和两次标记过程"><a href="#1、存活算法和两次标记过程" class="headerlink" title="1、存活算法和两次标记过程"></a><strong>1、存活算法和两次标记过程</strong></h4><p><strong>引用计数法：</strong></p>
<p> 给对象添加一个引用计数器，每当由一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
<p> 优点：实现简单，判定效率也很高</p>
<p> 缺点：他很难解决对象之间相互循环引用的问题，基本上被抛弃</p>
<p><strong>可达性分析法：</strong></p>
<p> 通过一系列的成为“GC Roots”(活动线程相关的各种引用，虚拟机<strong>栈帧引用</strong>，<strong>静态变量引用</strong>，<strong>JNI引用</strong>)的对象作为起始点，从这些节点ReferenceChains开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC ROOTS没有任何引用链相连时，则证明此对象时不可用的；</p>
<p><strong>两次标记过程：</strong></p>
<p> 对象被回收之前，该对象的finalize()方法会被调用；两次标记，即第一次标记不在“关系网”中的对象。第二次的话就要先判断该对象有没有实现finalize()方法了，如果没有实现就直接判断该对象可回收；如果实现了就会先放在一个队列中，并由虚拟机建立的一个低优先级的线程去执行它，随后就会进行第二次的小规模标记，在这次被标记的对象就会真正的被回收了。</p>
<h4 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a><strong>2、垃圾回收算法</strong></h4><p><strong>垃圾回收算法</strong>：复制算法、标记清除、标记整理、分代收集</p>
<p><strong>复制算法：(young)</strong></p>
<p> 将内存分为⼤⼩相同的两块，每次使⽤其中的⼀块。当这⼀块的内存使⽤完后，就将还存活的对象复制到另⼀块去，然后再把使⽤的空间⼀次清理掉。这样就使每次的内存回收都是对内存区间的⼀半进⾏回收；</p>
<p> 优点：实现简单，内存效率高，不易产生碎片</p>
<p> 缺点：内存压缩了一半，倘若存活对象多，Copying 算法的效率会大大降低</p>
<p><strong>标记清除：(cms)</strong></p>
<p> 标记出所有需要回收的对象，在标记完成后统⼀回收所有被标记的对象</p>
<p> 缺点：效率低，标记清除后会产⽣⼤量不连续的碎⽚，需要预留空间给分配阶段的浮动垃圾</p>
<p><strong>标记整理：(old)</strong></p>
<p> 标记过程仍然与“标记-清除”算法⼀样，再让所有存活的对象向⼀端移动，然后直接清理掉端边界以外的内存；解决了产生大量不连续碎片问题</p>
<p><strong>分代收集：</strong></p>
<p> 根据各个年代的特点选择合适的垃圾收集算法。</p>
<p> 新生代采用复制算法，新生代每次垃圾回收都要回收大部分对象，存活对象较少，即要复制的操作比较少，一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。</p>
<p> 老年代的对象存活⼏率是⽐较⾼的，⽽且没有额外的空间对它进⾏分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进⾏垃圾收集。</p>
<p><strong>Safepoint</strong> 当发生 GC 时，用户线程必须全部停下来，才可以进行垃圾回收，这个状态我们可以认为 JVM 是安全的（safe），整个堆的状态是稳定的。如果在 GC 前，有线程迟迟进入不了 safepoint，那么整个 JVM 都在等待这个阻塞的线程，造成了整体 GC 的时间变长</p>
<p><img src="/2022/07/05/Full-QA/008eGmZEly1gobnmip32vj30l109q0t3.jpg" alt="img"></p>
<h5 id="MinorGC、MajorGC、FullGC"><a href="#MinorGC、MajorGC、FullGC" class="headerlink" title="MinorGC、MajorGC、FullGC"></a><strong>MinorGC、MajorGC、FullGC</strong></h5><p><strong>MinorGC</strong> 在年轻代空间不足的时候发生，</p>
<p><strong>MajorGC</strong> 指的是老年代的 GC，出现 MajorGC 一般经常伴有 MinorGC。</p>
<p><strong>FullGC</strong> 1、当老年代无法再分配内存的时候；2、元空间不足的时候；3、显示调用 System.gc 的时候。另外，像 CMS 一类的垃圾回收器，在 MinorGC 出现 promotion failure 的时候也会发生 FullGC。</p>
<p><strong>对象优先在 Eden 区分配</strong><br>大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。</p>
<p><strong>大对象直接进入老年代</strong><br>大对象是指需要连续内存空间的对象，比如很长的字符串以及数组。老年代直接分配的<strong>目的是</strong>避免在 Eden 区和 Survivor 区之间出现大量内存复制。</p>
<p><strong>长期存活的对象进入老年代</strong><br>虚拟机给每个对象定义了年龄计数器，对象在 Eden 区出生之后，如果经过一次 Minor GC 之后，将进入 Survivor 区，同时对象年龄变为 1，增加到一定阈值时则进入老年代（阈值默认为 15）</p>
<p><strong>动态对象年龄判定</strong><br>为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到阈值才能进入老年代。如果在 Survivor 区中相同年龄的所有对象的空间总和大于 Survivor 区空间的一半，则年龄大于或等于该年龄的对象直接进入老年代。</p>
<p><strong>空间分配担保</strong><br>在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的空间总和，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立则进行 Full GC。</p>
<h4 id="3、垃圾收集器"><a href="#3、垃圾收集器" class="headerlink" title="3、垃圾收集器"></a><strong>3、垃圾收集器</strong></h4><p><img src="/2022/07/05/Full-QA/008eGmZEly1gobnjx3zcej30l10ctaat.jpg" alt="img"></p>
<p> <strong>JDK3：Serial Parnew 关注效率</strong></p>
<p><strong>Serial：</strong></p>
<p> Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。适合用于客户端垃圾收集器。</p>
<p><strong>Parnew：</strong></p>
<p> ParNew 垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。</p>
<p> <strong>JDK5：parallel Scavenge+（Serial old/parallel old）关注吞吐量</strong></p>
<p><strong>parallel Scavenge：</strong>(关注吞吐量)</p>
<p> Parallel Scavenge收集器关注点是吞吐量（⾼效率的利⽤CPU）。CMS等垃圾收集器的关注点更多的是⽤户线程的停顿时间（提⾼⽤户体验）；高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。</p>
<p><strong>Serial old：</strong></p>
<p>Serial收集器的⽼年代版本，它同样是⼀个单线程收集器，使用标记-整理算法。主要有两个用途：</p>
<ul>
<li>在 JDK1.5 之前版本中与新生代的 Parallel Scavenge 收集器搭配使用。</li>
<li>作为年老代中使用 CMS 收集器的后备垃圾收集方案。</li>
</ul>
<p><strong>parallel old：</strong></p>
<p> Parallel Scavenge收集器的⽼年代版本。使⽤多线程和“标记-整理”算法。</p>
<p><strong>JDK8-CMS：（关注最短垃圾回收停顿时间）</strong></p>
<p> CMS收集器是一种年老代垃圾收集器，其最主要目标是获取<strong>最短垃圾回收停顿时间</strong>，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段：</p>
<p> <strong>初始标记：</strong>只是标记一下 GC Roots 能直接关联的对象，速度很快，STW。</p>
<p> <strong>并发标记：</strong>进行 ReferenceChains跟踪的过程，和用户线程一起工作，不需要暂停工作线程。</p>
<p> <strong>重新标记：</strong>为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，STW。</p>
<p> <strong>并发清除：</strong>清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。</p>
<p> 由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。</p>
<p> <strong>优点：</strong>并发收集、低停顿</p>
<p> <strong>缺点：</strong>对CPU资源敏感；⽆法处理浮动垃圾；使⽤“标记清除”算法，会导致⼤量空间碎⽚产⽣。</p>
<p><strong>JDK9-G1：（精准控制停顿时间，避免垃圾碎片）</strong></p>
<p> 是⼀款⾯向服务器的垃圾收集器,主要针对配备多颗处理器及⼤容量内存的机器.以极⾼概率满⾜GC停顿时间要求的同时,还具备⾼吞吐量性能特征；相比与 CMS 收集器，G1 收集器两个最突出的改进是：</p>
<p> 【1】基于标记-整理算法，不产生内存碎片。</p>
<p> 【2】可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。</p>
<p> G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。<strong>区域划分</strong>和<strong>优先级区域</strong>回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。</p>
<ul>
<li><strong>初始标记</strong>：<strong>Stop The World，</strong>仅使用一条初始标记线程对GC Roots关联的对象进行标记</li>
<li><strong>并发标记</strong>：使用一条标记线程与用户线程并发执行。此过程进行<strong>可达性分析，速度很慢</strong></li>
<li><strong>最终标记</strong>：<strong>Stop The World</strong>，使用多条标记线程并发执行</li>
<li><strong>筛选回收</strong>：回收废弃对象，此时也要 <strong>Stop The World</strong>，并使用多条筛选回收线程并发执行</li>
</ul>
<p>**JDK11-ZGC:**（在不关注容量的情况获取最小停顿时间5TB/10ms）</p>
<p> 着色笔技术：加快标记过程</p>
<p> 读屏障：解决GC和应用之间并发导致的STW问题</p>
<ul>
<li>支持 TB 级堆内存（最大 4T， JDK13 最大16TB）</li>
<li>最大 GC 停顿 10ms</li>
<li>对吞吐量影响最大，不超过 15%</li>
</ul>
<h4 id="4、配置垃圾收集器"><a href="#4、配置垃圾收集器" class="headerlink" title="4、配置垃圾收集器"></a><strong>4、配置垃圾收集器</strong></h4><ul>
<li>首先是内存大小问题，基本上每一个内存区域我都会设置一个上限，来避免溢出问题，比如元空间。</li>
<li>通常，堆空间我会设置成操作系统的 2/3，超过 8GB 的堆，优先选用 G1</li>
<li>然后我会对 JVM 进行初步优化，比如根据老年代的对象提升速度，来调整年轻代和老年代之间的比例</li>
<li>依据系统容量、访问延迟、吞吐量等进行专项优化，我们的服务是高并发的，对 STW 的时间敏感</li>
<li>我会通过记录详细的 GC 日志，来找到这个瓶颈点，借用 GCeasy 这样的日志分析工具，定位问题</li>
</ul>
<h4 id="4、JVM性能调优"><a href="#4、JVM性能调优" class="headerlink" title="4、JVM性能调优"></a><strong>4、JVM性能调优</strong></h4><p>对应进程的JVM状态以定位问题和解决问题并作出相应的优化</p>
<p><strong>常用命令：</strong>jps、jinfo、jstat、jstack、jmap</p>
<p><strong>jps：查看java进程及相关信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jps -l 输出jar包路径，类全名</span><br><span class="line">jps -m 输出main参数</span><br><span class="line">jps -v 输出JVM参数</span><br></pre></td></tr></table></figure>

<p><strong>jinfo：查看JVM参数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jinfo <span class="number">11666</span></span><br><span class="line">jinfo -flags <span class="number">11666</span></span><br><span class="line">Xmx、Xms、Xmn、MetaspaceSize</span><br></pre></td></tr></table></figure>

<p><strong>jstat：查看JVM运行时的状态信息，包括内存状态、垃圾回收</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat [option] LVMID [interval] [count]其中LVMID是进程id，interval是打印间隔时间（毫秒），count是打印次数（默认一直打印）  option参数解释：-gc 垃圾回收堆的行为统计-gccapacity 各个垃圾回收代容量(young,old,perm)和他们相应的空间统计-gcutil 垃圾回收统计概述-gcnew 新生代行为统计-gcold 年老代和永生代行为统计</span><br></pre></td></tr></table></figure>

<p><strong>jstack：查看JVM线程快照，jstack命令可以定位线程出现长时间卡顿的原因，例如死锁，死循环</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [-l] &lt;pid&gt; (连接运行中的进程)  option参数解释：-F 当使用jstack &lt;pid&gt;无响应时，强制输出线程堆栈。-m 同时输出java和本地堆栈(混合模式)-l 额外显示锁信息</span><br></pre></td></tr></table></figure>

<p><strong>jmap：可以用来查看内存信息</strong>(配合jhat使用)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] &lt;pid&gt; (连接正在执行的进程)option参数解释：-heap 打印java heap摘要-dump:&lt;dump-options&gt; 生成java堆的dump文件</span><br></pre></td></tr></table></figure>

<h4 id="5、JDK新特性"><a href="#5、JDK新特性" class="headerlink" title="5、JDK新特性"></a>5、JDK新特性</h4><p>JDK8</p>
<p>支持 Lamda 表达式、集合的 stream 操作、提升HashMap性能</p>
<p><strong>JDK9</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Stream API中iterate方法的新重载方法，可以指定什么时候结束迭代IntStream.iterate(1, i -&gt; i &lt; 100, i -&gt; i + 1).forEach(System.out::println);</span></span><br></pre></td></tr></table></figure>

<p>默认G1垃圾回收器</p>
<p><strong>JDK10</strong></p>
<p>其重点在于通过完全GC并行来改善G1最坏情况的等待时间。</p>
<p><strong>JDK11</strong></p>
<p>ZGC (并发回收的策略) 4TB</p>
<p>用于 Lambda 参数的局部变量语法</p>
<p><strong>JDK12</strong></p>
<p>Shenandoah GC (GC 算法)停顿时间和堆的大小没有任何关系，并行关注停顿响应时间。</p>
<p><strong>JDK13</strong></p>
<p>增加ZGC以将未使用的堆内存返回给操作系统，16TB</p>
<p><strong>JDK14</strong></p>
<p>删除cms垃圾回收器、弃用ParallelScavenge+SerialOldGC垃圾回收算法组合</p>
<p>将ZGC垃圾回收器应用到macOS和windows平台</p>
<h1 id="三、多线程篇"><a href="#三、多线程篇" class="headerlink" title="三、多线程篇"></a>三、多线程篇</h1><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><h4 id="1、线程状态"><a href="#1、线程状态" class="headerlink" title="1、线程状态"></a><strong>1、线程状态</strong></h4><p> 线程是cpu任务调度的最小执行单位，每个线程拥有自己独立的程序计数器、虚拟机栈、本地方法栈</p>
<p><strong>线程状态：创建、就绪、运行、阻塞、死亡</strong></p>
<p><img src="/2022/07/05/Full-QA/Cgq2xl5xxGKAKBpeAAEw9Ifr07Y662.png" alt="img"></p>
<h4 id="2、线程状态切换"><a href="#2、线程状态切换" class="headerlink" title="2、线程状态切换"></a><strong>2、线程状态切换</strong></h4><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>区别</th>
</tr>
</thead>
<tbody><tr>
<td>start</td>
<td>启动线程，由虚拟机自动调度执行run()方法</td>
<td>线程处于就绪状态</td>
</tr>
<tr>
<td>run</td>
<td>线程逻辑代码块处理，JVM调度执行</td>
<td>线程处于运行状态</td>
</tr>
<tr>
<td>sleep</td>
<td>让当前正在执行的线程休眠（暂停执行）</td>
<td>不释放锁</td>
</tr>
<tr>
<td>wait</td>
<td>使得当前线程等待</td>
<td>释放同步锁</td>
</tr>
<tr>
<td>notify</td>
<td>唤醒在此对象监视器上等待的单个线程</td>
<td>唤醒单个线程</td>
</tr>
<tr>
<td>notifyAll</td>
<td>唤醒在此对象监视器上等待的所有线程</td>
<td>唤醒多个线程</td>
</tr>
<tr>
<td>yiled</td>
<td>停止当前线程，让同等优先权的线程运行</td>
<td>用Thread类调用</td>
</tr>
<tr>
<td>join</td>
<td>使当前线程停下来等待，直至另一个调用join方法的线程终止</td>
<td>用线程对象调用</td>
</tr>
</tbody></table>
<p><img src="/2022/07/05/Full-QA/Ciqc1F_Qfy2ACkrLAAD2DLkc2qw212.png" alt="img"></p>
<h4 id="3、阻塞唤醒过程"><a href="#3、阻塞唤醒过程" class="headerlink" title="3、阻塞唤醒过程"></a><strong>3、阻塞唤醒过程</strong></h4><p><strong>阻塞：</strong></p>
<p> 这三个方法的调用都会使当前线程阻塞。该线程将会被放置到对该Object的请求等待队列中，然后让出当前对Object所拥有的所有的同步请求。线程会一直暂停所有线程调度，直到下面其中一种情况发生：</p>
<p>　　　　① 其他线程调用了该Object的notify方法，而该线程刚好是那个被唤醒的线程；</p>
<p>　　　　② 其他线程调用了该Object的notifyAll方法；</p>
<p><strong>唤醒：</strong></p>
<p> 线程将会从等待队列中移除，重新成为可调度线程。它会与其他线程以常规的方式竞争对象同步请求。<strong>一旦它重新获得对象的同步请求，所有之前的请求状态都会恢复，也就是线程调用wait的地方的状态。线程将会在之前调用wait的地方继续运行下去。</strong></p>
<p><strong>为什么要出现在同步代码块中：</strong></p>
<p> 由于<code>wait()属于Object方法，调用之后会强制释放当前对象锁，所以在wait()</code> 调用时必须拿到当前对象的监视器monitor对象。因此，wait()方法在同步方法/代码块中调用。</p>
<h4 id="4、wait和sleep区别"><a href="#4、wait和sleep区别" class="headerlink" title="4、wait和sleep区别"></a><strong>4、wait和sleep区别</strong></h4><ul>
<li>wait 方法必须在 synchronized 保护的代码中使用，而 sleep 方法并没有这个要求。</li>
<li>wait 方法会主动释放 monitor 锁，在同步代码中执行 sleep 方法时，并不会释放 monitor 锁。</li>
<li>wait 方法意味着永久等待，直到被中断或被唤醒才能恢复，不会主动恢复，sleep 方法中会定义一个时间，时间到期后会主动恢复。</li>
<li>wait/notify 是 Object 类的方法，而 sleep 是 Thread 类的方法。</li>
</ul>
<h4 id="5、创建线程方式"><a href="#5、创建线程方式" class="headerlink" title="5、创建线程方式"></a>5、创建线程方式</h4><p><strong>实现 Runnable 接口</strong>（优先使用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;System.out.println(<span class="string">&#x27;用实现Runnable接口实现线程&#x27;</span>);&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现Callable接口</strong>（有返回值可抛出异常）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt();&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>继承Thread类</strong>（java不支持多继承）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;System.out.println(<span class="string">&#x27;用Thread类实现线程&#x27;</span>);&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用线程池</strong>（底层都是实现run方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;    DefaultThreadFactory() &#123;        SecurityManager s = System.getSecurityManager();        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();        namePrefix = <span class="string">&quot;pool-&quot;</span> + poolNumber.getAndIncrement() +<span class="string">&quot;-thread-&quot;</span>;    &#125;    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;        Thread t = <span class="keyword">new</span> Thread(group, r,namePrefix + threadNumber.getAndIncrement(),<span class="number">0</span>);        <span class="keyword">if</span> (t.isDaemon()) t.setDaemon(<span class="keyword">false</span>);  <span class="comment">//是否守护线程        if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); //线程优先级        return t;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>优点：通过复用已创建的线程，<strong>降低资源损耗</strong>、线程可以直接处理队列中的任务<strong>加快响应速度</strong>、同时便于<strong>统一监控和管理</strong>。</p>
<h4 id="1、线程池构造函数"><a href="#1、线程池构造函数" class="headerlink" title="1、线程池构造函数"></a><strong>1、线程池构造函数</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 线程池构造函数7大参数*/</span><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,    TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,    RejectedExecutionHandler handler)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参数介绍：</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>核心线程池大小</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>最大线程池大小</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>线程池中超过 corePoolSize 数目的空闲线程最大存活时间；</td>
</tr>
<tr>
<td>TimeUnit</td>
<td>keepAliveTime 时间单位</td>
</tr>
<tr>
<td>workQueue</td>
<td>阻塞任务队列</td>
</tr>
<tr>
<td>threadFactory</td>
<td>新建线程工厂</td>
</tr>
<tr>
<td>RejectedExecutionHandler</td>
<td>拒绝策略。当提交任务数超过 maxmumPoolSize+workQueue 之和时，任务会交给RejectedExecutionHandler 来处理</td>
</tr>
</tbody></table>
<h4 id="2、线程处理任务过程："><a href="#2、线程处理任务过程：" class="headerlink" title="2、线程处理任务过程："></a><strong>2、线程处理任务过程：</strong></h4><p><img src="/2022/07/05/Full-QA/Cgq2xl5zjxGAXOA-AABF0Dv8GMI518.png" alt="img"></p>
<ol>
<li>当线程池小于corePoolSize，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。</li>
<li>当线程池达到corePoolSize时，新提交任务将被放入 workQueue 中，等待线程池中任务调度执行。</li>
<li>当workQueue已满，且 maximumPoolSize 大于 corePoolSize 时，新提交任务会创建新线程执行任务。</li>
<li>当提交任务数超过 maximumPoolSize 时，新提交任务由 RejectedExecutionHandler 处理。</li>
<li>当线程池中超过corePoolSize 线程，空闲时间达到 keepAliveTime 时，关闭空闲线程 。</li>
</ol>
<h4 id="3、线程拒绝策略"><a href="#3、线程拒绝策略" class="headerlink" title="3、线程拒绝策略"></a><strong>3、线程拒绝策略</strong></h4><p> 线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。</p>
<p>JDK 内置的拒绝策略如下：</p>
<p> <strong>AbortPolicy：</strong>直接抛出异常，阻止系统正常运行。可以根据业务逻辑选择重试或者放弃提交等策略。</p>
<p> <strong>CallerRunsPolicy ：</strong>只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。</p>
<p> 不会造成任务丢失，同时减缓提交任务的速度，给执行任务缓冲时间。</p>
<p> <strong>DiscardOldestPolicy ：</strong>丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。</p>
<p> <strong>DiscardPolicy ：</strong>该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。</p>
<h4 id="4、Execuors类实现线程池"><a href="#4、Execuors类实现线程池" class="headerlink" title="4、Execuors类实现线程池"></a><strong>4、Execuors类实现线程池</strong></h4><p><img src="/2022/07/05/Full-QA/CgpOIF4z1EiAFjNQAAAtVe5xjgQ999.png" alt="img"></p>
<ul>
<li><strong>newSingleThreadExecutor()：</strong>只有一个线程的线程池，任务是顺序执行，适用于一个一个任务执行的场景</li>
<li><strong>newCachedThreadPool()：</strong>线程池里有很多线程需要同时执行，60s内复用，适用执行很多短期异步的小程序或者负载较轻的服务</li>
<li><strong>newFixedThreadPool()：</strong>拥有固定线程数的线程池，如果没有任务执行，那么线程会一直等待，适用执行长期的任务。</li>
<li><strong>newScheduledThreadPool()：</strong>用来调度即将执行的任务的线程池</li>
<li>**newWorkStealingPool()**：底层采用forkjoin的Deque，采用独立的任务队列可以减少竞争同时加快任务处理</li>
<li></li>
<li><img src="/2022/07/05/Full-QA/CgoB5l3kzomAckv5AAAxf6FCPco696.png" alt="img"></li>
</ul>
<p><strong>因为以上方式都存在弊端：</strong></p>
<p> FixedThreadPool 和 SingleThreadExecutor ： 允许请求的<strong>队列⻓度</strong>为 Integer.MAX_VALUE，会导致OOM。<br>​ CachedThreadPool 和 ScheduledThreadPool ： 允许创建的<strong>线程数量</strong>为 Integer.MAX_VALUE，会导致OOM。</p>
<p>手动创建的线程池底层使用的是ArrayBlockingQueue可以防止OOM。</p>
<h4 id="5、线程池大小设置"><a href="#5、线程池大小设置" class="headerlink" title="5、线程池大小设置"></a><strong>5、线程池大小设置</strong></h4><ul>
<li>CPU 密集型（n+1）</li>
</ul>
<p> CPU 密集的意思是该任务需要大量的运算，而没有阻塞，CPU 一直全速运行。</p>
<p> CPU 密集型任务尽可能的少的线程数量，一般为 CPU 核数 + 1 个线程的线程池。</p>
<ul>
<li>IO 密集型（2*n）</li>
</ul>
<p> 由于 IO 密集型任务线程并不是一直在执行任务，可以多分配一点线程数，如 CPU * 2</p>
<p> 也可以使用公式：CPU 核心数 *（1+平均等待时间/平均工作时间）。</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h4 id="1、乐观锁，CAS思想"><a href="#1、乐观锁，CAS思想" class="headerlink" title="1、乐观锁，CAS思想"></a><strong>1、乐观锁，CAS思想</strong></h4><p><strong>java乐观锁机制：</strong></p>
<p> 乐观锁体现的是悲观锁的反面。它是一种积极的思想，它总是认为数据是不会被修改的，所以是不会对数据上锁的。但是乐观锁在更新的时候会去判断数据是否被更新过。乐观锁的实现方案一般有两种（版本号机制和CAS）。乐观锁适用于<strong>读多写少的场景，这样可以提高系统的并发量</strong>。在Java中 <strong>java.util.concurrent.atomic</strong>下的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p>
<p>　　乐观锁，大多是基于数据版本 (Version)记录机制实现。即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来 实现。 读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提 交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据 版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>
<p><strong>CAS思想：</strong></p>
<p> CAS就是compare and swap（<strong>比较交换</strong>），是一种很出名的无锁的算法，就是可以不使用锁机制实现线程间的同步。使用CAS线程是不会被阻塞的，所以又称为非阻塞同步。CAS算法涉及到三个操作：</p>
<p> 需要读写内存值V；进行比较的值A；准备写入的值B</p>
<p> 当且仅当V的值等于A的值等于V的值的时候，才用B的值去更新V的值，否则不会执行任何操作（比较和替换是一个原子操作-A和V比较，V和B替换），一般情况下是一个<strong>自旋操作</strong>，即<strong>不断重试</strong></p>
<p><strong>缺点：</strong></p>
<p> <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23281499/answer/854522984">ABA问题-知乎</a></p>
<p> 高并发的情况下，很容易发生并发冲突，如果CAS一直失败，那么就会一直重试，浪费CPU资源</p>
<p><strong>原子性：</strong></p>
<p> 功能限制CAS是能保证单个变量的操作是原子性的，在Java中要配合使用volatile关键字来保证线程的安全；当涉及到多个变量的时候CAS无能为力；除此之外CAS实现需要硬件层面的支持，在Java的普通用户中无法直接使用，只能<strong>借助atomic包下的原子类</strong>实现，灵活性受到了限制</p>
<h4 id="2、synchronized底层实现"><a href="#2、synchronized底层实现" class="headerlink" title="2、synchronized底层实现"></a><strong>2、synchronized底层实现</strong></h4><p><strong>使用方法：</strong>主要的三种使⽤⽅式</p>
<p> <strong>修饰实例⽅法:</strong> 作⽤于当前对象实例加锁，进⼊同步代码前要获得当前对象实例的锁</p>
<p> <strong>修饰静态⽅法:</strong> 也就是给当前类加锁，会作⽤于类的所有对象实例，因为静态成员不属于任何⼀个实例对象，是类成员。</p>
<p> <strong>修饰代码块:</strong> 指定加锁对象，对给定对象加锁，进⼊同步代码库前要获得给定对象的锁。</p>
<p> <strong>总结：</strong>synchronized锁住的资源只有两类：一个是<strong>对象</strong>，一个是<strong>类</strong>。</p>
<p><strong>底层实现：</strong></p>
<p> 对象头是我们需要关注的重点，它是synchronized实现锁的基础，因为synchronized申请锁、上锁、释放锁都与对象头有关。对象头主要结构是由<code>Mark Word</code> 组成，<strong>其中<code>Mark Word</code>存储对象的hashCode、锁信息或分代年龄或GC标志等信息</strong>。</p>
<p> 锁也分不同状态，JDK6之前只有两个状态：无锁、有锁（重量级锁），而在JDK6之后对synchronized进行了优化，新增了两种状态，总共就是四个状态：<strong>无锁状态、偏向锁、轻量级锁、重量级锁</strong>，其中无锁就是一种状态了。锁的类型和状态在对象头<code>Mark Word</code>中都有记录，在申请锁、锁升级等过程中JVM都需要读取对象的<code>Mark Word</code>数据。</p>
<p> 同步代码块是利用 monitorenter 和 monitorexit 指令实现的，而同步方法则是利用 flags 实现的。</p>
<h4 id="3、ReenTrantLock底层实现"><a href="#3、ReenTrantLock底层实现" class="headerlink" title="3、ReenTrantLock底层实现"></a><strong>3、ReenTrantLock底层实现</strong></h4><p> 由于ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，ReentrantLock类提供了一些高级功能</p>
<p><strong>使用方法：</strong></p>
<p> 基于API层面的互斥锁，需要lock()和unlock()方法配合try/finally语句块来完成</p>
<p><strong>底层实现：</strong></p>
<p> ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。</p>
<p><strong>和synchronized区别：</strong></p>
<p> 1、<strong>底层实现</strong>：synchronized 是<strong>JVM</strong>层面的锁，是<strong>Java关键字</strong>，通过monitor对象来完成（monitorenter与monitorexit），ReentrantLock 是从jdk1.5以来（java.util.concurrent.locks.Lock）提供的<strong>API层面</strong>的锁。</p>
<p> 2、<strong>实现原理****：synchronized 的实现涉及到**锁的升级</strong>，具体为无锁、偏向锁、自旋锁、向OS申请重量级锁；ReentrantLock实现则是通过利用<strong>CAS</strong>（CompareAndSwap）自旋机制保证线程操作的原子性和volatile保证数据可见性以实现锁的功能。</p>
<p> 3、<strong>是否可手动释放：</strong>synchronized 不需要用户去手动释放锁，synchronized 代码执行完后系统会自动让线程释放对锁的占用； ReentrantLock则需要用户去手动释放锁，如果没有手动释放锁，就可能导致<strong>死锁现象</strong>。</p>
<p> 4、<strong>是否可中断</strong>synchronized是不可中断类型的锁，除非加锁的代码中出现异常或正常执行完成； ReentrantLock则可以中断，可通过trylock(long timeout,TimeUnit unit)设置超时方法或者将lockInterruptibly()放到代码块中，调用interrupt方法进行中断。</p>
<p> 5、<strong>是否公平锁</strong>synchronized为非公平锁 ReentrantLock则即可以选公平锁也可以选非公平锁，通过构造方法new ReentrantLock时传入boolean值进行选择，为空默认false非公平锁，true为公平锁,公平锁性能非常低。</p>
<h4 id="4、公平锁和非公平锁区别"><a href="#4、公平锁和非公平锁区别" class="headerlink" title="4、公平锁和非公平锁区别"></a><strong>4、公平锁和非公平锁区别</strong></h4><p><strong>公平锁：</strong></p>
<p> 公平锁自然是遵循<strong>FIFO</strong>（先进先出）原则的，先到的线程会优先获取资源，后到的会进行排队等待</p>
<p> <strong>优点：</strong>所有的线程都能得到资源，不会饿死在队列中。适合大任务</p>
<p> <strong>缺点：</strong>吞吐量会下降，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销大</p>
<p><strong>非公平锁：</strong></p>
<p> 多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p>
<p> <strong>优点：</strong>可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。</p>
<p> <strong>缺点：</strong>你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁</p>
<p><img src="/2022/07/05/Full-QA/Ciqah157DAiAK_DJAAC0JawhGp4730.png" alt="img"></p>
<p><strong>公平锁效率低原因：</strong></p>
<p> 公平锁要维护一个队列，后来的线程要加锁，即使锁空闲，也要先检查有没有其他线程在 wait，如果有自己要挂起，加到队列后面，然后唤醒队列最前面线程。这种情况下相比较非公平锁多了一次<strong>挂起和唤醒</strong>。</p>
<p> <strong>线程切换的开销</strong>，其实就是非公平锁效率高于公平锁的原因，因为<strong>非公平锁减少了线程挂起的几率</strong>，后来的线程有一定几率逃离被挂起的开销。</p>
<h4 id="5、使用层面锁优化"><a href="#5、使用层面锁优化" class="headerlink" title="5、使用层面锁优化"></a><strong>5、使用层面锁优化</strong></h4><p> 【1】<strong>减少锁的时间：</strong><br>​ 不需要同步执行的代码，能不放在同步快里面执行就不要放在同步快内，可以让锁尽快释放；</p>
<p> 【2】<strong>减少锁的粒度：</strong><br>​ 它的思想是将物理上的一个锁，拆成逻辑上的多个锁，增加并行度，从而降低锁竞争。它的思想也是用空间来换时间；java中很多数据结构都是采用这种方法提高并发操作的效率，比如：</p>
<p> <strong>ConcurrentHashMap：</strong></p>
<p> java中的ConcurrentHashMap在jdk1.8之前的版本，使用一个Segment 数组：Segment&lt; K,V &gt;[] segments</p>
<p> Segment继承自ReenTrantLock，所以每个Segment是个可重入锁，每个Segment 有一个HashEntry&lt; K,V &gt;数组用来存放数据，put操作时，先确定往哪个Segment放数据，只需要锁定这个Segment，执行put，其它的Segment不会被锁定；所以数组中有多少个Segment就允许同一时刻多少个线程存放数据，这样增加了并发能力。</p>
<p> 【3】<strong>锁粗化：</strong><br>​ 大部分情况下我们是要让锁的粒度最小化，锁的粗化则是要增大锁的粒度;</p>
<p> 假如有一个循环，循环内的操作需要加锁，我们应该把锁放到循环外面，否则每次进出循环，都进出一次临界区，效率是非常差的；</p>
<p> 【4】<strong>使用读写锁：</strong></p>
<p> ReentrantReadWriteLock 是一个读写锁，读操作加读锁，可并发读，写操作使用写锁，只能单线程写；</p>
<p> 【5】<strong>使用CAS：</strong></p>
<p> 如果需要同步的操作执行速度非常快，并且线程竞争并不激烈，这时候使用cas效率会更高，因为加锁会导致线程的上下文切换，如果上下文切换的耗时比同步操作本身更耗时，且线程对资源的竞争不激烈，使用volatiled+cas操作会是非常高效的选择；</p>
<h4 id="6、系统层面锁优化"><a href="#6、系统层面锁优化" class="headerlink" title="6、系统层面锁优化"></a>6、系统层面锁优化</h4><p><strong>自适应自旋锁：</strong></p>
<p> 自旋锁可以避免等待竞争锁进入阻塞挂起状态被唤醒造成的<strong>内核态和用户态之间的切换</strong>的损耗，它们只需要等一等（自旋），但是如果锁被其他线程长时间占用，一直不释放CPU，死等会带来更多的性能开销；自旋次数默认值是10</p>
<p> 对上面自旋锁优化方式的进一步优化，它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的<strong>自旋时间及锁的拥有者的状态</strong>来决定，这就解决了自旋锁带来的缺点</p>
<p><strong>锁消除：</strong></p>
<p> 锁削除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行削除。Netty中无锁化设计pipeline中channelhandler会进行锁消除的优化。</p>
<p><strong>锁升级：</strong></p>
<p> <strong>偏向锁：</strong></p>
<p> 如果线程已经占有这个锁，当他在次试图去获取这个锁的时候，他会已最快的方式去拿到这个锁，而不需要在进行一些monitor操作，因为在大部分情况下是没有竞争的，所以使用偏向锁是可以提高性能的；</p>
<p> <strong>轻量级锁：</strong></p>
<p> 在竞争不激烈的情况下，通过CAS避免线程上下文切换，可以显著的提高性能。</p>
<p> <strong>重量级锁：</strong></p>
<p> 重量级锁的加锁、解锁过程造成的损耗是固定的，重量级锁适合于竞争激烈、高并发、同步块执行时间长的情况。</p>
<h4 id="7、ThreadLocal原理"><a href="#7、ThreadLocal原理" class="headerlink" title="7、ThreadLocal原理"></a><strong>7、ThreadLocal原理</strong></h4><p><strong>ThreadLocal简介：</strong></p>
<p> 通常情况下，我们创建的变量是可以被任何⼀个线程访问并修改的。如果想实现每⼀个线程都有⾃⼰的<br>专属本地变量该如何解决呢？ JDK中提供的 ThreadLocal 类正是为了解决这样的问题。类似操作系统中的TLAB</p>
<p><strong>原理：</strong></p>
<p> 首先 ThreadLocal 是一个泛型类，保证可以接受任何类型的对象。因为一个线程内可以存在多个 ThreadLocal 对象，所以其实是 ThreadLocal 内部维护了一个 Map ，是 ThreadLocal 实现的一个叫做 ThreadLocalMap 的静态内部类。</p>
<p> 最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。</p>
<p> 我们使用的 get()、set() 方法其实都是调用了这个ThreadLocalMap类对应的 get()、set() 方法。例如下面的</p>
<p><strong>如何使用：</strong></p>
<p> 1）存储用户Session</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal();</span><br></pre></td></tr></table></figure>

<p> 2）解决线程安全的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; format1 = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;()</span><br></pre></td></tr></table></figure>

<p><strong>ThreadLocal内存泄漏的场景</strong></p>
<p> 实际上 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，⽽ value 是强引⽤。弱引用的特点是，如果这个对象持有弱引用，那么在下一次垃圾回收的时候必然会被清理掉。</p>
<p> 所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。 假如我们不做任何措施的话，value 永远⽆法被GC 回收，如果线程长时间不被销毁，可能会产⽣内存泄露。</p>
<p><img src="/2022/07/05/Full-QA/Cgq2xl5Pld-AHFhJAADLtGXmSxc833.png" alt="img"></p>
<p> ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。如果说会出现内存泄漏，那只有在出现了 key 为 null 的记录后，没有手动调用 remove() 方法，并且之后也不再调用 get()、set()、remove() 方法的情况下。因此使⽤完ThreadLocal ⽅法后，<strong>最好⼿动调⽤ remove() ⽅法</strong>。</p>
<h4 id="8、HashMap线程安全"><a href="#8、HashMap线程安全" class="headerlink" title="8、HashMap线程安全"></a><strong>8、HashMap线程安全</strong></h4><p> <strong>死循环造成 CPU 100%</strong></p>
<p> HashMap 有可能会发生死循环并且造成 CPU 100% ，这种情况发生最主要的原因就是在<strong>扩容</strong>的时候，也就是内部<strong>新建新的 HashMap</strong> 的时候，扩容的逻辑会<strong>反转散列桶中的节点顺序</strong>，当有多个线程同时进行扩容的时候，由于 HashMap 并非线程安全的，所以如果<strong>两个线程同时反转的话，便可能形成一个循环</strong>，并且这种循环是链表的循环，相当于 A 节点指向 B 节点，B 节点又指回到 A 节点，这样一来，在下一次想要获取该 key 所对应的 value 的时候，便会在遍历链表的时候发生永远无法遍历结束的情况，也就发生 CPU 100% 的情况。</p>
<p> 所以综上所述，HashMap 是线程不安全的，在多线程使用场景中推荐使用线程安全同时性能比较好的 ConcurrentHashMap。</p>
<h4 id="9、String不可变原因"><a href="#9、String不可变原因" class="headerlink" title="9、String不可变原因"></a>9、String不可变原因</h4><ol>
<li>可以使用<strong>字符串常量池</strong>，多次创建同样的字符串会指向同一个内存地址</li>
<li>可以很方便地用作 <strong>HashMap 的 key</strong>。通常建议把不可变对象作为 HashMap的 key</li>
<li>hashCode生成后就不会改变，使用时无需重新计算</li>
<li>线程安全，因为具备不变性的对象一定是线程安全的</li>
</ol>
<h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p> Java 内存模型（Java Memory Model，JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了 Java 程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</p>
<p><img src="/2022/07/05/Full-QA/Cgq2xl54fTKALhevAAB_l3axT_o532.png" alt="img"></p>
<p> JMM 是一种规范，是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。目的是保证并发编程场景中的原子性、可见性和有序性。</p>
<p><strong>原子性：</strong></p>
<p> 在 Java 中，为了保证原子性，提供了两个高级的字节码指令 Monitorenter 和 Monitorexit。这两个字节码，在 Java 中对应的关键字就是 Synchronized。因此，在 Java 中可以使用 Synchronized 来保证方法和代码块内的操作是原子性的。</p>
<p><strong>可见性：</strong></p>
<p> Java 中的 Volatile 关键字修饰的变量在被修改后可以立即同步到主内存。被其修饰的变量在每次使用之前都从主内存刷新。因此，可以使用 Volatile 来保证多线程操作时变量的可见性。除了 Volatile，Java 中的 Synchronized 和 Final 两个关键字也可以实现可见性。只不过实现方式不同</p>
<p><strong>有序性</strong></p>
<p> 在 Java 中，可以使用 Synchronized 和 Volatile 来保证多线程之间操作的有序性。区别：Volatile 禁止指令重排。Synchronized 保证同一时刻只允许一条线程操作。</p>
<h4 id="1、volatile底层实现"><a href="#1、volatile底层实现" class="headerlink" title="1、volatile底层实现"></a><strong>1、volatile底层实现</strong></h4><p><strong>作用：</strong></p>
<p> 保证数据的“可见性”：被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。</p>
<p> 禁止指令重排：在多线程操作情况下，指令重排会导致计算结果不一致</p>
<p><strong>底层实现：</strong></p>
<p> “观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>
<p>　　lock前缀指令实际上相当于一个<strong>内存屏障</strong>（也成内存栅栏），内存屏障会提供3个功能：</p>
<p>　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；</p>
<p>　　2）它会强制将对缓存的修改操作立即写入主存；</p>
<p>　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
<p><strong>单例模式中volatile的作用：</strong></p>
<p>防止代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;   <span class="comment">//禁止指令重排    private Singleton() &#123;             &#125;    public static Singleton getInstance() &#123;        if(instance==null) &#123; //减少加锁的损耗            synchronized (Singleton.class) &#123;                if(instance==null) //确认是否初始化完成                    instance = new Singleton();            &#125;        &#125;        return instance;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="2、AQS思想"><a href="#2、AQS思想" class="headerlink" title="2、AQS思想"></a><strong>2、AQS思想</strong></h4><p> AQS的全称为（AbstractQueuedSynchronizer）抽象的队列式的同步器，是⼀个⽤来构建锁和同步器的框架，使⽤AQS能简单且⾼效地构造出应⽤⼴泛的⼤量的同步器，如：基于AQS实现的lock, CountDownLatch、CyclicBarrier、Semaphore需解决的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">状态的原子性管理线程的阻塞与解除阻塞队列的管理</span><br></pre></td></tr></table></figure>

<p> AQS核⼼思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占⽤，那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是⽤<strong>CLH（虚拟的双向队列）</strong>队列锁实现的，即将暂时获取不到锁的线程加⼊到队列中。</p>
<p><strong>lock：</strong></p>
<p> 是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。默认为非公平锁，但可以初始化为公平锁； 通过方法 lock()与 unlock()来进行加锁与解锁操作；</p>
<p><strong>CountDownLatch：</strong></p>
<p> 通过计数法（倒计时器），让一些线程堵塞直到另一个线程完成一系列操作后才被唤醒；该⼯具通常⽤来控制线程等待，它可以让某⼀个线程等待直到倒计时结束，再开始执⾏。具体可以使用countDownLatch.await()来等待结果。多用于多线程信息汇总。</p>
<p><strong>CompletableFuture：</strong></p>
<p> 通过设置参数，可以完成CountDownLatch同样的多平台响应问题，但是可以针对其中部分返回结果做更加灵活的展示。</p>
<p><strong>CyclicBarrier：</strong></p>
<p> 字面意思是可循环(Cyclic)使用的屏障（Barrier）。他要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await()方法。可以用于批量发送消息队列信息、异步限流。</p>
<p><strong>Semaphore：</strong></p>
<p> 信号量主要用于两个目的，一个是用于多个共享资源的互斥作用，另一个用于并发线程数的控制。SpringHystrix限流的思想</p>
<h4 id="3、happens-before"><a href="#3、happens-before" class="headerlink" title="3、happens-before"></a>3、happens-before</h4><p> 用来描述和可见性相关问题：如果第一个操作 happens-before 第二个操作，那么我们就说第一个操作对于第二个操作是可见的</p>
<p> 常见的happens-before：volatile 、锁、线程生命周期。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Full-QA</p><p><a href="http://example.com/2022/07/05/Full-QA/">http://example.com/2022/07/05/Full-QA/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>white crow</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2022-07-05</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-03-25</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/07/26/Git/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Git</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/03/16/TaskPerFrame/"><span class="level-item">TaskPerFrame</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#一、基础篇"><span class="level-left"><span class="level-item">1</span><span class="level-item">一、基础篇</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#网络基础"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">网络基础</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#TCP三次握手"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">TCP三次握手</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、OSI与TCP-IP-模型"><span class="level-left"><span class="level-item">1.1.1.1</span><span class="level-item">1、OSI与TCP/IP 模型</span></span></a></li><li><a class="level is-mobile" href="#2、常见网络服务分层"><span class="level-left"><span class="level-item">1.1.1.2</span><span class="level-item">2、常见网络服务分层</span></span></a></li><li><a class="level is-mobile" href="#3、TCP与UDP区别及场景"><span class="level-left"><span class="level-item">1.1.1.3</span><span class="level-item">3、TCP与UDP区别及场景</span></span></a></li><li><a class="level is-mobile" href="#4、TCP滑动窗口，拥塞控制"><span class="level-left"><span class="level-item">1.1.1.4</span><span class="level-item">4、TCP滑动窗口，拥塞控制</span></span></a></li><li><a class="level is-mobile" href="#5、TCP粘包原因和解决方法"><span class="level-left"><span class="level-item">1.1.1.5</span><span class="level-item">5、TCP粘包原因和解决方法</span></span></a></li><li><a class="level is-mobile" href="#6、TCP、UDP报文格式"><span class="level-left"><span class="level-item">1.1.1.6</span><span class="level-item">6、TCP、UDP报文格式</span></span></a></li></ul></li><li><a class="level is-mobile" href="#HTTP协议"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">HTTP协议</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、HTTP协议1-0-1-1-2-0"><span class="level-left"><span class="level-item">1.1.2.1</span><span class="level-item">1、HTTP协议1.0_1.1_2.0</span></span></a></li><li><a class="level is-mobile" href="#2、HTTP与HTTPS之间的区别"><span class="level-left"><span class="level-item">1.1.2.2</span><span class="level-item">2、HTTP与HTTPS之间的区别</span></span></a></li><li><a class="level is-mobile" href="#3、Get和Post请求区别"><span class="level-left"><span class="level-item">1.1.2.3</span><span class="level-item">3、Get和Post请求区别</span></span></a></li><li><a class="level is-mobile" href="#4、HTTP常见响应状态码"><span class="level-left"><span class="level-item">1.1.2.4</span><span class="level-item">4、HTTP常见响应状态码</span></span></a></li><li><a class="level is-mobile" href="#5、重定向和转发区别"><span class="level-left"><span class="level-item">1.1.2.5</span><span class="level-item">5、重定向和转发区别</span></span></a></li><li><a class="level is-mobile" href="#6、Cookie和Session区别。"><span class="level-left"><span class="level-item">1.1.2.6</span><span class="level-item">6、Cookie和Session区别。</span></span></a></li></ul></li><li><a class="level is-mobile" href="#浏览器输入URL过程"><span class="level-left"><span class="level-item">1.1.3</span><span class="level-item">浏览器输入URL过程</span></span></a></li></ul></li><li><a class="level is-mobile" href="#操作系统基础"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">操作系统基础</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#进程和线程的区别"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">进程和线程的区别</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、进程间通信方式IPC"><span class="level-left"><span class="level-item">1.2.1.1</span><span class="level-item">1、进程间通信方式IPC</span></span></a></li><li><a class="level is-mobile" href="#2、用户态和核心态"><span class="level-left"><span class="level-item">1.2.1.2</span><span class="level-item">2、用户态和核心态</span></span></a></li><li><a class="level is-mobile" href="#3、操作系统的进程空间"><span class="level-left"><span class="level-item">1.2.1.3</span><span class="level-item">3、操作系统的进程空间</span></span></a></li></ul></li><li><a class="level is-mobile" href="#操作系统内存管理"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">操作系统内存管理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、页面置换算法FIFO、LRU"><span class="level-left"><span class="level-item">1.2.2.1</span><span class="level-item">1、页面置换算法FIFO、LRU</span></span></a></li><li><a class="level is-mobile" href="#2、死锁条件、解决方式。"><span class="level-left"><span class="level-item">1.2.2.2</span><span class="level-item">2、死锁条件、解决方式。</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Java基础"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">Java基础</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#面向对象三大特性"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">面向对象三大特性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、Java与C-区别"><span class="level-left"><span class="level-item">1.3.1.1</span><span class="level-item">1、Java与C++区别</span></span></a></li><li><a class="level is-mobile" href="#2、多态实现原理"><span class="level-left"><span class="level-item">1.3.1.2</span><span class="level-item">2、多态实现原理</span></span></a></li><li><a class="level is-mobile" href="#3、static和final关键字"><span class="level-left"><span class="level-item">1.3.1.3</span><span class="level-item">3、static和final关键字</span></span></a></li><li><a class="level is-mobile" href="#4、抽象类和接口"><span class="level-left"><span class="level-item">1.3.1.4</span><span class="level-item">4、抽象类和接口</span></span></a></li><li><a class="level is-mobile" href="#5、泛型以及泛型擦除"><span class="level-left"><span class="level-item">1.3.1.5</span><span class="level-item">5、泛型以及泛型擦除</span></span></a></li><li><a class="level is-mobile" href="#6、反射原理以及使用场景"><span class="level-left"><span class="level-item">1.3.1.6</span><span class="level-item">6、反射原理以及使用场景</span></span></a></li><li><a class="level is-mobile" href="#7、Java异常体系"><span class="level-left"><span class="level-item">1.3.1.7</span><span class="level-item">7、Java异常体系</span></span></a></li></ul></li><li><a class="level is-mobile" href="#数据结构"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">数据结构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、ArrayList和LinkedList"><span class="level-left"><span class="level-item">1.3.2.1</span><span class="level-item">1、ArrayList和LinkedList</span></span></a></li><li><a class="level is-mobile" href="#2、List遍历快速和安全失败"><span class="level-left"><span class="level-item">1.3.2.2</span><span class="level-item">2、List遍历快速和安全失败</span></span></a></li><li><a class="level is-mobile" href="#3、详细介绍HashMap"><span class="level-left"><span class="level-item">1.3.2.3</span><span class="level-item">3、详细介绍HashMap</span></span></a></li><li><a class="level is-mobile" href="#4、ConcurrentHashMap"><span class="level-left"><span class="level-item">1.3.2.4</span><span class="level-item">**4、ConcurrentHashMap **</span></span></a></li><li><a class="level is-mobile" href="#5、序列化和反序列化"><span class="level-left"><span class="level-item">1.3.2.5</span><span class="level-item">5、序列化和反序列化</span></span></a></li><li><a class="level is-mobile" href="#6、String"><span class="level-left"><span class="level-item">1.3.2.6</span><span class="level-item">6、String</span></span></a></li></ul></li><li><a class="level is-mobile" href="#设计模式与原则"><span class="level-left"><span class="level-item">1.3.3</span><span class="level-item">设计模式与原则</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、单例模式"><span class="level-left"><span class="level-item">1.3.3.1</span><span class="level-item">1、单例模式</span></span></a></li><li><a class="level is-mobile" href="#2、工厂模式"><span class="level-left"><span class="level-item">1.3.3.2</span><span class="level-item">2、工厂模式</span></span></a></li><li><a class="level is-mobile" href="#3、抽象工厂模式"><span class="level-left"><span class="level-item">1.3.3.3</span><span class="level-item">3、抽象工厂模式</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#面试题"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">面试题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#构造方法"><span class="level-left"><span class="level-item">1.4.1</span><span class="level-item">构造方法</span></span></a></li><li><a class="level is-mobile" href="#初始化块"><span class="level-left"><span class="level-item">1.4.2</span><span class="level-item">初始化块</span></span></a></li><li><a class="level is-mobile" href="#This"><span class="level-left"><span class="level-item">1.4.3</span><span class="level-item">This</span></span></a></li><li><a class="level is-mobile" href="#重写和重载的区别"><span class="level-left"><span class="level-item">1.4.4</span><span class="level-item">重写和重载的区别</span></span></a></li><li><a class="level is-mobile" href="#Object类方法"><span class="level-left"><span class="level-item">1.4.5</span><span class="level-item">Object类方法</span></span></a></li><li><a class="level is-mobile" href="#基本数据类型和包装类"><span class="level-left"><span class="level-item">1.4.6</span><span class="level-item">基本数据类型和包装类</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#二、JVM篇"><span class="level-left"><span class="level-item">2</span><span class="level-item">二、JVM篇</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#JVM内存划分"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">JVM内存划分</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、JVM运行时数据区域"><span class="level-left"><span class="level-item">2.1.1.1</span><span class="level-item">1、JVM运行时数据区域</span></span></a></li><li><a class="level is-mobile" href="#2、堆内存分配策略"><span class="level-left"><span class="level-item">2.1.1.2</span><span class="level-item">2、堆内存分配策略</span></span></a></li><li><a class="level is-mobile" href="#3、创建一个对象的步骤"><span class="level-left"><span class="level-item">2.1.1.3</span><span class="level-item">3、创建一个对象的步骤</span></span></a></li><li><a class="level is-mobile" href="#4、对象引用"><span class="level-left"><span class="level-item">2.1.1.4</span><span class="level-item">4、对象引用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#JVM类加载过程"><span class="level-left"><span class="level-item">2.1.2</span><span class="level-item">JVM类加载过程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、双亲委派机制"><span class="level-left"><span class="level-item">2.1.2.1</span><span class="level-item">1、双亲委派机制</span></span></a></li><li><a class="level is-mobile" href="#2、tomcat的类加载机制"><span class="level-left"><span class="level-item">2.1.2.2</span><span class="level-item">2、tomcat的类加载机制</span></span></a></li></ul></li><li><a class="level is-mobile" href="#JVM垃圾回收"><span class="level-left"><span class="level-item">2.1.3</span><span class="level-item">JVM垃圾回收</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、存活算法和两次标记过程"><span class="level-left"><span class="level-item">2.1.3.1</span><span class="level-item">1、存活算法和两次标记过程</span></span></a></li><li><a class="level is-mobile" href="#2、垃圾回收算法"><span class="level-left"><span class="level-item">2.1.3.2</span><span class="level-item">2、垃圾回收算法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#MinorGC、MajorGC、FullGC"><span class="level-left"><span class="level-item">2.1.3.2.1</span><span class="level-item">MinorGC、MajorGC、FullGC</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3、垃圾收集器"><span class="level-left"><span class="level-item">2.1.3.3</span><span class="level-item">3、垃圾收集器</span></span></a></li><li><a class="level is-mobile" href="#4、配置垃圾收集器"><span class="level-left"><span class="level-item">2.1.3.4</span><span class="level-item">4、配置垃圾收集器</span></span></a></li><li><a class="level is-mobile" href="#4、JVM性能调优"><span class="level-left"><span class="level-item">2.1.3.5</span><span class="level-item">4、JVM性能调优</span></span></a></li><li><a class="level is-mobile" href="#5、JDK新特性"><span class="level-left"><span class="level-item">2.1.3.6</span><span class="level-item">5、JDK新特性</span></span></a></li></ul></li></ul></ul></li><li><a class="level is-mobile" href="#三、多线程篇"><span class="level-left"><span class="level-item">3</span><span class="level-item">三、多线程篇</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#线程调度"><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">线程调度</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、线程状态"><span class="level-left"><span class="level-item">3.1.1.1</span><span class="level-item">1、线程状态</span></span></a></li><li><a class="level is-mobile" href="#2、线程状态切换"><span class="level-left"><span class="level-item">3.1.1.2</span><span class="level-item">2、线程状态切换</span></span></a></li><li><a class="level is-mobile" href="#3、阻塞唤醒过程"><span class="level-left"><span class="level-item">3.1.1.3</span><span class="level-item">3、阻塞唤醒过程</span></span></a></li><li><a class="level is-mobile" href="#4、wait和sleep区别"><span class="level-left"><span class="level-item">3.1.1.4</span><span class="level-item">4、wait和sleep区别</span></span></a></li><li><a class="level is-mobile" href="#5、创建线程方式"><span class="level-left"><span class="level-item">3.1.1.5</span><span class="level-item">5、创建线程方式</span></span></a></li></ul></li><li><a class="level is-mobile" href="#线程池"><span class="level-left"><span class="level-item">3.1.2</span><span class="level-item">线程池</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、线程池构造函数"><span class="level-left"><span class="level-item">3.1.2.1</span><span class="level-item">1、线程池构造函数</span></span></a></li><li><a class="level is-mobile" href="#2、线程处理任务过程："><span class="level-left"><span class="level-item">3.1.2.2</span><span class="level-item">2、线程处理任务过程：</span></span></a></li><li><a class="level is-mobile" href="#3、线程拒绝策略"><span class="level-left"><span class="level-item">3.1.2.3</span><span class="level-item">3、线程拒绝策略</span></span></a></li><li><a class="level is-mobile" href="#4、Execuors类实现线程池"><span class="level-left"><span class="level-item">3.1.2.4</span><span class="level-item">4、Execuors类实现线程池</span></span></a></li><li><a class="level is-mobile" href="#5、线程池大小设置"><span class="level-left"><span class="level-item">3.1.2.5</span><span class="level-item">5、线程池大小设置</span></span></a></li></ul></li><li><a class="level is-mobile" href="#线程安全"><span class="level-left"><span class="level-item">3.1.3</span><span class="level-item">线程安全</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、乐观锁，CAS思想"><span class="level-left"><span class="level-item">3.1.3.1</span><span class="level-item">1、乐观锁，CAS思想</span></span></a></li><li><a class="level is-mobile" href="#2、synchronized底层实现"><span class="level-left"><span class="level-item">3.1.3.2</span><span class="level-item">2、synchronized底层实现</span></span></a></li><li><a class="level is-mobile" href="#3、ReenTrantLock底层实现"><span class="level-left"><span class="level-item">3.1.3.3</span><span class="level-item">3、ReenTrantLock底层实现</span></span></a></li><li><a class="level is-mobile" href="#4、公平锁和非公平锁区别"><span class="level-left"><span class="level-item">3.1.3.4</span><span class="level-item">4、公平锁和非公平锁区别</span></span></a></li><li><a class="level is-mobile" href="#5、使用层面锁优化"><span class="level-left"><span class="level-item">3.1.3.5</span><span class="level-item">5、使用层面锁优化</span></span></a></li><li><a class="level is-mobile" href="#6、系统层面锁优化"><span class="level-left"><span class="level-item">3.1.3.6</span><span class="level-item">6、系统层面锁优化</span></span></a></li><li><a class="level is-mobile" href="#7、ThreadLocal原理"><span class="level-left"><span class="level-item">3.1.3.7</span><span class="level-item">7、ThreadLocal原理</span></span></a></li><li><a class="level is-mobile" href="#8、HashMap线程安全"><span class="level-left"><span class="level-item">3.1.3.8</span><span class="level-item">8、HashMap线程安全</span></span></a></li><li><a class="level is-mobile" href="#9、String不可变原因"><span class="level-left"><span class="level-item">3.1.3.9</span><span class="level-item">9、String不可变原因</span></span></a></li></ul></li><li><a class="level is-mobile" href="#内存模型"><span class="level-left"><span class="level-item">3.1.4</span><span class="level-item">内存模型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、volatile底层实现"><span class="level-left"><span class="level-item">3.1.4.1</span><span class="level-item">1、volatile底层实现</span></span></a></li><li><a class="level is-mobile" href="#2、AQS思想"><span class="level-left"><span class="level-item">3.1.4.2</span><span class="level-item">2、AQS思想</span></span></a></li><li><a class="level is-mobile" href="#3、happens-before"><span class="level-left"><span class="level-item">3.1.4.3</span><span class="level-item">3、happens-before</span></span></a></li></ul></li></ul></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatarPng.png" alt="White Crow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">White Crow</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">81</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">4</p></a></div></div></nav></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatarCircle.png" alt="Crow&#039;s Sky" height="28"></a><p class="is-size-7"><span>&copy; 2025 white crow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://github.com/WhileCrow"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>